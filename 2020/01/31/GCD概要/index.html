<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/Blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/Blog/css/main.css">


<link rel="stylesheet" href="/Blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/Blog/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="什么是GCDGrand Central Dispatch（GCD）是异步执行任务的技术之一。一般将应用程序中记述的线程管理用的代码在系统级中实现。开发者只需要定义想要执行的任务并追加到适当的 Dispatch Queue 中，GCD 就能生成必要的线程并计划执行任务。由于线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，这样就比以前的线程更有效率。 在导入GCD之前，Cocoa 框">
<meta property="og:type" content="article">
<meta property="og:title" content="GCD概要">
<meta property="og:url" content="https://github.com/DavidWanderer/Blog/2020/01/31/GCD%E6%A6%82%E8%A6%81/index.html">
<meta property="og:site_name" content="Stay hungry, Stay foolish.">
<meta property="og:description" content="什么是GCDGrand Central Dispatch（GCD）是异步执行任务的技术之一。一般将应用程序中记述的线程管理用的代码在系统级中实现。开发者只需要定义想要执行的任务并追加到适当的 Dispatch Queue 中，GCD 就能生成必要的线程并计划执行任务。由于线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，这样就比以前的线程更有效率。 在导入GCD之前，Cocoa 框">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/Blog/2020/01/31/GCD%E6%A6%82%E8%A6%81/snip1.png">
<meta property="og:image" content="https://github.com/Blog/2020/01/31/GCD%E6%A6%82%E8%A6%81/snip2.png">
<meta property="og:image" content="https://github.com/Blog/2020/01/31/GCD%E6%A6%82%E8%A6%81/snip3.png">
<meta property="article:published_time" content="2020-01-31T04:44:51.000Z">
<meta property="article:modified_time" content="2021-04-15T16:09:02.000Z">
<meta property="article:author" content="听月的博客">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/Blog/2020/01/31/GCD%E6%A6%82%E8%A6%81/snip1.png">

<link rel="canonical" href="https://github.com/DavidWanderer/Blog/2020/01/31/GCD%E6%A6%82%E8%A6%81/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>GCD概要 | Stay hungry, Stay foolish.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/Blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Stay hungry, Stay foolish.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/Blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/Blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/Blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/Blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/DavidWanderer/Blog/2020/01/31/GCD%E6%A6%82%E8%A6%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="听月的博客">
      <meta itemprop="description" content="Your dreams don't work unless you do.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stay hungry, Stay foolish.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          GCD概要
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-31 12:44:51" itemprop="dateCreated datePublished" datetime="2020-01-31T12:44:51+08:00">2020-01-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="什么是GCD"><a href="#什么是GCD" class="headerlink" title="什么是GCD"></a>什么是GCD</h2><p>Grand Central Dispatch（GCD）是异步执行任务的技术之一。一般将应用程序中记述的线程管理用的代码在系统级中实现。开发者只需要定义想要执行的任务并追加到适当的 Dispatch Queue 中，GCD 就能生成必要的线程并计划执行任务。由于线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，这样就比以前的线程更有效率。</p>
<p>在导入GCD之前，Cocoa 框架提供了 NSObject 类的 performSelectorInBackground:withObject 实例方法和 performSelectorOnMainThread 实例方法等简单的多线程编程技术。</p>
<h3 id="dispatch-after-用法"><a href="#dispatch-after-用法" class="headerlink" title="dispatch_after 用法"></a>dispatch_after 用法</h3><p>在3秒后将指定的 Block 追加到 Main Dispatch Queue 中的源代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;begin...&quot;);</span><br><span class="line">    </span><br><span class="line">&#x2F;**</span><br><span class="line"> 因为 Main Dispatch Queue 在主线程的 RunLoop 中执行，所以在比如每隔1&#x2F;60秒执行的 RunLoop 中，Block 最快在3秒后执行，最慢在3秒+1&#x2F;60秒后执行，</span><br><span class="line"> 并且在 Main Dispatch Queue 有大量处理追加或主线程的处理本身有延迟时，这个时间会更长。虽然在有严格时间的要求下使用会出现问题，但在想大致延迟执行处</span><br><span class="line"> 理时，该函数是非常有效的。</span><br><span class="line"> *&#x2F;</span><br><span class="line">dispatch_time_t time &#x3D; dispatch_time(DISPATCH_TIME_NOW, 3ull * NSEC_PER_SEC);</span><br><span class="line">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;waited at least three seconds.&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;end...&quot;);</span><br></pre></td></tr></table></figure>

<p>第一个参数是指定时间用的 dispatch_time_t 类型的值。该值使用 dispatch_time 函数或 dispatch_walltime 函数生成。</p>
<p>dispatch_time 函数能够获取从第一个参数 dispatch_time_t 类型值中指定的时间开始，到第二个参数指定的毫微秒单位时间后的时间。第一个参数经常使用的值是之前源代码中出现的DISPATCH_TIME_NOW。这表示现在的时间。即以下源代码可得到表示从现在开始1秒后的 dispatch_time_t 类型的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time &#x3D; dispatch_time(DISPATCH_TIME_NOW, 1ull * NSEC_PER_SEC);</span><br></pre></td></tr></table></figure>

<p>数值和 NSEC_PER_SEC 的乘积得到单位为毫微秒的数值。“ull”是C语言的数值字面量，是显示表明类型时使用的字符串（表示“unsigned long long”）。如果使用 NSEC_PER_MSEC 则可以以毫秒为单位计算。以下源代码获取表示从现在开始150毫秒后时间的值。TI</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time &#x3D; dispatch_time(DISPATCH_TIME_NOW, 150ull * NSEC_PER_MSEC);</span><br></pre></td></tr></table></figure>

<p>dispatch_walltime 函数由 POSIX 中使用的 struct timespec 类型的时间得到 dispatch_time_t 类型的值。dispatch_time 函数通常用于计算时间，而 dispatch_walltime 函数用于计算绝对时间。例如在 dispatch_after 函数中想指定 2020年01月01日01时01分01秒这一绝对时间的情况，这可以作为粗略的闹钟功能使用。</p>
<p>struct timespec 类型的时间可以很轻松的通过 NSDate 类对象生成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t getDispatchTimeByDate(NSDate *date) &#123;</span><br><span class="line">    NSTimeInterval interval;</span><br><span class="line">    double second, subsecond;</span><br><span class="line">    struct timespec time;</span><br><span class="line">    dispatch_time_t milestone;</span><br><span class="line">    </span><br><span class="line">    interval &#x3D; [date timeIntervalSince1970];</span><br><span class="line">    subsecond &#x3D; modf(interval, &amp;second);</span><br><span class="line">    time.tv_sec &#x3D; second;</span><br><span class="line">    time.tv_nsec &#x3D; subsecond * NSEC_PER_SEC;</span><br><span class="line">    milestone &#x3D; dispatch_walltime(&amp;time, 0);</span><br><span class="line">    </span><br><span class="line">    return milestone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的源代码可由 NSDate 类对象获取能传递给 dispatch_after 函数的 dispatch_time_t 类型的值。</p>
<h3 id="dispatch-group-t-用法"><a href="#dispatch-group-t-用法" class="headerlink" title="dispatch_group_t 用法"></a>dispatch_group_t 用法</h3><p>在追加到 Dispatch Queue 中的多个处理全部结束后想执行结束处理，这种情况会经常出现。</p>
<p>例如下面代码：追加3个 Block 到 Global Dispatch Queue，这些 Block 如果全部执行完毕，就会执行 Main Dispatch Queue 中结束处理用的 Block。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDispatchGroupNotify &#123;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;blk0&quot;);&#125;);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;blk2&quot;);&#125;);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;blk3&quot;);&#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;NSLog(@&quot;done&quot;);&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论向什么样的 Dispatch Queue 中追加处理，使用 Dispatch Queue 都可以监视这些处理执行的结束。一旦检测到所有的处理执行结束，就可以将结束的处理追加到 Dispatch Queue 中。这就是使用</p>
<p>Dispatch Group 的原因。</p>
<p>在Dispatch Group中也可以使用 dispatch_group_wait 函数仅等待全部处理执行结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDispatchGroupWait1 &#123;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;blk0&quot;);&#125;);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;blk1&quot;);&#125;);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;blk2&quot;);&#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;done.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dispatch_group_wait 函数的第二个参数指定为等待时间（超时）。它属于 dispatch_time_t 类型的值。该源代码使用 DISPATCH_DISPATCH_TIME_FOREVER，意味着永久等待。只要属于Dispatch Group 的处理尚未结束，就会一直等待，中途不能取消。</p>
<p>如同 dispatch_after 函数说明的那样，指定等待间隔为1秒时应做如下处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDispatchGroupWait2 &#123;</span><br><span class="line">    dispatch_time_t time &#x3D; dispatch_time(DISPATCH_TIME_NOW, 1ull * NSEC_PER_SEC);</span><br><span class="line">    dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">    long result &#x3D; dispatch_group_wait(group, time);</span><br><span class="line">    if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         属于 Dispatch Group 的全部处理执行结束</span><br><span class="line">         *&#x2F;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         属于 Dispatch Group 的某一个处理还在执行中</span><br><span class="line">         *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 dispatch_group_wait 函数的返回值不为0，就意味着虽然经过了指定的时间，但属于 Dispatch Group 的某一个处理还在执行中。如果返回值为0，那么全部处理执行结束。当等待时间为 DISPATCH_TIME_FOREVER，由 dispatch_group_wait 函数返回时，由于属于 Dispatch Group 的处理必定全部执行结束，因此返回值恒为0。</p>
<p>这里的“等待”是什么意思呢？这意味着一旦调用 dispatch_group_wait 函数，该函数就处于调用的状态而不返回。即执行 dispatch_group_wait 函数的所在的线程停止。在经过 dispatch_group_wait 函数中指定的时间或属于指定 Dispatch Group 的处理全部执行结束之前，执行该函数的线程停止。</p>
<h3 id="dispatch-barrier-async-用法"><a href="#dispatch-barrier-async-用法" class="headerlink" title="dispatch_barrier_async 用法"></a>dispatch_barrier_async 用法</h3><p>如果像下面这样简单地在 dispatch_async 函数中加入写入处理，那么根据 Concurrent Dispatch Queue 的性质，就有可能在写入处理前面的读取处理中读取到与期待不符的数据，还可能因非法访问导致应用程序异常结束。如果追加多个写入处理，则可能发生更多的问题，比如数据竞争等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)testReadAndWrite &#123;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;com.gcd.barrier&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk0_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk1_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk2_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk3_for_reading&quot;);&#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk_for_writing&quot;);&#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk4_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk5_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk6_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk7_for_reading&quot;);&#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2020-02-01 10:33:21.908239+0800 GCD_Demo[1852:30606] blk0_for_reading</span><br><span class="line">2020-02-01 10:33:21.908272+0800 GCD_Demo[1852:30354] blk1_for_reading</span><br><span class="line">2020-02-01 10:33:21.908349+0800 GCD_Demo[1852:30705] blk2_for_reading</span><br><span class="line">2020-02-01 10:33:21.908409+0800 GCD_Demo[1852:30706] blk3_for_reading</span><br><span class="line">2020-02-01 10:33:21.908446+0800 GCD_Demo[1852:30606] blk4_for_reading</span><br><span class="line">2020-02-01 10:33:21.908464+0800 GCD_Demo[1852:30354] blk5_for_reading</span><br><span class="line">2020-02-01 10:33:21.908466+0800 GCD_Demo[1852:30707] blk_for_writing</span><br><span class="line">2020-02-01 10:33:21.908490+0800 GCD_Demo[1852:30705] blk6_for_reading</span><br><span class="line">2020-02-01 10:33:21.908498+0800 GCD_Demo[1852:30708] blk7_for_reading</span><br></pre></td></tr></table></figure>

<p>因此我们要使用 dispatch_barrier_async 函数。dispatch_barrier_async 函数会等待追加到 Concurrent Dispatch Queue 上的并行执行的处理全部结束之后，再将指定的处理追加到该 Concurrent Dispatch Queue 中。然后在由 dispatch_barrier_async 函数追加的处理执行完毕后，Concurrent Dispatch Queue 才恢复为一般的动作，追加到该 Concurrent Dispatch Queue 的处理又开始并行执行。</p>
<p>使用 dispatch_barrier_async 的代码示例如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)testReadAndWrite2 &#123;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;com.gcd.barrier&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk0_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk1_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk2_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk3_for_reading&quot;);&#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;NSLog(@&quot;blk_for_writing&quot;);&#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk4_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk5_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk6_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk7_for_reading&quot;);&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行的结果如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">59.739217</span>+<span class="number">0800</span> GCD_Demo[<span class="number">2063</span>:<span class="number">43192</span>] blk0_for_reading</span><br><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">59.739225</span>+<span class="number">0800</span> GCD_Demo[<span class="number">2063</span>:<span class="number">43191</span>] blk1_for_reading</span><br><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">59.739240</span>+<span class="number">0800</span> GCD_Demo[<span class="number">2063</span>:<span class="number">42655</span>] blk2_for_reading</span><br><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">59.739244</span>+<span class="number">0800</span> GCD_Demo[<span class="number">2063</span>:<span class="number">43193</span>] blk3_for_reading</span><br><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">59.739375</span>+<span class="number">0800</span> GCD_Demo[<span class="number">2063</span>:<span class="number">43193</span>] blk_for_writing</span><br><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">59.739480</span>+<span class="number">0800</span> GCD_Demo[<span class="number">2063</span>:<span class="number">42655</span>] blk5_for_reading</span><br><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">59.739483</span>+<span class="number">0800</span> GCD_Demo[<span class="number">2063</span>:<span class="number">43193</span>] blk4_for_reading</span><br><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">59.739503</span>+<span class="number">0800</span> GCD_Demo[<span class="number">2063</span>:<span class="number">43191</span>] blk6_for_reading</span><br><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">59.739510</span>+<span class="number">0800</span> GCD_Demo[<span class="number">2063</span>:<span class="number">43192</span>] blk7_for_reading</span><br></pre></td></tr></table></figure>

<p>使用 Concurrent Dispatch Queue 和 dispatch_barrier_async 函数可实现高效率的数据库访问和文件访问。</p>
<p>dispatch_barrier_async 函数的处理流程图：</p>
<img src="/Blog/2020/01/31/GCD%E6%A6%82%E8%A6%81/snip1.png" class="" title="dispatch_barrier_async函数处理流程图">

<h3 id="dispatch-sync-用法"><a href="#dispatch-sync-用法" class="headerlink" title="dispatch_sync 用法"></a>dispatch_sync 用法</h3><p>dispatch_async 函数，就是将指定的Block“非同步”地追加到指定的 Dispatch Queue 中，dispatch_async 函数不做任何等待。</p>
<img src="/Blog/2020/01/31/GCD%E6%A6%82%E8%A6%81/snip2.png" class="" title="dispatch_async 函数的处理流程">

<p>dispatch_sync 函数，就是将指定的Block“同步”地追加到指定的 Dispatch Queue 中。在追加的Block结束之前，dispatch_sync 函数会一直等待。如 dispatch_group_wait 函数一样，“等待”意味着当前线程停止。</p>
<img src="/Blog/2020/01/31/GCD%E6%A6%82%E8%A6%81/snip3.png" class="" title="dispatch_sync 函数的处理流程">

<p>我们先假设这样一种情况，执行 Main Dispatch Queue 时，使用另外的线程 Global Dispatch Queue 进行处理，处理结束后立即使用所得到的结果。在这种情况下就要使用 dispatch_sync 函数。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;<span class="comment">/* 处理 */</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>一旦调用 dispatch_sync 函数，那么在指定的处理执行结束之前，该函数不会返回。dispatch_sync 函数可简化源代码，也可说是简易版的 dispatch_group_wait 函数。正因为 dispatch_sync 函数使用简单，所以也容易引起问题，即死锁。</p>
<p>例如如果在主线程中执行以下源代码就会死锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDispatchSync1 &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;begin...&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_main_queue();</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;Hello&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;end...&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该源代码在 Main Dispatch Queue 即主线程中执行指定的Block，并等待其执行结束。而其实在主线程中正在执行这些源代码，所以无法执行追加到 Main Dispatch Queue 的Block。下面的例子也一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDispatchSync2 &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;begin...&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_main_queue();</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        dispatch_sync(queue, ^&#123;NSLog(@&quot;Hello&quot;);&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;end...&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Main Dispatch Queue 中执行的Block等待 Main Dispatch Queue 中要执行的Block 执行结束。这样的死锁就像在画像上画画一样。</p>
<p>当然 Serial Dispatch Queue 也会引起相同的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDispatchSync3 &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;begin...&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;com.gcd.mySerialDispatchQueue&quot;, NULL);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        dispatch_sync(queue, ^&#123;NSLog(@&quot;Hello&quot;);&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;end...&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由 dispatch_barrier_async 函数中含有 async 可推测出，相应的也有 dispatch_barrier_sync 函数。dispatch_barrier_async 函数的作用是在等待追加的处理全部执行结束后，再追加处理到 Dispatch Queue 中，此外，它还与 dispatch_sync 函数相同，会等待追加处理的执行结束。</p>
<h3 id="dispatch-apply-用法"><a href="#dispatch-apply-用法" class="headerlink" title="dispatch_apply 用法"></a>dispatch_apply 用法</h3><p>dispatch_apply 函数是 dispatch_sync 函数和 Dispatch Group 的关联 API。该函数按指定的次数将指定的Block追加到指定的 Dispatch Queue中，并等待全部处理执行结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDispatchApply1 &#123;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_apply(10, queue, ^(size_t index) &#123;</span><br><span class="line">        NSLog(@&quot;blk %zu&quot;, index);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;done&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2020-02-01 12:40:31.343067+0800 GCD_Demo[3361:105895] blk 1</span><br><span class="line">2020-02-01 12:40:31.343067+0800 GCD_Demo[3361:105839] blk 2</span><br><span class="line">2020-02-01 12:40:31.343074+0800 GCD_Demo[3361:105885] blk 0</span><br><span class="line">2020-02-01 12:40:31.343078+0800 GCD_Demo[3361:105940] blk 4</span><br><span class="line">2020-02-01 12:40:31.343079+0800 GCD_Demo[3361:105941] blk 7</span><br><span class="line">2020-02-01 12:40:31.343078+0800 GCD_Demo[3361:105939] blk 3</span><br><span class="line">2020-02-01 12:40:31.343085+0800 GCD_Demo[3361:105894] blk 5</span><br><span class="line">2020-02-01 12:40:31.343085+0800 GCD_Demo[3361:105938] blk 6</span><br><span class="line">2020-02-01 12:40:31.343224+0800 GCD_Demo[3361:105895] blk 8</span><br><span class="line">2020-02-01 12:40:31.343235+0800 GCD_Demo[3361:105839] blk 9</span><br><span class="line">2020-02-01 12:40:31.343787+0800 GCD_Demo[3361:105839] done</span><br></pre></td></tr></table></figure>

<p>因为在 Global Dispatch Queue 中执行处理，所以各个处理的执行时间不定。但是输出结果中最后的 done 必定在最后的位置上。这是因为 dispatch_apply 函数会等待全部处理执行结束。</p>
<p>第一个参数为重复次数，第二个参数为追加对象的 Dispatch Queue，第三个参数为追加的处理。与到目前为止所出现的例子不同，第三个参数的Block为带有参数的Block。这是为了按第一个参数重复追加Block并区分各个Block而使用。例如要对 NSArray 类对象的所有元素执行处理时，不必一个一个编写 for 循环部分。</p>
<p>另外，由于 dispatch_apply 函数也与 dispatch_sync 函数相同，会等待处理执行结束，因此推荐在 dispatch_async 函数中非同步地执行 dispatch_apply 函数。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDispatchApply2 &#123;</span><br><span class="line">    </span><br><span class="line">    NSArray *array &#x3D; [NSArray arrayWithObjects:@&quot;obj1&quot;, @&quot;obj2&quot;, @&quot;obj3&quot;, @&quot;obj4&quot;, @&quot;obj5&quot;, @&quot;obj6&quot;, nil];</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    &#x2F;** 在 Global Dispatch Queue 中非同步执行 *&#x2F;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">       </span><br><span class="line">        &#x2F;**</span><br><span class="line">         Global Dispatch Queue</span><br><span class="line">         等待 dispatch_apply 函数中全部处理执行结束</span><br><span class="line">         *&#x2F;</span><br><span class="line">        dispatch_apply([array count], queue, ^(size_t index) &#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             并列处理包含在 NSArray 对象的全部对象</span><br><span class="line">             *&#x2F;</span><br><span class="line">            NSLog(@&quot;%zu: %@&quot;, index, [array objectAtIndex:index]);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;**</span><br><span class="line">         dispatch_apply 函数中的处理全部执行结束</span><br><span class="line">         *&#x2F;</span><br><span class="line">        </span><br><span class="line">        &#x2F;**</span><br><span class="line">         在 Main Dispatch Queue 中非同步执行</span><br><span class="line">         *&#x2F;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             在 Main Dispatch Queue 中执行处理</span><br><span class="line">             用户界面更新等</span><br><span class="line">             *&#x2F;</span><br><span class="line">            NSLog(@&quot;done&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2020-02-01 13:17:57.785290+0800 GCD_Demo[3821:122905] 4: obj5</span><br><span class="line">2020-02-01 13:17:57.785285+0800 GCD_Demo[3821:122911] 5: obj6</span><br><span class="line">2020-02-01 13:17:57.785283+0800 GCD_Demo[3821:122895] 3: obj4</span><br><span class="line">2020-02-01 13:17:57.785283+0800 GCD_Demo[3821:122896] 0: obj1</span><br><span class="line">2020-02-01 13:17:57.785283+0800 GCD_Demo[3821:122897] 2: obj3</span><br><span class="line">2020-02-01 13:17:57.785283+0800 GCD_Demo[3821:122894] 1: obj2</span><br><span class="line">2020-02-01 13:17:57.811750+0800 GCD_Demo[3821:122848] done</span><br></pre></td></tr></table></figure>

<h3 id="dispatch-suspend-dispatch-resume-用法"><a href="#dispatch-suspend-dispatch-resume-用法" class="headerlink" title="dispatch_suspend / dispatch_resume 用法"></a>dispatch_suspend / dispatch_resume 用法</h3><p>当追加大量处理到 Dispatch Queue 时，在追加处理的过程中，有时希望不执行已追加的处理。例如演算结果被Block截获时，一些处理会对这个演算结果造成影响。在这种情况下，只要挂起 Dispatch Queue 即可。当可以执行时再恢复。</p>
<p>dispatch_suspend 函数挂起指定的 Dispatch Queue。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_suspend(queue);</span><br></pre></td></tr></table></figure>

<p>Dispatch_resume 函数恢复指定的 Dispatch Queue。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_resume(queue);</span><br></pre></td></tr></table></figure>

<p>这些函数对已经执行的处理没有影响。挂起后，追加到 Dispatch Queue 中但尚未执行的处理在此之后停止执行。而恢复则使得这些处理能够继续执行。</p>
<h3 id="Dispatch-Semaphore-用法"><a href="#Dispatch-Semaphore-用法" class="headerlink" title="Dispatch Semaphore 用法"></a>Dispatch Semaphore 用法</h3><p>如前所述，当并行执行的处理更新数据时，会产生数据不一致的情况，有时应用程序还会异常结束。虽然使用 Serial Dispatch Queue 和 dispatch_barrier_async 函数可避免这类问题，但有必要进行更细粒度的排他控制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDispatchSemaphore1 &#123;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *array &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">    </span><br><span class="line">    for (int i&#x3D;0; i &lt; 10000; ++i) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            [array addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为该源代码使用 Global Dispatch Queue 更新 NSMutableArray 类对象，所以执行后由内存错误导致应用程序异常结束的概率很高。此时应使用 Dispatch Semephore。</p>
<p>Dispatch Semaphore 是持有计数的信号，该计数是多线程编程中的计数类型信号。所谓信号，类似于过马路时常用的手旗。可以通过时举起手旗，不可通过时放下手旗。而在Dispatch Semaphore中，使用计数来实现该功能。计数为0时等待，计数为1或大于1时，减去1而不等待。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore &#x3D; dispatch_semaphore_create(1);</span><br></pre></td></tr></table></figure>

<p>参数表示计数的初始值。本例将计数值初始化为“1”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>

<p>dispatch_semaphore_wait 函数等待 Dispatch Semaphore 的计数值达到大于或等于 1。当计数值大于等于1，或者在待机中计数值大于等于1时，对该计数进行减法并从 dispatch_semaphore_wait 函数返回。第二个参数与 dispatch_group_wait 函数等相同，由 dispatch_time_t 类型值指定等待时间。该例的参数意味着永久等待。另外，dispatch_semaphore_wait 函数的返回值也与 dispatch_group_wait 函数相同。可像以下源代码这样通过返回值进行分支处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time &#x3D; dispatch_time(DISPATCH_TIME_NOW, 1ull * NSEC_PER_SEC);</span><br><span class="line"></span><br><span class="line">long result &#x3D; dispatch_semaphore_wait(semaphore, time);</span><br><span class="line"></span><br><span class="line">if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	由于 Dispatch Semaphore 的计数值达到大于等于 1</span><br><span class="line">	或者在待机中指定的时间内</span><br><span class="line">	Dispatch Semaphore 的计数值达到大于等于 1</span><br><span class="line">	所以 Dispatch Semaphore 的计数值减去 1。</span><br><span class="line">	</span><br><span class="line">	可执行需要进行排他控制的处理</span><br><span class="line">	*&#x2F;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;**</span><br><span class="line">  由于 Dispatch Semaphore 的计数值为0</span><br><span class="line">  因此在达到指定时间为止待机</span><br><span class="line">  *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dispatch_semaphore_wait 函数返回0时，可安全地执行需要进行排他控制的处理。该处理结束时通过 dispatch_semaphore_signal 函数将 Dispatch Semaphore 的计数值加1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDispatchSemaphore2 &#123;</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     生成 Dispatch Semaphore</span><br><span class="line">     Dispatch Semaphore 的计数初始值设定为 “1”。</span><br><span class="line">     保证可访问 NSMutableArray 类对象的线程同时只能有1个。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    dispatch_semaphore_t semaphore &#x3D; dispatch_semaphore_create(1);</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *array &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; 100000; i++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">           &#x2F;**</span><br><span class="line">            等待 Dispatch Semaphore</span><br><span class="line">            一直等待，直到 Dispatch Semaphore 的计数值达到大于等于1。</span><br><span class="line">            *&#x2F;</span><br><span class="line">            dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">            </span><br><span class="line">            &#x2F;**</span><br><span class="line">             由于Dispatch Semaphore 的计数值达到大于等于1</span><br><span class="line">             所以将 Dispatch Semaphore 的计数值减去 1，</span><br><span class="line">             dispatch_semaphore_wait 函数执行返回。</span><br><span class="line"></span><br><span class="line">             即执行到此时的 Dispatch Semaphore 的计数值恒为 0。</span><br><span class="line">             </span><br><span class="line">             由于可访问 NSmutableArray 类对象的线程只有1个，因此可以安全的进行更新。</span><br><span class="line">             *&#x2F;</span><br><span class="line">            [array addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">            </span><br><span class="line">            &#x2F;**</span><br><span class="line">             排他控制处理结束，所以通过 dispatch_semaphore_signal 函数</span><br><span class="line">             将 Dispatch Semaphore 的计数值加1。</span><br><span class="line">             如果有通过 dispatch_semaphore_wait 函数</span><br><span class="line">             等待 Dispatch Semaphore 的计数值增加的线程，</span><br><span class="line">             就由最先等待的线程执行。</span><br><span class="line">             *&#x2F;</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dispatch-once-用法"><a href="#dispatch-once-用法" class="headerlink" title="dispatch_once 用法"></a>dispatch_once 用法</h3><p>dispatch_once 函数是保证在应用程序中只执行一次指定处理的API。如果使用 dispatch_once 函数，源代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDispatchOnce &#123;</span><br><span class="line">    </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         初始化</span><br><span class="line">         *&#x2F;</span><br><span class="line">        NSLog(@&quot;当前初始化代码只会执行一次&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 dispatch_once 函数，该源代码即使在多线程环境下执行，也可保证百分之百安全。在生成单例对象时使用。</p>
<h3 id="Dispatch-I-O-用法"><a href="#Dispatch-I-O-用法" class="headerlink" title="Dispatch I/O 用法"></a>Dispatch I/O 用法</h3><p>Dispatch I/O 和 Dispatch Data，可以做到一次使用多个线程更快地并列读取。dispatch_io_create 函数生成 Dispatch I/O，并指定发生错误时用来执行处理的Block，以及执行该Block的 Dispatch Queue。如果想提高文件读取速度，可以尝试使用 Dispatch I/O。</p>
<h3 id="Dispatch-Source-用法"><a href="#Dispatch-Source-用法" class="headerlink" title="Dispatch Source 用法"></a>Dispatch Source 用法</h3><p>GCD中除了主要的 Dispatch Queue 外，还有不太引人注目的 Dispatch Source。下面展示一个使用 DISPATCH_SOURCE_TYPE_TIMER 的定时器的例子。在网络编程的通信超时等情况下可使用该例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (void) testDispatchSource &#123;</span><br><span class="line">    </span><br><span class="line">    dispatch_source_t timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     将定时器设定为 15 秒后。</span><br><span class="line">     不指定为重复。</span><br><span class="line">     允许延迟 1 秒。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, 15ull * NSEC_PER_SEC), DISPATCH_TIME_FOREVER, 1ull * NSEC_PER_SEC);</span><br><span class="line">    </span><br><span class="line">    &#x2F;** 指定定时器指定时间内执行的处理 *&#x2F;</span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        NSLog(@&quot;wakeup!&quot;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;** 取消 Dispatch Source 时的处理 *&#x2F;</span><br><span class="line">        dispatch_source_cancel(timer);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;** 指定取消 Dispatch Source 时的处理 *&#x2F;</span><br><span class="line">    dispatch_source_set_cancel_handler(timer, ^&#123;</span><br><span class="line">        NSLog(@&quot;canceled&quot;);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;** 启动 Dispatch Source *&#x2F;</span><br><span class="line">    dispatch_resume(timer);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码在15秒之后会执行“wakeup!”打印，打印完就取消当前的定时器。实际上 Dispatch Queue 没有“取消”这一概念。一旦将处理追加到 Dispatch Queue 中，就没有方法将该处理去除，也没有方法可在执行中取消处理。编程人员要么在处理中导入取消这一概念，要么放弃取消，或者使用 NSOperationQueue 等其他方法。</p>
<p>Dispatch Source 与 Dispatch Queue 不同，是可以取消的。而且取消时必须执行的处理可以指定为回调的Block形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDownloadImg &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *url &#x3D; @&quot;http:&#x2F;&#x2F;images.apple.com&#x2F;jp&#x2F;iphone&#x2F;features&#x2F;includes&#x2F;camera-gallery&#x2F;03-20100607.jpg&quot;;</span><br><span class="line">    </span><br><span class="line">    [[NSURLSession sharedSession] dataTaskWithURL:[NSURL URLWithString:url] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            </span><br><span class="line">            if (!error) &#123;</span><br><span class="line">                </span><br><span class="line">                &#x2F;**</span><br><span class="line">                 在 Global Dispatch Queue 中对下载的数据进行解析处理，</span><br><span class="line">                 不妨碍主线程可长时间处理。</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                </span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    &#x2F;**</span><br><span class="line">                     在 Main Dispatch Queue 中使用解析结果，</span><br><span class="line">                     对用户界面尽心刷新处理。</span><br><span class="line">                     *&#x2F;</span><br><span class="line">                &#125;);</span><br><span class="line">                </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;** 发生错误 *&#x2F;</span><br><span class="line">                NSLog(@&quot;error:%@&quot;, error);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了不妨碍主线程的运行，在另外的线程中解析下载的数据。实现数据解析的就是通过 dispatch_get_global_queue 函数得到的一般优先级的 Global Dispatch Queue 和在 Global Dispatch Queue 中执行解析处理的 dispatch_async 函数。解析处理后为了反映到用户界面，需要在主线程中进行用户界面的更新。通过 dispatch_get_main_queue 函数得到的 Main Dispatch Queue 和在 Main Dispatch Queue 中使该处理执行的 dispatch_async 函数实现了此处理。</p>
<p>那么为了不妨碍主线程的运行，网络下载处理也是使用GCD的线程更好吗？答案是否定的。网络编程强烈推荐使用异步 API。如果在网络编程中使用线程，就很可能会产生大量使用线程的倾向，会引发很多问题。例如每个连接都使用线程，很快就会用尽线程栈内存等。因为Cocoa框架提供了用于异步网络通信的API，所以在网络编程中不可使用线程。务必使用用于异步网络通信的API。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p>《iOS与OS X多线程和内存管理》</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/Blog/tags/iOS/" rel="tag"># iOS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Blog/2020/01/27/%E6%9F%A5%E7%9C%8Bautoreleasepool%E7%9A%84%E7%8A%B6%E6%80%81/" rel="prev" title="查看autoreleasepool的状态">
      <i class="fa fa-chevron-left"></i> 查看autoreleasepool的状态
    </a></div>
      <div class="post-nav-item">
    <a href="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/" rel="next" title="iOS创建Framwork工程步骤">
      iOS创建Framwork工程步骤 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFGCD"><span class="nav-number">1.</span> <span class="nav-text">什么是GCD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-after-%E7%94%A8%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">dispatch_after 用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-group-t-%E7%94%A8%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">dispatch_group_t 用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-barrier-async-%E7%94%A8%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">dispatch_barrier_async 用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-sync-%E7%94%A8%E6%B3%95"><span class="nav-number">1.4.</span> <span class="nav-text">dispatch_sync 用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-apply-%E7%94%A8%E6%B3%95"><span class="nav-number">1.5.</span> <span class="nav-text">dispatch_apply 用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-suspend-dispatch-resume-%E7%94%A8%E6%B3%95"><span class="nav-number">1.6.</span> <span class="nav-text">dispatch_suspend &#x2F; dispatch_resume 用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dispatch-Semaphore-%E7%94%A8%E6%B3%95"><span class="nav-number">1.7.</span> <span class="nav-text">Dispatch Semaphore 用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-once-%E7%94%A8%E6%B3%95"><span class="nav-number">1.8.</span> <span class="nav-text">dispatch_once 用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dispatch-I-O-%E7%94%A8%E6%B3%95"><span class="nav-number">1.9.</span> <span class="nav-text">Dispatch I&#x2F;O 用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dispatch-Source-%E7%94%A8%E6%B3%95"><span class="nav-number">1.10.</span> <span class="nav-text">Dispatch Source 用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">1.10.1.</span> <span class="nav-text">参考链接</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">听月的博客</p>
  <div class="site-description" itemprop="description">Your dreams don't work unless you do.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/Blog/archives/">
        
          <span class="site-state-item-count">66</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/Blog/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/Blog/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">听月的博客</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">262k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:59</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/Blog/lib/anime.min.js"></script>
  <script src="/Blog/lib/velocity/velocity.min.js"></script>
  <script src="/Blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/Blog/js/utils.js"></script>

<script src="/Blog/js/motion.js"></script>


<script src="/Blog/js/schemes/pisces.js"></script>


<script src="/Blog/js/next-boot.js"></script>




  




  
<script src="/Blog/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'ce086645462b7a1b8271',
      clientSecret: '1d47ffa5ff3b39018245b87fd35ce20630d9a608',
      repo        : 'Blog',
      owner       : 'DavidWanderer',
      admin       : ['DavidWanderer'],
      id          : '6d8b28031e5cf85d3761d74b7e22ef91',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>


  

  <script async src="/Blog/js/cursor/love.min.js"></script>

</body>
</html>
