<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Block解析</title>
    <url>/Blog/2019/06/27/Block%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="Block底层解密"><a href="#Block底层解密" class="headerlink" title="Block底层解密"></a>Block底层解密</h2><p>block想必做过一段iOS开发的同学都用过吧，但是大部分人都是仅仅会用，不怎么理解他是怎么实现的，今天就让我们来一步一步的分析一下底层是怎么实现的吧。</p>
<h3 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) =  ^()&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;this is a block!&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样一个简单的<code>block</code>块大家都应该知道吧，但是这个<code>block</code>块是怎么实现的呢？</p>
<p>想要了解OC对象主要是基于C/C++的什么数据结构实现的，我们首先要做的就是将Object-C代码转化为C/C++代码，这样我们才能清楚的看清是怎么实现的</p>
<p>然后我们打开终端，在命令行找到cd到文件目录，然后中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc main.m</span><br></pre></td></tr></table></figure>
<p>执行结束以后，会生成<code>main.cpp</code>文件，我们打开<code>main.cpp</code>文件，拉到最下边就是我们的<code>main</code>函数实现的。</p>
<p>我们得到c++代码的block实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure>

<p>我们知道<code>(void *)</code>这种类型的都是类型的强制转换，为了更好的识别我们的这个Block代码，我们把类型转化去掉</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = &amp;__main_block_impl_0(__main_block_func_0,</span><br><span class="line">&amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure>

<p>我们在分别查询<code>__main_block_impl_0</code>,<code>__main_block_func_0</code>,<code>__main_block_desc_0_DATA</code>代表什么意思</p>
<p><strong>__main_block_impl_0</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="comment">// 构造函数（类似于OC的init方法），返回结构体对象</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们查看一下<code>__block_impl</code>里面是什么</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>__main_block_func_0</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装了block执行逻辑的函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_2r__m13fp2x2n9dvlr8d68yry500000gn_T_main_c60393_mi_0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>__main_block_desc_0_DATA</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;<span class="comment">//内存大小描述</span></span><br><span class="line">&#125; __main_block_desc_0_DATA</span><br></pre></td></tr></table></figure>


<p>所以我们可以总结</p>
<ul>
<li>1、<code>__main_block_impl_0</code>中<code>__block_impl</code>存放的是一些变量信息，其中存在<code>isa</code>，所以可以判断block的本质其实就是OC对象</li>
<li>2、初始化<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">  impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">  impl.Flags = flags;</span><br><span class="line">  impl.FuncPtr = fp;</span><br><span class="line">  Desc = desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们在来查看Block方法<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = &amp;__main_block_impl_0(__main_block_func_0,</span><br><span class="line">&amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure>
对应上面的初始化我们可以看出第一个参数传递的是<code>执行方法</code>，第二个参数为<code>描述信息</code></li>
</ul>
<p><strong>Block底层结构图</strong></p>
<img src="/Blog/2019/06/27/Block%E8%A7%A3%E6%9E%90/Block1.png" class="" title="Block截图">


<h3 id="成员变量的捕获"><a href="#成员变量的捕获" class="headerlink" title="成员变量的捕获"></a>成员变量的捕获</h3><p>为了保证block内部能够正常的访问外部变量，block有个变量捕获机制,这里我们先说结果，然后在进行证明</p>
<img src="/Blog/2019/06/27/Block%E8%A7%A3%E6%9E%90/Block2.png" class="" title="Block截图">

<p>我们在<code>main</code>函数写下这些代码，然后在把<code>main</code>函数生成c++代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> height = <span class="number">180</span>;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> weight = <span class="number">65</span>;</span><br><span class="line">    <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) =  ^()&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;age---------%d&quot;</span>,age);</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;weight---------%d&quot;</span>,weight);</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;height---------%d&quot;</span>,height);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们直接找到c++代码里面存放变量的结构体<code>__main_block_impl_0</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">int</span> *weight;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> _age, <span class="keyword">int</span> *_weight, <span class="keyword">int</span> flags=<span class="number">0</span>) : age(_age), weight(_weight) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以看到变量捕获为<code>age</code>,<code>*weight</code>,但是没有捕获到全局变量<code>height</code>。为了方便的理解，我们先来了解一些内存空间的分配。</p>
<ul>
<li>1、栈区(stack) 由编译器自动分配并释放，存放函数的参数值，局部变量等。栈空间分静态分配 和动态分配两种。静态分配是编译器完成的，比如自动变量(auto)的分配。动态分配由alloca函数完成。</li>
<li>2、堆区(heap) 由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收 ，比如在ios 中 alloc 都是存放在堆中。</li>
<li>3、全局区(静态区) (static) 全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后有系统释放。</li>
<li>4、程序代码区 存放函数的二进制代码</li>
</ul>
<p>总结：</p>
<ul>
<li>1、因为自动变量(auto)分配的内存空间在<code>栈区(stack)</code>，编译器会自动帮我们释放，如果我们把block写在另外一个方法中调用，自动变量<code>age</code>就会被释放，block在使用的时候就已经被释放了，所以需要重新copy一下</li>
<li>2、静态变量在程序结束后有系统释放，所以不需要担心被释放，block只需要知道他的内存地址就行</li>
<li>3、对于全局变量，任何时候都可以直接访问，所以根本就不需要捕获</li>
</ul>
<h3 id="Block类型"><a href="#Block类型" class="headerlink" title="Block类型"></a>Block类型</h3><p>block有3种类型，可以通过调用class方法或者isa指针查看具体的类型，但是最终都是继承者NSBlock类型</p>
<ul>
<li>1、__NSGlobalBlock__，没有访问auto变量</li>
<li>2、__NSStackBlock__，访问了auto变量</li>
<li>3、__NSMallocBlock__，__NSStackBlock__调用了copy方法</li>
</ul>
<p>她们的内存分配：</p>
<img src="/Blog/2019/06/27/Block%E8%A7%A3%E6%9E%90/Block3.png" class="" title="Block截图">


<p>每一种类型的Block调用copy后的结果</p>
<ul>
<li>1、__NSStackBlock__原来在栈区，copy以后从栈复制到堆</li>
<li>2、__NSGlobalBlock__原来在程序的数据段，copy以后什么也不做</li>
<li>3、__NSMallocBlock__原来在堆区，复制以后引用计数加1<br>我们来写一小段代码证明一下<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (^block1)(<span class="keyword">void</span>) =  ^()&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;block1&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">void</span> (^block2)(<span class="keyword">void</span>) =  ^()&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;block2&quot;</span>);</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;age---------%d&quot;</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> (^block3)(<span class="keyword">void</span>) = [ ^()&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;block3&quot;</span>);</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;age---------%d&quot;</span>,age);</span><br><span class="line">&#125; <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;block1:%@----&gt;block2:%@-----&gt;block3:%@&quot;</span>,[block1 <span class="keyword">class</span>],[block2 <span class="keyword">class</span>],[block3 <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure>
打印结果为：<img src="/Blog/2019/06/27/Block%E8%A7%A3%E6%9E%90/Block4.png" class="" title="Block截图">

</li>
</ul>
<p>为什么<code>block2</code>打印类型为<code>__NSMallocBlock__</code>,而不是<code>__NSStackBlock__</code>，因为ARC环境导致了，ARC会自动帮我们copy了一下<code>__NSStackBlock__</code>。</p>
<h3 id="auto变量修饰符-weak"><a href="#auto变量修饰符-weak" class="headerlink" title="auto变量修饰符__weak"></a>auto变量修饰符__weak</h3><p>在开始之前，我先说一下结论，然后我们在去印证</p>
<ul>
<li>1、当Block内部访问了auto变量时，如果block是在栈上，将不会对auto变量产生强引用。</li>
<li>2、如果block被拷贝到堆上，会根据auto变量的修饰符（__strong，__weak，__unsafe_unretained），对auto变量进行强引用或者弱引用。</li>
<li>3、如果block从堆上移除的时候，会调用block内部的dispose函数，该函数自动释放auto变量。</li>
<li>4、在多个block相互嵌套的时候，auto属性的释放取决于最后的那个强引用什么时候释放。</li>
</ul>
<p>下面我们把ARC环境变成MRC环境，同时稍微修改一下代码，我们在看看<code>dealloc</code>什么时候打印<br><code>选择项目 Target -&gt; Build Sttings -&gt; All -&gt; 搜索‘automatic’ -&gt; 把 Objective-C Automatic Reference Counting 设置为 NO</code></p>
<p>我们写一个<code>Person</code>类，在MRC环境，重写<code>dealloc</code>方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line">  [<span class="keyword">super</span> dealloc];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;person---&gt;dealloc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在<code>main</code>函数里面写下这个方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  Person *p = [[Person alloc] init];</span><br><span class="line">  [p release];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;--------&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>我们肯定都知道打印结果吧：先打印<code>person---&gt;dealloc</code>，然后打印<code>--------</code></p>
<p>如果我们添加一个Block呢,</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^Block)(<span class="keyword">void</span>);</span><br><span class="line">Block block;</span><br><span class="line">&#123;</span><br><span class="line">  Person *p = [[Person alloc] init];</span><br><span class="line">  block = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,p);</span><br><span class="line">  &#125;;</span><br><span class="line">  [p release];</span><br><span class="line">&#125;</span><br><span class="line">block();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;--------&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>打印结果为：</p>
<img src="/Blog/2019/06/27/Block%E8%A7%A3%E6%9E%90/Block5.png" class="" title="Block截图">


<p>在ARC环境下，代码稍微的改变一下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Block block;</span><br><span class="line">&#123;</span><br><span class="line">  Person *p = [[Person alloc] init];</span><br><span class="line">  block = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,p);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">block();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;--------&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>打印结果为：</p>
<img src="/Blog/2019/06/27/Block%E8%A7%A3%E6%9E%90/Block6.png" class="" title="Block截图">

<p><strong>注意打印顺序：</strong></p>
<ul>
<li>MRC环境下，是先打印<code>dealloc</code>，然后在打印<code>p</code>的</li>
<li>ARC环境下，是先打印<code>p</code>，然后在打印<code>dealloc</code>的</li>
</ul>
<p><code>当Block内部访问了auto变量时，如果block是在栈上，将不会对auto变量产生强引用,因为当Block在栈上的时候，他自己都不能保证自己什么时候被释放，所以block也就不会对自动变量进行强引用了</code></p>
<p>在ARC环境下如果我们对自动变量进行一些修饰符，那么block对auto变量是进行怎么引用呢<br>我们还是老方法，把main文件转化为c++文件，我们找到<code>__main_block_func_0</code>执行函数，</p>
<ul>
<li>当不用修饰符修饰的时：<code>Person *p = __cself-&gt;p; // bound by copy</code></li>
<li>当使用<code>__strong</code>修饰时：<code>Person *strongP = __cself-&gt;strongP; // bound by copy</code></li>
<li>当使用<code>__weak</code>修饰的时:<code>Person *__weak weakP = __cself-&gt;weakP; // bound by copy</code><br>我们运行<code> xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc main.m</code>出错了，我们需要支持ARC，指定运行时系统版本，<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m </code></li>
</ul>
<p><strong><em><code>Block会自动copy自动变量的修饰属性</code></em></strong></p>
<h3 id="Block修饰"><a href="#Block修饰" class="headerlink" title="__Block修饰"></a>__Block修饰</h3><p>我们都知道想要修改Block外边的变量，我们都会用<code>__Block</code>来修饰自动变量，但是为什么使用<code>__Block</code>修饰就可以在Block内部来更改自动变量了呢。</p>
<p>我们先写一小段代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;block前age地址1：%p&quot;</span>,&amp;age);</span><br><span class="line">Block block = ^&#123;</span><br><span class="line">  age = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;block内%d--&gt;age地址2：%p&quot;</span>,age,&amp;age);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;block后%d--&gt;age地址3：%p&quot;</span>,age,&amp;age);</span><br></pre></td></tr></table></figure>

<p>打印结果为：</p>
<img src="/Blog/2019/06/27/Block%E8%A7%A3%E6%9E%90/Block7.png" class="" title="Block截图">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据内存地址变化可见，__block所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。</span><br></pre></td></tr></table></figure>

<p>我们把<code>main</code>函数转化为C++代码，然后在age使用<code>__Block</code>前后，对Block结构体进行分析</p>
<img src="/Blog/2019/06/27/Block%E8%A7%A3%E6%9E%90/Block8.png" class="" title="Block截图">

<p>在<code>__Block</code>所起到的作用就是只要观察到该变量被 block 所持有之后，<code>age</code>其实变成了OC对象，里面含有<code>isa</code>指针</p>
<p><strong>__Block的内存管理原则</strong></p>
<ul>
<li>1、当Block在栈上的时候，并不会对<code>__Block</code>变量进行强引用</li>
<li>2、当block被copy到堆时,会调用block内部的copy函数,copy函数内部会调用_Block_object_assign函数,_Block_object_assign函数会对__block变量形成强引用（retain）</li>
<li>3、当block从堆中移除时，会调用block内部的dispose函数，dispose函数内部会调用_Block_object_dispose函数，_Block_object_dispose函数会自动释放引用的__block变量（release)</li>
</ul>
<img src="/Blog/2019/06/27/Block%E8%A7%A3%E6%9E%90/Block9.png" class="" title="Block截图">

<img src="/Blog/2019/06/27/Block%E8%A7%A3%E6%9E%90/Block10.png" class="" title="Block截图">

<img src="/Blog/2019/06/27/Block%E8%A7%A3%E6%9E%90/Block11.png" class="" title="Block截图">


<p>我们先看到了结果，这里我们在来分析一下源码<br><code>__block int age = 10;</code>转化为C++代码，会变成这样</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_age_0 age = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_age_0 *)&amp;age, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_age_0), <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了便于观察，我们可以将强制转化去掉</span></span><br><span class="line">__Block_byref_age_0 age = &#123;<span class="number">0</span>, &amp;age, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_age_0), <span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>唯一我们不太清楚的就是<code>__Block_byref_age_0</code>了，我们查找一下发现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (*Block)(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">struct</span> __Block_byref_age_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">  __Block_byref_age_0 *__forwarding;</span><br><span class="line">  <span class="keyword">int</span> __flags;</span><br><span class="line">  <span class="keyword">int</span> __size;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后我们在来查找Block实现代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_age_0 *age = __cself-&gt;age; <span class="comment">// bound by ref</span></span><br><span class="line">  (age-&gt;__forwarding-&gt;age) = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">NSLog</span>((<span class="built_in">NSString</span>*)&amp;__NSConstantStringImpl__var_folders_nb_9qtf99yd2qlbx2m97hdjf2yr0000gn_T_main_1757f5_mi_0,(age-&gt;__forwarding-&gt;age));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来查看一下age是怎么变成20的<code>(age-&gt;__forwarding-&gt;age) = 20;</code>，先是找到<code>__forwarding</code>结构体，然后在找到结构体里面的<code>age</code>。</p>
<p><strong>总结</strong></p>
<ul>
<li>1、在ARC环境下，Block被引用的时候，会被Copy一次，由栈区copy到了堆。</li>
<li>2、在Block被copy的时候，Block内部被引用的<code>变量</code>也同样被copy一份到了堆上面。</li>
<li>3、被__Block修饰的变量，在被Block引用的时候，会变成结构体也就是OC对象，里面的<code>__forwarding</code>也会由栈copy到堆上面。</li>
<li>4、栈上__block变量结构体中<code>__forwarding</code>的指针指向堆上面__block变量结构体，堆上__block变量结构体中<code>__forwarding</code>指针指向自己。</li>
<li>5、当block从堆中移除时，会调用block内部的dispose函数，dispose函数内部会调用_Block_object_dispose函数，_Block_object_dispose函数会自动释放引用的__block变量（release)。</li>
</ul>
<h3 id="解决循环引用"><a href="#解决循环引用" class="headerlink" title="解决循环引用"></a>解决循环引用</h3><p>我们看了那么长时间的源码了，一定还记得在auto变量为OC对象的时候，在没有修饰符修饰的时候Block内部会强引用OC对象，而对象如果也持有Block的时候就会造成相互引用，也就是循环引用的问题。</p>
<img src="/Blog/2019/06/27/Block%E8%A7%A3%E6%9E%90/Block12.png" class="" title="Block截图">

<p>我们也只能在Block持有OC对象的时候，给OC对象添加弱引用修饰符才比较合适，有两个弱引用修饰符<code>__weak</code>和<code>__unsafe_unretained</code></p>
<ul>
<li>1、 __weak：不会产生强引用，指向的对象销毁时，会自动让指针置为nil</li>
<li>2、__unsafe_unretained：不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变</li>
</ul>
<p>其实还有一种解决方法，那就是使用<code>__Block</code>,需要在Block内部把OC对象设置为nil</p>
<img src="/Blog/2019/06/27/Block%E8%A7%A3%E6%9E%90/Block13.png" class="" title="Block截图">

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block <span class="keyword">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">  weakSelf = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">self</span>.block();</span><br></pre></td></tr></table></figure>
<p>使用<code>__Block</code>解决必须调用Block</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6语法</title>
    <url>/Blog/2020/05/23/ES6%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="ES6新语法"><a href="#ES6新语法" class="headerlink" title="ES6新语法"></a>ES6新语法</h2><p>1.变量/赋值<br>var     可以重复定义，不能限制修改，没有块级作用域<br>let      不能重复定义，变量，块级作用域<br>const 不能重复定义，常量，块级作用域</p>
<p>解构赋值：<br>1.左右两边格式相同，右边必须是合法类型<br>2.必须是定义和赋值同步完成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>, <span class="number">12</span>, <span class="number">23</span>]；</span><br><span class="line"><span class="keyword">let</span> &#123;a, b, c&#125; = &#123;<span class="attr">a</span>: <span class="number">12</span>, <span class="attr">b</span>: <span class="number">89</span>, <span class="attr">c</span>: <span class="number">55</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>2.函数<br>    箭头函数<br>    function (参数，参数) {<br>        函数体<br>    }<br>    (参数，参数) =&gt; {<br>        函数体<br>    }<br>    1.如果有且仅有1个参数，()可以省<br>    2.如果函数体只有一句话，而且是return，{}可以省</p>
<p>​    默认参数<br>​        (a, b=xx, c=xxx)</p>
<p>​    参数展示<br>​        function show(a, b, …参数名)<br>​        剩余参数必须在参数列表的最后</p>
<p>3.数组/json</p>
<p>4.字符串</p>
<p>5.面向对象</p>
<p>6.Promise</p>
<p>7.generator</p>
<p>8.模块</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>GCD什么情况下会死锁?</title>
    <url>/Blog/2020/11/05/GCD%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<img src="/Blog/2020/11/05/GCD%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%AD%BB%E9%94%81/GCD%E6%AD%BB%E9%94%81.png" class="" title="GCD死锁情景分析图">

<blockquote>
<p>A serial dispatch queue runs only one task at a time, waiting until that task is complete before dequeuing and starting a new one. By contrast, a concurrent dispatch queue starts as many tasks as it can without waiting for already started tasks to finish.</p>
</blockquote>
<h2 id="串行队列-同步-同步"><a href="#串行队列-同步-同步" class="headerlink" title="串行队列-同步-同步"></a>串行队列-同步-同步</h2><p>运行结果：死锁。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">条件：串行队列，同步执行，同步执行。</span></span><br><span class="line"><span class="comment">结果：死锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) testMethod2 &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.serial&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;11&quot;</span>);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;22&quot;</span>);</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@&quot;33&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;44&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;55&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行截图：</p>
<img src="/Blog/2020/11/05/GCD%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%AD%BB%E9%94%81/1.png" class="" title="串行队列-同步-同步执行截图">

<h2 id="串行队列-同步-异步"><a href="#串行队列-同步-异步" class="headerlink" title="串行队列-同步-异步"></a>串行队列-同步-异步</h2><p>运行结果：不死锁，同步操作在主线程中执行，异步操作在子线程执行。为什么第一个同步操作没有死锁，因为第一个同步操作在“com.serial”这个队列里，而testMethod10在主队列里，虽然是同步操作，但是二者不属于同一个队列，不会互相阻塞。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">条件：串行队列，同步执行，异步执行。</span></span><br><span class="line"><span class="comment">结果：死锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) testMethod10 &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.serial&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;11, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;22, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@&quot;33, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;44, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;55, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行截图：</p>
<img src="/Blog/2020/11/05/GCD%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%AD%BB%E9%94%81/2.png" class="" title="串行队列-同步-异步执行截图">

<h2 id="串行队列-异步-同步"><a href="#串行队列-异步-同步" class="headerlink" title="串行队列-异步-同步"></a>串行队列-异步-同步</h2><p>运行结果：死锁。打印“22”、“44”的操作已经在串行队列上执行了，此时要求插入打印“33”的操作，这个同步操作造成“com.serial”串行队列死锁。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">条件：串行队列，异步执行，同步执行。</span></span><br><span class="line"><span class="comment">结果：死锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) testMethod5 &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.serial&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;11, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;22, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@&quot;33, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;44, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;55, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行截图：</p>
<img src="/Blog/2020/11/05/GCD%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%AD%BB%E9%94%81/3.png" class="" title="串行队列-异步-同步执行截图">

<h2 id="串行队列-异步-异步"><a href="#串行队列-异步-异步" class="headerlink" title="串行队列-异步-异步"></a>串行队列-异步-异步</h2><p>运行结果：不死锁。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">条件：串行队列，异步执行，异步执行。</span></span><br><span class="line"><span class="comment">结果：不死锁。</span></span><br><span class="line"><span class="comment">线程：创建了一个线程。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) testMethod8 &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.serial&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;11, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;22, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@&quot;33, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;44, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;55, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行截图：</p>
<img src="/Blog/2020/11/05/GCD%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%AD%BB%E9%94%81/4.png" class="" title="串行队列-异步-异步执行截图">

<h2 id="并发队列-同步-同步"><a href="#并发队列-同步-同步" class="headerlink" title="并发队列-同步-同步"></a>并发队列-同步-同步</h2><p>运行结果：不死锁。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">条件：并发队列，同步执行，同步执行。</span></span><br><span class="line"><span class="comment">结果：不死锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) testMethod3 &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.serial.11&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;11, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;22, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@&quot;33, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;44, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;55, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行截图：</p>
<img src="/Blog/2020/11/05/GCD%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%AD%BB%E9%94%81/5.png" class="" title="并发队列-同步-同步执行截图">

<h2 id="并发队列-同步-异步"><a href="#并发队列-同步-异步" class="headerlink" title="并发队列-同步-异步"></a>并发队列-同步-异步</h2><p>运行结果：不死锁。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">条件：并发队列，同步执行，异步执行。</span></span><br><span class="line"><span class="comment">结果：不死锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) testMethod11 &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.serial.11&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;11, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;22, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@&quot;33, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;44, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;55, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行截图：</p>
<img src="/Blog/2020/11/05/GCD%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%AD%BB%E9%94%81/6.png" class="" title="并发队列-同步-异步执行截图">

<h2 id="并发队列-异步-同步"><a href="#并发队列-异步-同步" class="headerlink" title="并发队列-异步-同步"></a>并发队列-异步-同步</h2><p>运行结果：不死锁。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">条件：并发队列，异步执行，同步执行。</span></span><br><span class="line"><span class="comment">结果：不死锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) testMethod6 &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.serial.11&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;11, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;22, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@&quot;33, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;44, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;55, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行截图：</p>
<img src="/Blog/2020/11/05/GCD%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%AD%BB%E9%94%81/7.png" class="" title="并发队列-异步-同步执行截图">

<h2 id="并发队列-异步-异步"><a href="#并发队列-异步-异步" class="headerlink" title="并发队列-异步-异步"></a>并发队列-异步-异步</h2><p>运行结果：不死锁。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">条件：并发队列，异步执行，异步执行。</span></span><br><span class="line"><span class="comment">结果：不死锁。</span></span><br><span class="line"><span class="comment">线程：创建了一个线程。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) testMethod9 &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.serial.11&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;11, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;22, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@&quot;33, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;44, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;55, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行截图：</p>
<img src="/Blog/2020/11/05/GCD%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%AD%BB%E9%94%81/8.png" class="" title="并发队列-异步-异步执行截图">

<h2 id="主队列-同步-同步"><a href="#主队列-同步-同步" class="headerlink" title="主队列-同步-同步"></a>主队列-同步-同步</h2><p>运行结果：死锁。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 条件：主队列，同步执行，同步执行。</span></span><br><span class="line"><span class="comment"> 结果：死锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) testMethod1 &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;11, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;22, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@&quot;33, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;44, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;55, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行截图：</p>
<img src="/Blog/2020/11/05/GCD%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%AD%BB%E9%94%81/9.png" class="" title="主队列-同步-同步执行截图">

<h2 id="主队列-同步-异步"><a href="#主队列-同步-异步" class="headerlink" title="主队列-同步-异步"></a>主队列-同步-异步</h2><p>运行结果：死锁。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">条件：主队列，同步执行，异步执行。</span></span><br><span class="line"><span class="comment">结果：死锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) testMethod12 &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;11, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;22, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@&quot;33, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;44, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;55, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行截图：</p>
<img src="/Blog/2020/11/05/GCD%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%AD%BB%E9%94%81/10.png" class="" title="主队列-同步-异步执行截图">

<h2 id="主队列-异步-同步"><a href="#主队列-异步-同步" class="headerlink" title="主队列-异步-同步"></a>主队列-异步-同步</h2><p>运行结果：死锁。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">条件：主队列，异步执行，同步执行。</span></span><br><span class="line"><span class="comment">结果：死锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) testMethod4 &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;11, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;22, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@&quot;33, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;44, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;55, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行截图：</p>
<img src="/Blog/2020/11/05/GCD%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%AD%BB%E9%94%81/11.png" class="" title="主队列-异步-同步执行截图">

<h2 id="主队列-异步-异步"><a href="#主队列-异步-异步" class="headerlink" title="主队列-异步-异步"></a>主队列-异步-异步</h2><p>运行结果：不死锁。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">条件：主队列，异步执行，异步执行。</span></span><br><span class="line"><span class="comment">结果：不死锁。</span></span><br><span class="line"><span class="comment">线程：主线程执行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) testMethod7 &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;11, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;22, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@&quot;33, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;44, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;55, %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行截图：</p>
<img src="/Blog/2020/11/05/GCD%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%AD%BB%E9%94%81/12.png" class="" title="主队列-异步-异步执行截图">

<p>总结：在并发队列上，无论是同步还是异步都不会发生死锁；主队列上只有异步执行的时候才不会发生死锁；串行队列是否发生死锁需要具体分析。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ConcurrencyandApplicationDesign/ConcurrencyandApplicationDesign.html">官方文档</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>GCD介绍</title>
    <url>/Blog/2020/07/04/GCD%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="GCD介绍"><a href="#GCD介绍" class="headerlink" title="GCD介绍"></a>GCD介绍</h2><ul>
<li>1、GCD简介</li>
<li>2、GCD任务和队列</li>
<li>3、GCD 的基本使用</li>
<li>4、GCD 线程间的通信</li>
<li>5、GCD 的其他方法（栅栏方法：dispatch_barrier_async、延时执行方法：dispatch_after、一次性代码（只执行一次）：dispatch_once、快速迭代方法：dispatch_apply、队列组：dispatch_group、信号量：dispatch_semaphore）</li>
</ul>
<h3 id="1、GCD简介"><a href="#1、GCD简介" class="headerlink" title="1、GCD简介"></a>1、GCD简介</h3><blockquote>
<p>Grand Central Dispatch(GCD) 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。</p>
</blockquote>
<p>GCD 的好处具体如下：</p>
<ul>
<li>GCD 可用于多核的并行运算</li>
<li>GCD 会自动利用更多的 CPU 内核（比如双核、四核）</li>
<li>GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>
<li>程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码</li>
</ul>
<h3 id="2、GCD任务和队列"><a href="#2、GCD任务和队列" class="headerlink" title="2、GCD任务和队列"></a>2、GCD任务和队列</h3><p>GCD 中两个核心概念：<b>任务</b> 和 <b>队列</b>。</p>
<h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p><strong>任务</strong>：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在 GCD 中是放在 block 中的。</p>
<ul>
<li><p><strong>同步执行（sync）</strong></p>
<ul>
<li>同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。</li>
<li>只能在当前线程中执行任务，<code>不具备</code>开启新线程的能力。</li>
</ul>
</li>
<li><p><strong>异步执行（async）</strong></p>
<ul>
<li>异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。</li>
<li>可以在新的线程中执行任务，<code>具备</code>开启新线程的能力。</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步执行任务创建方法</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">  <span class="comment">// 这里放同步执行任务代码</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步执行任务创建方法</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">  <span class="comment">// 这里放异步执行任务代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p><strong>队列（Dispatch Queue）</strong>：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。</p>
<ul>
<li><p><strong>串行队列（Serial Dispatch Queue）</strong></p>
<ul>
<li>每次只有一个任务被执行。让任务一个接着一个地执行。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）</li>
</ul>
</li>
<li><p><strong>并发队列（Concurrent Dispatch Queue）</strong></p>
<ul>
<li>可以让多个任务并发（同时）执行。（可以开启多个线程，并且同时执行任务）</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：并发队列的并发功能只有在异步（dispatch_async）函数下才有效。</p>
</blockquote>
<p><strong>队列的创建方法/获取方法</strong></p>
<p>可以使用<code>dispatch_queue_create</code>来创建队列，需要传入两个参数，第一个参数表示队列的唯一标识符，用于 DEBUG，可为空，Dispatch Queue 的名称推荐使用应用程序 ID 这种逆序全程域名；第二个参数用来识别是串行队列还是并发队列。<code>DISPATCH_QUEUE_SERIAL</code> 表示串行队列，<code>DISPATCH_QUEUE_CONCURRENT</code>表示并发队列。</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 串行队列的创建方法</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;net.bujige.testQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// 并发队列的创建方法</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;net.bujige.testQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>对于串行队列，GCD 提供了的一种特殊的串行队列：主队列（Main Dispatch Queue）</strong></p>
<ul>
<li>所有放在主队列中的任务，都会放到主线程中执行。</li>
<li>可使用dispatch_get_main_queue()获得主队列。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主队列的获取方法</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>

<p><strong>对于并发队列，GCD 默认提供了全局并发队列（Global Dispatch Queue）</strong></p>
<p>可以使用<code>dispatch_get_global_queue</code>来获取。需要传入两个参数。第一个参数表示队列优先级，一般用<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>。第二个参数暂时没用，用0即可。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局并发队列的获取方法</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<img src="/Blog/2020/07/04/GCD%E4%BB%8B%E7%BB%8D/GCD.png" class="" title="GCD">

<blockquote>
<p>1.使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）。<br>2.并发功能只有在异步函数才会生效。</p>
</blockquote>
<h3 id="3、GCD-的基本使用"><a href="#3、GCD-的基本使用" class="headerlink" title="3、GCD 的基本使用"></a>3、GCD 的基本使用</h3><p><strong>同步串行队列</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;test&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">  <span class="comment">// 追加任务1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">  <span class="comment">// 追加任务2</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2020-07-04 10:05:33.862875+0800 GCD[2180:85864] 1---&lt;NSThread: 0x600003205e40&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-07-04 10:05:33.863044+0800 GCD[2180:85864] 1---&lt;NSThread: 0x600003205e40&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-07-04 10:05:33.863190+0800 GCD[2180:85864] 2---&lt;NSThread: 0x600003205e40&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-07-04 10:05:33.863331+0800 GCD[2180:85864] 2---&lt;NSThread: 0x600003205e40&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>

<p>根据打印结果可知，<code>同步串行队列即没有开启新的线程，也没有异步执行</code>。</p>
<p><strong>同步并行队列</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;test&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">  <span class="comment">// 追加任务1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">  <span class="comment">// 追加任务2</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2020-07-04 10:11:28.625131+0800 GCD[2267:92158] 1---&lt;NSThread: 0x6000010c6d40&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-07-04 10:11:28.625290+0800 GCD[2267:92158] 1---&lt;NSThread: 0x6000010c6d40&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-07-04 10:11:28.625433+0800 GCD[2267:92158] 2---&lt;NSThread: 0x6000010c6d40&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-07-04 10:11:28.625566+0800 GCD[2267:92158] 2---&lt;NSThread: 0x6000010c6d40&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>


<p>根据两种打印我们发现：<code>同步函数</code>既不会开启新的线程，也不会执行并发任务。</p>
<p><strong>异步串行队列</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;主线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;test&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1====%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2====%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2020-07-04 10:19:00.528690+0800 GCD[2414:99573] 主线程：&lt;NSThread: 0x6000002fd0c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-07-04 10:19:00.529043+0800 GCD[2414:99785] 1=====&lt;NSThread: 0x6000002a4d40&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2020-07-04 10:19:00.529176+0800 GCD[2414:99785] 1=====&lt;NSThread: 0x6000002a4d40&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2020-07-04 10:19:00.529315+0800 GCD[2414:99785] 2====&lt;NSThread: 0x6000002a4d40&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2020-07-04 10:19:00.529455+0800 GCD[2414:99785] 2====&lt;NSThread: 0x6000002a4d40&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<code>有开启新的线程，串行执行任务</code>。</p>
<p><strong>异步并行队列</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;主线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;test&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1====%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2====%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2020-07-04 10:21:16.460023+0800 GCD[2450:101648] 主线程：&lt;NSThread: 0x6000025e6d40&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-07-04 10:21:16.460411+0800 GCD[2450:101857] 2====&lt;NSThread: 0x60000258d080&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2020-07-04 10:21:16.460411+0800 GCD[2450:101859] 1=====&lt;NSThread: 0x6000025b4f80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2020-07-04 10:21:16.460562+0800 GCD[2450:101857] 2====&lt;NSThread: 0x60000258d080&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2020-07-04 10:21:16.460589+0800 GCD[2450:101859] 1=====&lt;NSThread: 0x6000025b4f80&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<code>有开启新的线程，并发执行任务</code>。想要出现明显的并发执行效果，可以<code>sleep</code>一下。</p>
<p><strong>sync函数造成的线程死锁</strong></p>
<p>首先你要理解同步和异步执行的概念，同步和异步目的不是为了是否创建一个新的线程，同步会阻塞当前函数的返回，异步函数会立即返回执行下面的代码；队列是一种数据结构，队列有FIFO,LIFO等，控制任务的执行顺序，至于是否开辟一个新的线程，因为同步函数会等待函数的返回，所以在当前线程执行就行了，没必要浪费资源再开辟新的线程，如果是异步函数，当前线程需要立即函数返回，然后往下执行，所以函数里面的任务必须要开辟一个新的线程去执行这个任务。</p>
<blockquote>
<p>队列上是放任务的,而线程是去执行队列上的任务的。</p>
</blockquote>
<p>【问题1】：以下代码是在主线程执行的，会不会产生死锁？会！</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务1&quot;</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务3&quot;</span>);</span><br></pre></td></tr></table></figure>

<img src="/Blog/2020/07/04/GCD%E4%BB%8B%E7%BB%8D/GCD4.png" class="" title="GCD">

<p><code>dispatch_sync立马在当前线程同步执行任务</code>。</p>
<p>分析：</p>
<ul>
<li>1、主线程中任务执行：<code>任务1</code>、<code>sync</code>、<code>任务3</code>、</li>
<li>2、主队列：<code>viewDidLoad</code>、<code>任务2</code>、</li>
</ul>
<p>其中在主队列<code>viewDidLoad</code>里面的<code>任务3</code>执行结束才会执行<code>任务2</code>；而主线程中是执行完<code>sync</code>才会执行<code>任务3</code>。也就是<code>任务2</code>等待<code>任务3</code>执行，<code>任务3</code>再也等待<code>任务2</code>执行，造成死锁。</p>
<img src="/Blog/2020/07/04/GCD%E4%BB%8B%E7%BB%8D/GCD5.png" class="" title="GCD">


<p>【问题2】：以下代码是在主线程执行的，会不会产生死锁？不会！</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)interview02 &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务1&quot;</span>);</span><br><span class="line">  <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">  <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务3&quot;</span>);</span><br><span class="line">  <span class="comment">// dispatch_async不要求立马在当前线程同步执行任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/Blog/2020/07/04/GCD%E4%BB%8B%E7%BB%8D/GCD4_1.png" class="" title="GCD">

<p>因为<code>dispatch_async</code>不要求立马在当前线程同步执行任务，不会造成线程死锁。</p>
<p>【问题3】：以下代码是在主线程执行的，会不会产生死锁？会！</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务1&quot;</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;myqueu&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123; <span class="comment">// 0</span></span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务2&quot;</span>);</span><br><span class="line">  <span class="built_in">dispatch_sync</span>(queue, ^&#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务3&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务4&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务5&quot;</span>);</span><br></pre></td></tr></table></figure>
<img src="/Blog/2020/07/04/GCD%E4%BB%8B%E7%BB%8D/GCD6.png" class="" title="GCD">

<p>其中<code>执行任务3</code>和<code>执行任务4</code>之间造成死锁。</p>
<p>【问题4】：以下代码是在主线程执行的，会不会产生死锁？不会！</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)interview04 &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务1&quot;</span>);</span><br><span class="line">  <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;myqueu&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">  <span class="built_in">dispatch_async</span>(queue, ^&#123; <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务2&quot;</span>);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123; <span class="comment">// 1</span></span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务3&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务4&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务5&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、GCD-线程间的通信"><a href="#4、GCD-线程间的通信" class="headerlink" title="4、GCD 线程间的通信"></a>4、GCD 线程间的通信</h3><p>在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)communication &#123;</span><br><span class="line">  <span class="comment">// 获取全局并发队列</span></span><br><span class="line">  <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>); </span><br><span class="line">  <span class="comment">// 获取主队列</span></span><br><span class="line">  <span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue(); </span><br><span class="line">  <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 异步追加任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">      [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;1---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回到主线程</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">      <span class="comment">// 追加在主线程中执行的任务</span></span><br><span class="line">      [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;2---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">50.617918</span>+<span class="number">0800</span> GCD[<span class="number">2798</span>:<span class="number">125429</span>] <span class="number">1</span>---&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000025eb800</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">52.622555</span>+<span class="number">0800</span> GCD[<span class="number">2798</span>:<span class="number">125429</span>] <span class="number">1</span>---&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000025eb800</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">54.624007</span>+<span class="number">0800</span> GCD[<span class="number">2798</span>:<span class="number">125174</span>] <span class="number">2</span>---&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000025e2d40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、GCD-的其他方法"><a href="#5、GCD-的其他方法" class="headerlink" title="5、GCD 的其他方法"></a>5、GCD 的其他方法</h3><h4 id="5-1、GCD-栅栏方法：dispatch-barrier-async"><a href="#5-1、GCD-栅栏方法：dispatch-barrier-async" class="headerlink" title="5.1、GCD 栅栏方法：dispatch_barrier_async"></a>5.1、GCD 栅栏方法：<code>dispatch_barrier_async</code></h4><img src="/Blog/2020/07/04/GCD%E4%BB%8B%E7%BB%8D/GCD7.png" class="" title="GCD">


<p>就是我们在异步执行一些操作的时候，我们使用<code>dispatch_barrier_async</code>函数把异步操作暂时性的做成同步操作，就像一个<code>栅栏</code>一样分开。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)barrierTest &#123;</span><br><span class="line">    <span class="keyword">self</span>.queue = dispatch_queue_create(<span class="string">&quot;rw_queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        [<span class="keyword">self</span> readWithIndex:i];</span><br><span class="line">        [<span class="keyword">self</span> readWithIndex:i];</span><br><span class="line">        [<span class="keyword">self</span> writeWithIndex:i];</span><br><span class="line">        [<span class="keyword">self</span> readWithIndex:i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)readWithIndex:(<span class="built_in">NSInteger</span>)index &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;第%ld次循环:read&quot;</span>, (<span class="keyword">long</span>)index);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)writeWithIndex:(<span class="built_in">NSInteger</span>)index &#123;</span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;第%ld次循环:write&quot;</span>, (<span class="keyword">long</span>)index);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/Blog/2020/07/04/GCD%E4%BB%8B%E7%BB%8D/GCD8.png" class="" title="GCD">
<p>我们观察时间可以看到在执行<code>dispatch_barrier_async</code>写操作的时候是同步执行的，不会出现异步情况。</p>
<h4 id="5-2、GCD-延时执行方法：dispatch-after"><a href="#5-2、GCD-延时执行方法：dispatch-after" class="headerlink" title="5.2、GCD 延时执行方法：dispatch_after"></a>5.2、GCD 延时执行方法：dispatch_after</h4><p>我们经常会遇到这样的需求：在指定时间（例如3秒）之后执行某个任务。可以用 GCD 的dispatch_after函数来实现。<br>需要注意的是：dispatch_after函数并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中。严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，dispatch_after函数是很有效的。</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 延时执行方法 dispatch_after</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)after &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;currentThread---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线</span></span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;asyncMain---begin&quot;</span>);</span><br><span class="line">  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)),dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="comment">// 2.0秒后异步追加任务代码到主队列，并开始执行</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;after---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">24</span>:<span class="number">46.248616</span>+<span class="number">0800</span> GCD[<span class="number">3252</span>:<span class="number">146325</span>] currentThread---&lt;<span class="built_in">NSThread</span>: <span class="number">0x600003589e40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">24</span>:<span class="number">46.248769</span>+<span class="number">0800</span> GCD[<span class="number">3252</span>:<span class="number">146325</span>] asyncMain---begin</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">24</span>:<span class="number">48.248964</span>+<span class="number">0800</span> GCD[<span class="number">3252</span>:<span class="number">146325</span>] after---&lt;<span class="built_in">NSThread</span>: <span class="number">0x600003589e40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3、GCD-一次性代码（只执行一次）：dispatch-once"><a href="#5-3、GCD-一次性代码（只执行一次）：dispatch-once" class="headerlink" title="5.3、GCD 一次性代码（只执行一次）：dispatch_once"></a>5.3、GCD 一次性代码（只执行一次）：dispatch_once</h4><p>我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了 GCD 的 dispatch_once 函数。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">  <span class="comment">// 只执行1次的代码(这里面默认是线程安全的)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="5-4、GCD-队列组：dispatch-group"><a href="#5-4、GCD-队列组：dispatch-group" class="headerlink" title="5.4、GCD 队列组：dispatch_group"></a>5.4、GCD 队列组：dispatch_group</h4><p>有时候我们会有这样的需求：分别异步执行2个耗时任务，然后当2个耗时任务都执行完毕后再回到主线程执行任务。这时候我们可以用到 GCD 的队列组。</p>
<ul>
<li>调用队列组的 <code>dispatch_group_async</code> 先把任务放到队列中，然后将队列放入队列组中。或者使用队列组的 <code>dispatch_group_enter</code>、<code>dispatch_group_leave</code> 组合 来实现<code>dispatch_group_async</code>。</li>
<li>调用队列组的 <code>dispatch_group_notify </code>回到指定线程执行任务。或者使用 <code>dispatch_group_wait</code> 回到当前线程继续向下执行（会阻塞当前线程）。</li>
<li><code>dispatch_group_enter </code>标志着一个任务追加到 group，执行一次，相当于 group 中未执行完毕任务数+1</li>
<li><code>dispatch_group_leave</code> 标志着一个任务离开了 group，执行一次，相当于 group 中未执行完毕任务数-1</li>
<li>当 group 中未执行完毕任务数为0的时候，才会使<code>dispatch_group_wait</code>解除阻塞，以及执行追加到<code>dispatch_group_notify</code>中的任务。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 队列组 dispatch_group_notify</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)groupNotify &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;currentThread---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;group---begin&quot;</span>);</span><br><span class="line">  dispatch_group_t group =  dispatch_group_create();</span><br><span class="line">  dispatch_group_async(group,dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 追加任务1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">      [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;1---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  dispatch_group_async(group,dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 追加任务2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">      [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;2---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="comment">// 等前面的异步任务1、任务2都执行完毕后，回到主线程执行下边任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">      [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;3---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;group---end&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">28</span>:<span class="number">55.585362</span>+<span class="number">0800</span> GCD[<span class="number">3414</span>:<span class="number">151664</span>] currentThread---&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000019bad00</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">28</span>:<span class="number">55.585511</span>+<span class="number">0800</span> GCD[<span class="number">3414</span>:<span class="number">151664</span>] group---begin</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">28</span>:<span class="number">57.588445</span>+<span class="number">0800</span> GCD[<span class="number">3414</span>:<span class="number">151882</span>] <span class="number">1</span>---&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000019dcb40</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">28</span>:<span class="number">57.588463</span>+<span class="number">0800</span> GCD[<span class="number">3414</span>:<span class="number">151886</span>] <span class="number">2</span>---&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000019d89c0</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">28</span>:<span class="number">59.593759</span>+<span class="number">0800</span> GCD[<span class="number">3414</span>:<span class="number">151886</span>] <span class="number">2</span>---&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000019d89c0</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">28</span>:<span class="number">59.593718</span>+<span class="number">0800</span> GCD[<span class="number">3414</span>:<span class="number">151882</span>] <span class="number">1</span>---&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000019dcb40</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">29</span>:<span class="number">01.595497</span>+<span class="number">0800</span> GCD[<span class="number">3414</span>:<span class="number">151664</span>] <span class="number">3</span>---&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000019bad00</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">29</span>:<span class="number">03.597050</span>+<span class="number">0800</span> GCD[<span class="number">3414</span>:<span class="number">151664</span>] <span class="number">3</span>---&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000019bad00</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">29</span>:<span class="number">03.597351</span>+<span class="number">0800</span> GCD[<span class="number">3414</span>:<span class="number">151664</span>] group---end</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用<code>dispatch_group_async</code>包裹起来的操作是异步的，可以使用<code>dispatch_group_enter(dispatchGroup);</code> 和 <code>dispatch_group_leave(dispatchGroup);</code>替代，注意<code>dispatch_group_enter()</code> 和 <code>dispatch_group_leave()</code>需要配对使用，如果未配对容易出现<code>dispatch_group_notify()</code>不调用或者崩溃。</p>
</blockquote>
<h4 id="5-5、GCD-信号量：dispatch-semaphore"><a href="#5-5、GCD-信号量：dispatch-semaphore" class="headerlink" title="5.5、GCD 信号量：dispatch_semaphore"></a>5.5、GCD 信号量：dispatch_semaphore</h4><p>Dispatch Semaphore 提供了三个函数。</p>
<ul>
<li><code>dispatch_semaphore_create</code>：创建一个信号量，具有整形的数值，即为信号的总量。</li>
<li><code>dispatch_semaphore_signal</code>：发送一个信号，让信号总量加1</li>
<li><code>dispatch_semaphore_wait</code>：可以使总信号量减1，当信号总量为0时就会一直等待（阻塞所在线程），否则就可以正常执行。</li>
</ul>
<p>示例代码，异步线程的并发量设置为3，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)interview05&#123;</span><br><span class="line">    <span class="comment">// 创建队列组</span></span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    <span class="comment">// 创建信号量，并且设置值为3</span></span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        由于是异步执行的，所以每次循环Block里面的dispatch_semaphore_signal根本还没有执行就会执行dispatch_semaphore_wait，从而semaphore-1.当循环10此后，semaphore等于0，则会阻塞线程，直到执行了Block的dispatch_semaphore_signal 才会继续执行</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%i&quot;</span>,i);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="comment">// 每次发送信号则semaphore会+1，</span></span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">46</span>:<span class="number">30.490317</span>+<span class="number">0800</span> GCD[<span class="number">3689</span>:<span class="number">165328</span>] <span class="number">0</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">46</span>:<span class="number">30.490327</span>+<span class="number">0800</span> GCD[<span class="number">3689</span>:<span class="number">165332</span>] <span class="number">1</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">46</span>:<span class="number">30.490348</span>+<span class="number">0800</span> GCD[<span class="number">3689</span>:<span class="number">165329</span>] <span class="number">2</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">46</span>:<span class="number">32.490797</span>+<span class="number">0800</span> GCD[<span class="number">3689</span>:<span class="number">165329</span>] <span class="number">3</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">46</span>:<span class="number">32.490809</span>+<span class="number">0800</span> GCD[<span class="number">3689</span>:<span class="number">165328</span>] <span class="number">4</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">46</span>:<span class="number">32.490818</span>+<span class="number">0800</span> GCD[<span class="number">3689</span>:<span class="number">165332</span>] <span class="number">5</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">46</span>:<span class="number">34.493311</span>+<span class="number">0800</span> GCD[<span class="number">3689</span>:<span class="number">165332</span>] <span class="number">6</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">46</span>:<span class="number">34.493326</span>+<span class="number">0800</span> GCD[<span class="number">3689</span>:<span class="number">165328</span>] <span class="number">7</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">46</span>:<span class="number">34.493345</span>+<span class="number">0800</span> GCD[<span class="number">3689</span>:<span class="number">165329</span>] <span class="number">8</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">46</span>:<span class="number">36.495699</span>+<span class="number">0800</span> GCD[<span class="number">3689</span>:<span class="number">165328</span>] <span class="number">9</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>GCD概要</title>
    <url>/Blog/2020/01/31/GCD%E6%A6%82%E8%A6%81/</url>
    <content><![CDATA[<h2 id="什么是GCD"><a href="#什么是GCD" class="headerlink" title="什么是GCD"></a>什么是GCD</h2><p>Grand Central Dispatch（GCD）是异步执行任务的技术之一。一般将应用程序中记述的线程管理用的代码在系统级中实现。开发者只需要定义想要执行的任务并追加到适当的 Dispatch Queue 中，GCD 就能生成必要的线程并计划执行任务。由于线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，这样就比以前的线程更有效率。</p>
<p>在导入GCD之前，Cocoa 框架提供了 NSObject 类的 performSelectorInBackground:withObject 实例方法和 performSelectorOnMainThread 实例方法等简单的多线程编程技术。</p>
<h3 id="dispatch-after-用法"><a href="#dispatch-after-用法" class="headerlink" title="dispatch_after 用法"></a>dispatch_after 用法</h3><p>在3秒后将指定的 Block 追加到 Main Dispatch Queue 中的源代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSLog(@&quot;begin...&quot;);</span><br><span class="line">    </span><br><span class="line">&#x2F;**</span><br><span class="line"> 因为 Main Dispatch Queue 在主线程的 RunLoop 中执行，所以在比如每隔1&#x2F;60秒执行的 RunLoop 中，Block 最快在3秒后执行，最慢在3秒+1&#x2F;60秒后执行，</span><br><span class="line"> 并且在 Main Dispatch Queue 有大量处理追加或主线程的处理本身有延迟时，这个时间会更长。虽然在有严格时间的要求下使用会出现问题，但在想大致延迟执行处</span><br><span class="line"> 理时，该函数是非常有效的。</span><br><span class="line"> *&#x2F;</span><br><span class="line">dispatch_time_t time &#x3D; dispatch_time(DISPATCH_TIME_NOW, 3ull * NSEC_PER_SEC);</span><br><span class="line">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;waited at least three seconds.&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;end...&quot;);</span><br></pre></td></tr></table></figure>

<p>第一个参数是指定时间用的 dispatch_time_t 类型的值。该值使用 dispatch_time 函数或 dispatch_walltime 函数生成。</p>
<p>dispatch_time 函数能够获取从第一个参数 dispatch_time_t 类型值中指定的时间开始，到第二个参数指定的毫微秒单位时间后的时间。第一个参数经常使用的值是之前源代码中出现的DISPATCH_TIME_NOW。这表示现在的时间。即以下源代码可得到表示从现在开始1秒后的 dispatch_time_t 类型的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_time_t time &#x3D; dispatch_time(DISPATCH_TIME_NOW, 1ull * NSEC_PER_SEC);</span><br></pre></td></tr></table></figure>

<p>数值和 NSEC_PER_SEC 的乘积得到单位为毫微秒的数值。“ull”是C语言的数值字面量，是显示表明类型时使用的字符串（表示“unsigned long long”）。如果使用 NSEC_PER_MSEC 则可以以毫秒为单位计算。以下源代码获取表示从现在开始150毫秒后时间的值。TI</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_time_t time &#x3D; dispatch_time(DISPATCH_TIME_NOW, 150ull * NSEC_PER_MSEC);</span><br></pre></td></tr></table></figure>

<p>dispatch_walltime 函数由 POSIX 中使用的 struct timespec 类型的时间得到 dispatch_time_t 类型的值。dispatch_time 函数通常用于计算时间，而 dispatch_walltime 函数用于计算绝对时间。例如在 dispatch_after 函数中想指定 2020年01月01日01时01分01秒这一绝对时间的情况，这可以作为粗略的闹钟功能使用。</p>
<p>struct timespec 类型的时间可以很轻松的通过 NSDate 类对象生成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_time_t getDispatchTimeByDate(NSDate *date) &#123;</span><br><span class="line">    NSTimeInterval interval;</span><br><span class="line">    double second, subsecond;</span><br><span class="line">    struct timespec time;</span><br><span class="line">    dispatch_time_t milestone;</span><br><span class="line">    </span><br><span class="line">    interval &#x3D; [date timeIntervalSince1970];</span><br><span class="line">    subsecond &#x3D; modf(interval, &amp;second);</span><br><span class="line">    time.tv_sec &#x3D; second;</span><br><span class="line">    time.tv_nsec &#x3D; subsecond * NSEC_PER_SEC;</span><br><span class="line">    milestone &#x3D; dispatch_walltime(&amp;time, 0);</span><br><span class="line">    </span><br><span class="line">    return milestone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的源代码可由 NSDate 类对象获取能传递给 dispatch_after 函数的 dispatch_time_t 类型的值。</p>
<h3 id="dispatch-group-t-用法"><a href="#dispatch-group-t-用法" class="headerlink" title="dispatch_group_t 用法"></a>dispatch_group_t 用法</h3><p>在追加到 Dispatch Queue 中的多个处理全部结束后想执行结束处理，这种情况会经常出现。</p>
<p>例如下面代码：追加3个 Block 到 Global Dispatch Queue，这些 Block 如果全部执行完毕，就会执行 Main Dispatch Queue 中结束处理用的 Block。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)testDispatchGroupNotify &#123;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;blk0&quot;);&#125;);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;blk2&quot;);&#125;);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;blk3&quot;);&#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;NSLog(@&quot;done&quot;);&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论向什么样的 Dispatch Queue 中追加处理，使用 Dispatch Queue 都可以监视这些处理执行的结束。一旦检测到所有的处理执行结束，就可以将结束的处理追加到 Dispatch Queue 中。这就是使用</p>
<p>Dispatch Group 的原因。</p>
<p>在Dispatch Group中也可以使用 dispatch_group_wait 函数仅等待全部处理执行结束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)testDispatchGroupWait1 &#123;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;blk0&quot;);&#125;);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;blk1&quot;);&#125;);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;blk2&quot;);&#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;done.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dispatch_group_wait 函数的第二个参数指定为等待时间（超时）。它属于 dispatch_time_t 类型的值。该源代码使用 DISPATCH_DISPATCH_TIME_FOREVER，意味着永久等待。只要属于Dispatch Group 的处理尚未结束，就会一直等待，中途不能取消。</p>
<p>如同 dispatch_after 函数说明的那样，指定等待间隔为1秒时应做如下处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)testDispatchGroupWait2 &#123;</span><br><span class="line">    dispatch_time_t time &#x3D; dispatch_time(DISPATCH_TIME_NOW, 1ull * NSEC_PER_SEC);</span><br><span class="line">    dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">    long result &#x3D; dispatch_group_wait(group, time);</span><br><span class="line">    if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         属于 Dispatch Group 的全部处理执行结束</span><br><span class="line">         *&#x2F;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         属于 Dispatch Group 的某一个处理还在执行中</span><br><span class="line">         *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 dispatch_group_wait 函数的返回值不为0，就意味着虽然经过了指定的时间，但属于 Dispatch Group 的某一个处理还在执行中。如果返回值为0，那么全部处理执行结束。当等待时间为 DISPATCH_TIME_FOREVER，由 dispatch_group_wait 函数返回时，由于属于 Dispatch Group 的处理必定全部执行结束，因此返回值恒为0。</p>
<p>这里的“等待”是什么意思呢？这意味着一旦调用 dispatch_group_wait 函数，该函数就处于调用的状态而不返回。即执行 dispatch_group_wait 函数的所在的线程停止。在经过 dispatch_group_wait 函数中指定的时间或属于指定 Dispatch Group 的处理全部执行结束之前，执行该函数的线程停止。</p>
<h3 id="dispatch-barrier-async-用法"><a href="#dispatch-barrier-async-用法" class="headerlink" title="dispatch_barrier_async 用法"></a>dispatch_barrier_async 用法</h3><p>如果像下面这样简单地在 dispatch_async 函数中加入写入处理，那么根据 Concurrent Dispatch Queue 的性质，就有可能在写入处理前面的读取处理中读取到与期待不符的数据，还可能因非法访问导致应用程序异常结束。如果追加多个写入处理，则可能发生更多的问题，比如数据竞争等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)testReadAndWrite &#123;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;com.gcd.barrier&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk0_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk1_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk2_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk3_for_reading&quot;);&#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk_for_writing&quot;);&#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk4_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk5_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk6_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk7_for_reading&quot;);&#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-02-01 10:33:21.908239+0800 GCD_Demo[1852:30606] blk0_for_reading</span><br><span class="line">2020-02-01 10:33:21.908272+0800 GCD_Demo[1852:30354] blk1_for_reading</span><br><span class="line">2020-02-01 10:33:21.908349+0800 GCD_Demo[1852:30705] blk2_for_reading</span><br><span class="line">2020-02-01 10:33:21.908409+0800 GCD_Demo[1852:30706] blk3_for_reading</span><br><span class="line">2020-02-01 10:33:21.908446+0800 GCD_Demo[1852:30606] blk4_for_reading</span><br><span class="line">2020-02-01 10:33:21.908464+0800 GCD_Demo[1852:30354] blk5_for_reading</span><br><span class="line">2020-02-01 10:33:21.908466+0800 GCD_Demo[1852:30707] blk_for_writing</span><br><span class="line">2020-02-01 10:33:21.908490+0800 GCD_Demo[1852:30705] blk6_for_reading</span><br><span class="line">2020-02-01 10:33:21.908498+0800 GCD_Demo[1852:30708] blk7_for_reading</span><br></pre></td></tr></table></figure>

<p>因此我们要使用 dispatch_barrier_async 函数。dispatch_barrier_async 函数会等待追加到 Concurrent Dispatch Queue 上的并行执行的处理全部结束之后，再将指定的处理追加到该 Concurrent Dispatch Queue 中。然后在由 dispatch_barrier_async 函数追加的处理执行完毕后，Concurrent Dispatch Queue 才恢复为一般的动作，追加到该 Concurrent Dispatch Queue 的处理又开始并行执行。</p>
<p>使用 dispatch_barrier_async 的代码示例如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)testReadAndWrite2 &#123;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;com.gcd.barrier&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk0_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk1_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk2_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk3_for_reading&quot;);&#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;NSLog(@&quot;blk_for_writing&quot;);&#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk4_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk5_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk6_for_reading&quot;);&#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;NSLog(@&quot;blk7_for_reading&quot;);&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行的结果如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">59.739217</span>+<span class="number">0800</span> GCD_Demo[<span class="number">2063</span>:<span class="number">43192</span>] blk0_for_reading</span><br><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">59.739225</span>+<span class="number">0800</span> GCD_Demo[<span class="number">2063</span>:<span class="number">43191</span>] blk1_for_reading</span><br><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">59.739240</span>+<span class="number">0800</span> GCD_Demo[<span class="number">2063</span>:<span class="number">42655</span>] blk2_for_reading</span><br><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">59.739244</span>+<span class="number">0800</span> GCD_Demo[<span class="number">2063</span>:<span class="number">43193</span>] blk3_for_reading</span><br><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">59.739375</span>+<span class="number">0800</span> GCD_Demo[<span class="number">2063</span>:<span class="number">43193</span>] blk_for_writing</span><br><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">59.739480</span>+<span class="number">0800</span> GCD_Demo[<span class="number">2063</span>:<span class="number">42655</span>] blk5_for_reading</span><br><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">59.739483</span>+<span class="number">0800</span> GCD_Demo[<span class="number">2063</span>:<span class="number">43193</span>] blk4_for_reading</span><br><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">59.739503</span>+<span class="number">0800</span> GCD_Demo[<span class="number">2063</span>:<span class="number">43191</span>] blk6_for_reading</span><br><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">59.739510</span>+<span class="number">0800</span> GCD_Demo[<span class="number">2063</span>:<span class="number">43192</span>] blk7_for_reading</span><br></pre></td></tr></table></figure>

<p>使用 Concurrent Dispatch Queue 和 dispatch_barrier_async 函数可实现高效率的数据库访问和文件访问。</p>
<p>dispatch_barrier_async 函数的处理流程图：</p>
<img src="/Blog/2020/01/31/GCD%E6%A6%82%E8%A6%81/snip1.png" class="" title="dispatch_barrier_async函数处理流程图">

<h3 id="dispatch-sync-用法"><a href="#dispatch-sync-用法" class="headerlink" title="dispatch_sync 用法"></a>dispatch_sync 用法</h3><p>dispatch_async 函数，就是将指定的Block“非同步”地追加到指定的 Dispatch Queue 中，dispatch_async 函数不做任何等待。</p>
<img src="/Blog/2020/01/31/GCD%E6%A6%82%E8%A6%81/snip2.png" class="" title="dispatch_async 函数的处理流程">

<p>dispatch_sync 函数，就是将指定的Block“同步”地追加到指定的 Dispatch Queue 中。在追加的Block结束之前，dispatch_sync 函数会一直等待。如 dispatch_group_wait 函数一样，“等待”意味着当前线程停止。</p>
<img src="/Blog/2020/01/31/GCD%E6%A6%82%E8%A6%81/snip3.png" class="" title="dispatch_sync 函数的处理流程">

<p>我们先假设这样一种情况，执行 Main Dispatch Queue 时，使用另外的线程 Global Dispatch Queue 进行处理，处理结束后立即使用所得到的结果。在这种情况下就要使用 dispatch_sync 函数。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;<span class="comment">/* 处理 */</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>一旦调用 dispatch_sync 函数，那么在指定的处理执行结束之前，该函数不会返回。dispatch_sync 函数可简化源代码，也可说是简易版的 dispatch_group_wait 函数。正因为 dispatch_sync 函数使用简单，所以也容易引起问题，即死锁。</p>
<p>例如如果在主线程中执行以下源代码就会死锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)testDispatchSync1 &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;begin...&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_main_queue();</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;Hello&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;end...&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该源代码在 Main Dispatch Queue 即主线程中执行指定的Block，并等待其执行结束。而其实在主线程中正在执行这些源代码，所以无法执行追加到 Main Dispatch Queue 的Block。下面的例子也一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)testDispatchSync2 &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;begin...&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_main_queue();</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        dispatch_sync(queue, ^&#123;NSLog(@&quot;Hello&quot;);&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;end...&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Main Dispatch Queue 中执行的Block等待 Main Dispatch Queue 中要执行的Block 执行结束。这样的死锁就像在画像上画画一样。</p>
<p>当然 Serial Dispatch Queue 也会引起相同的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)testDispatchSync3 &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;begin...&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;com.gcd.mySerialDispatchQueue&quot;, NULL);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        dispatch_sync(queue, ^&#123;NSLog(@&quot;Hello&quot;);&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;end...&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由 dispatch_barrier_async 函数中含有 async 可推测出，相应的也有 dispatch_barrier_sync 函数。dispatch_barrier_async 函数的作用是在等待追加的处理全部执行结束后，再追加处理到 Dispatch Queue 中，此外，它还与 dispatch_sync 函数相同，会等待追加处理的执行结束。</p>
<h3 id="dispatch-apply-用法"><a href="#dispatch-apply-用法" class="headerlink" title="dispatch_apply 用法"></a>dispatch_apply 用法</h3><p>dispatch_apply 函数是 dispatch_sync 函数和 Dispatch Group 的关联 API。该函数按指定的次数将指定的Block追加到指定的 Dispatch Queue中，并等待全部处理执行结束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)testDispatchApply1 &#123;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_apply(10, queue, ^(size_t index) &#123;</span><br><span class="line">        NSLog(@&quot;blk %zu&quot;, index);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;done&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-02-01 12:40:31.343067+0800 GCD_Demo[3361:105895] blk 1</span><br><span class="line">2020-02-01 12:40:31.343067+0800 GCD_Demo[3361:105839] blk 2</span><br><span class="line">2020-02-01 12:40:31.343074+0800 GCD_Demo[3361:105885] blk 0</span><br><span class="line">2020-02-01 12:40:31.343078+0800 GCD_Demo[3361:105940] blk 4</span><br><span class="line">2020-02-01 12:40:31.343079+0800 GCD_Demo[3361:105941] blk 7</span><br><span class="line">2020-02-01 12:40:31.343078+0800 GCD_Demo[3361:105939] blk 3</span><br><span class="line">2020-02-01 12:40:31.343085+0800 GCD_Demo[3361:105894] blk 5</span><br><span class="line">2020-02-01 12:40:31.343085+0800 GCD_Demo[3361:105938] blk 6</span><br><span class="line">2020-02-01 12:40:31.343224+0800 GCD_Demo[3361:105895] blk 8</span><br><span class="line">2020-02-01 12:40:31.343235+0800 GCD_Demo[3361:105839] blk 9</span><br><span class="line">2020-02-01 12:40:31.343787+0800 GCD_Demo[3361:105839] done</span><br></pre></td></tr></table></figure>

<p>因为在 Global Dispatch Queue 中执行处理，所以各个处理的执行时间不定。但是输出结果中最后的 done 必定在最后的位置上。这是因为 dispatch_apply 函数会等待全部处理执行结束。</p>
<p>第一个参数为重复次数，第二个参数为追加对象的 Dispatch Queue，第三个参数为追加的处理。与到目前为止所出现的例子不同，第三个参数的Block为带有参数的Block。这是为了按第一个参数重复追加Block并区分各个Block而使用。例如要对 NSArray 类对象的所有元素执行处理时，不必一个一个编写 for 循环部分。</p>
<p>另外，由于 dispatch_apply 函数也与 dispatch_sync 函数相同，会等待处理执行结束，因此推荐在 dispatch_async 函数中非同步地执行 dispatch_apply 函数。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)testDispatchApply2 &#123;</span><br><span class="line">    </span><br><span class="line">    NSArray *array &#x3D; [NSArray arrayWithObjects:@&quot;obj1&quot;, @&quot;obj2&quot;, @&quot;obj3&quot;, @&quot;obj4&quot;, @&quot;obj5&quot;, @&quot;obj6&quot;, nil];</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    &#x2F;** 在 Global Dispatch Queue 中非同步执行 *&#x2F;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">       </span><br><span class="line">        &#x2F;**</span><br><span class="line">         Global Dispatch Queue</span><br><span class="line">         等待 dispatch_apply 函数中全部处理执行结束</span><br><span class="line">         *&#x2F;</span><br><span class="line">        dispatch_apply([array count], queue, ^(size_t index) &#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             并列处理包含在 NSArray 对象的全部对象</span><br><span class="line">             *&#x2F;</span><br><span class="line">            NSLog(@&quot;%zu: %@&quot;, index, [array objectAtIndex:index]);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;**</span><br><span class="line">         dispatch_apply 函数中的处理全部执行结束</span><br><span class="line">         *&#x2F;</span><br><span class="line">        </span><br><span class="line">        &#x2F;**</span><br><span class="line">         在 Main Dispatch Queue 中非同步执行</span><br><span class="line">         *&#x2F;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             在 Main Dispatch Queue 中执行处理</span><br><span class="line">             用户界面更新等</span><br><span class="line">             *&#x2F;</span><br><span class="line">            NSLog(@&quot;done&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-02-01 13:17:57.785290+0800 GCD_Demo[3821:122905] 4: obj5</span><br><span class="line">2020-02-01 13:17:57.785285+0800 GCD_Demo[3821:122911] 5: obj6</span><br><span class="line">2020-02-01 13:17:57.785283+0800 GCD_Demo[3821:122895] 3: obj4</span><br><span class="line">2020-02-01 13:17:57.785283+0800 GCD_Demo[3821:122896] 0: obj1</span><br><span class="line">2020-02-01 13:17:57.785283+0800 GCD_Demo[3821:122897] 2: obj3</span><br><span class="line">2020-02-01 13:17:57.785283+0800 GCD_Demo[3821:122894] 1: obj2</span><br><span class="line">2020-02-01 13:17:57.811750+0800 GCD_Demo[3821:122848] done</span><br></pre></td></tr></table></figure>

<h3 id="dispatch-suspend-dispatch-resume-用法"><a href="#dispatch-suspend-dispatch-resume-用法" class="headerlink" title="dispatch_suspend / dispatch_resume 用法"></a>dispatch_suspend / dispatch_resume 用法</h3><p>当追加大量处理到 Dispatch Queue 时，在追加处理的过程中，有时希望不执行已追加的处理。例如演算结果被Block截获时，一些处理会对这个演算结果造成影响。在这种情况下，只要挂起 Dispatch Queue 即可。当可以执行时再恢复。</p>
<p>dispatch_suspend 函数挂起指定的 Dispatch Queue。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_suspend(queue);</span><br></pre></td></tr></table></figure>

<p>Dispatch_resume 函数恢复指定的 Dispatch Queue。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_resume(queue);</span><br></pre></td></tr></table></figure>

<p>这些函数对已经执行的处理没有影响。挂起后，追加到 Dispatch Queue 中但尚未执行的处理在此之后停止执行。而恢复则使得这些处理能够继续执行。</p>
<h3 id="Dispatch-Semaphore-用法"><a href="#Dispatch-Semaphore-用法" class="headerlink" title="Dispatch Semaphore 用法"></a>Dispatch Semaphore 用法</h3><p>如前所述，当并行执行的处理更新数据时，会产生数据不一致的情况，有时应用程序还会异常结束。虽然使用 Serial Dispatch Queue 和 dispatch_barrier_async 函数可避免这类问题，但有必要进行更细粒度的排他控制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)testDispatchSemaphore1 &#123;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *array &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">    </span><br><span class="line">    for (int i&#x3D;0; i &lt; 10000; ++i) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            [array addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为该源代码使用 Global Dispatch Queue 更新 NSMutableArray 类对象，所以执行后由内存错误导致应用程序异常结束的概率很高。此时应使用 Dispatch Semephore。</p>
<p>Dispatch Semaphore 是持有计数的信号，该计数是多线程编程中的计数类型信号。所谓信号，类似于过马路时常用的手旗。可以通过时举起手旗，不可通过时放下手旗。而在Dispatch Semaphore中，使用计数来实现该功能。计数为0时等待，计数为1或大于1时，减去1而不等待。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore &#x3D; dispatch_semaphore_create(1);</span><br></pre></td></tr></table></figure>

<p>参数表示计数的初始值。本例将计数值初始化为“1”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>

<p>dispatch_semaphore_wait 函数等待 Dispatch Semaphore 的计数值达到大于或等于 1。当计数值大于等于1，或者在待机中计数值大于等于1时，对该计数进行减法并从 dispatch_semaphore_wait 函数返回。第二个参数与 dispatch_group_wait 函数等相同，由 dispatch_time_t 类型值指定等待时间。该例的参数意味着永久等待。另外，dispatch_semaphore_wait 函数的返回值也与 dispatch_group_wait 函数相同。可像以下源代码这样通过返回值进行分支处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_time_t time &#x3D; dispatch_time(DISPATCH_TIME_NOW, 1ull * NSEC_PER_SEC);</span><br><span class="line"></span><br><span class="line">long result &#x3D; dispatch_semaphore_wait(semaphore, time);</span><br><span class="line"></span><br><span class="line">if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	由于 Dispatch Semaphore 的计数值达到大于等于 1</span><br><span class="line">	或者在待机中指定的时间内</span><br><span class="line">	Dispatch Semaphore 的计数值达到大于等于 1</span><br><span class="line">	所以 Dispatch Semaphore 的计数值减去 1。</span><br><span class="line">	</span><br><span class="line">	可执行需要进行排他控制的处理</span><br><span class="line">	*&#x2F;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;**</span><br><span class="line">  由于 Dispatch Semaphore 的计数值为0</span><br><span class="line">  因此在达到指定时间为止待机</span><br><span class="line">  *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dispatch_semaphore_wait 函数返回0时，可安全地执行需要进行排他控制的处理。该处理结束时通过 dispatch_semaphore_signal 函数将 Dispatch Semaphore 的计数值加1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)testDispatchSemaphore2 &#123;</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     生成 Dispatch Semaphore</span><br><span class="line">     Dispatch Semaphore 的计数初始值设定为 “1”。</span><br><span class="line">     保证可访问 NSMutableArray 类对象的线程同时只能有1个。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    dispatch_semaphore_t semaphore &#x3D; dispatch_semaphore_create(1);</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *array &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; 100000; i++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">           &#x2F;**</span><br><span class="line">            等待 Dispatch Semaphore</span><br><span class="line">            一直等待，直到 Dispatch Semaphore 的计数值达到大于等于1。</span><br><span class="line">            *&#x2F;</span><br><span class="line">            dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">            </span><br><span class="line">            &#x2F;**</span><br><span class="line">             由于Dispatch Semaphore 的计数值达到大于等于1</span><br><span class="line">             所以将 Dispatch Semaphore 的计数值减去 1，</span><br><span class="line">             dispatch_semaphore_wait 函数执行返回。</span><br><span class="line"></span><br><span class="line">             即执行到此时的 Dispatch Semaphore 的计数值恒为 0。</span><br><span class="line">             </span><br><span class="line">             由于可访问 NSmutableArray 类对象的线程只有1个，因此可以安全的进行更新。</span><br><span class="line">             *&#x2F;</span><br><span class="line">            [array addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">            </span><br><span class="line">            &#x2F;**</span><br><span class="line">             排他控制处理结束，所以通过 dispatch_semaphore_signal 函数</span><br><span class="line">             将 Dispatch Semaphore 的计数值加1。</span><br><span class="line">             如果有通过 dispatch_semaphore_wait 函数</span><br><span class="line">             等待 Dispatch Semaphore 的计数值增加的线程，</span><br><span class="line">             就由最先等待的线程执行。</span><br><span class="line">             *&#x2F;</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dispatch-once-用法"><a href="#dispatch-once-用法" class="headerlink" title="dispatch_once 用法"></a>dispatch_once 用法</h3><p>dispatch_once 函数是保证在应用程序中只执行一次指定处理的API。如果使用 dispatch_once 函数，源代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)testDispatchOnce &#123;</span><br><span class="line">    </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         初始化</span><br><span class="line">         *&#x2F;</span><br><span class="line">        NSLog(@&quot;当前初始化代码只会执行一次&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 dispatch_once 函数，该源代码即使在多线程环境下执行，也可保证百分之百安全。在生成单例对象时使用。</p>
<h3 id="Dispatch-I-O-用法"><a href="#Dispatch-I-O-用法" class="headerlink" title="Dispatch I/O 用法"></a>Dispatch I/O 用法</h3><p>Dispatch I/O 和 Dispatch Data，可以做到一次使用多个线程更快地并列读取。dispatch_io_create 函数生成 Dispatch I/O，并指定发生错误时用来执行处理的Block，以及执行该Block的 Dispatch Queue。如果想提高文件读取速度，可以尝试使用 Dispatch I/O。</p>
<h3 id="Dispatch-Source-用法"><a href="#Dispatch-Source-用法" class="headerlink" title="Dispatch Source 用法"></a>Dispatch Source 用法</h3><p>GCD中除了主要的 Dispatch Queue 外，还有不太引人注目的 Dispatch Source。下面展示一个使用 DISPATCH_SOURCE_TYPE_TIMER 的定时器的例子。在网络编程的通信超时等情况下可使用该例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void) testDispatchSource &#123;</span><br><span class="line">    </span><br><span class="line">    dispatch_source_t timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     将定时器设定为 15 秒后。</span><br><span class="line">     不指定为重复。</span><br><span class="line">     允许延迟 1 秒。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, 15ull * NSEC_PER_SEC), DISPATCH_TIME_FOREVER, 1ull * NSEC_PER_SEC);</span><br><span class="line">    </span><br><span class="line">    &#x2F;** 指定定时器指定时间内执行的处理 *&#x2F;</span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        NSLog(@&quot;wakeup!&quot;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;** 取消 Dispatch Source 时的处理 *&#x2F;</span><br><span class="line">        dispatch_source_cancel(timer);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;** 指定取消 Dispatch Source 时的处理 *&#x2F;</span><br><span class="line">    dispatch_source_set_cancel_handler(timer, ^&#123;</span><br><span class="line">        NSLog(@&quot;canceled&quot;);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;** 启动 Dispatch Source *&#x2F;</span><br><span class="line">    dispatch_resume(timer);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码在15秒之后会执行“wakeup!”打印，打印完就取消当前的定时器。实际上 Dispatch Queue 没有“取消”这一概念。一旦将处理追加到 Dispatch Queue 中，就没有方法将该处理去除，也没有方法可在执行中取消处理。编程人员要么在处理中导入取消这一概念，要么放弃取消，或者使用 NSOperationQueue 等其他方法。</p>
<p>Dispatch Source 与 Dispatch Queue 不同，是可以取消的。而且取消时必须执行的处理可以指定为回调的Block形式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)testDownloadImg &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *url &#x3D; @&quot;http:&#x2F;&#x2F;images.apple.com&#x2F;jp&#x2F;iphone&#x2F;features&#x2F;includes&#x2F;camera-gallery&#x2F;03-20100607.jpg&quot;;</span><br><span class="line">    </span><br><span class="line">    [[NSURLSession sharedSession] dataTaskWithURL:[NSURL URLWithString:url] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            </span><br><span class="line">            if (!error) &#123;</span><br><span class="line">                </span><br><span class="line">                &#x2F;**</span><br><span class="line">                 在 Global Dispatch Queue 中对下载的数据进行解析处理，</span><br><span class="line">                 不妨碍主线程可长时间处理。</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                </span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    &#x2F;**</span><br><span class="line">                     在 Main Dispatch Queue 中使用解析结果，</span><br><span class="line">                     对用户界面尽心刷新处理。</span><br><span class="line">                     *&#x2F;</span><br><span class="line">                &#125;);</span><br><span class="line">                </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;** 发生错误 *&#x2F;</span><br><span class="line">                NSLog(@&quot;error:%@&quot;, error);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了不妨碍主线程的运行，在另外的线程中解析下载的数据。实现数据解析的就是通过 dispatch_get_global_queue 函数得到的一般优先级的 Global Dispatch Queue 和在 Global Dispatch Queue 中执行解析处理的 dispatch_async 函数。解析处理后为了反映到用户界面，需要在主线程中进行用户界面的更新。通过 dispatch_get_main_queue 函数得到的 Main Dispatch Queue 和在 Main Dispatch Queue 中使该处理执行的 dispatch_async 函数实现了此处理。</p>
<p>那么为了不妨碍主线程的运行，网络下载处理也是使用GCD的线程更好吗？答案是否定的。网络编程强烈推荐使用异步 API。如果在网络编程中使用线程，就很可能会产生大量使用线程的倾向，会引发很多问题。例如每个连接都使用线程，很快就会用尽线程栈内存等。因为Cocoa框架提供了用于异步网络通信的API，所以在网络编程中不可使用线程。务必使用用于异步网络通信的API。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p>《iOS与OS X多线程和内存管理》</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Git服务器搭建</title>
    <url>/Blog/2019/08/24/Git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="1-使用ssh命令登录Linux服务器"><a href="#1-使用ssh命令登录Linux服务器" class="headerlink" title="1.使用ssh命令登录Linux服务器"></a>1.使用ssh命令登录Linux服务器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@104.224.156.100 -p 2022</span><br></pre></td></tr></table></figure>


<h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel</span><br><span class="line">$ yum install git</span><br></pre></td></tr></table></figure>


<h2 id="3-接下来我们-创建一个git用户组和用户，用来运行git服务："><a href="#3-接下来我们-创建一个git用户组和用户，用来运行git服务：" class="headerlink" title="3.接下来我们 创建一个git用户组和用户，用来运行git服务："></a>3.接下来我们 创建一个git用户组和用户，用来运行git服务：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ groupadd git</span><br><span class="line">$ useradd git -g git</span><br></pre></td></tr></table></figure>


<h2 id="4-客户端生成ssh公钥"><a href="#4-客户端生成ssh公钥" class="headerlink" title="4.客户端生成ssh公钥"></a>4.客户端生成ssh公钥</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192:git poet$ ssh-keygen -t rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/poet/.ssh/id_rsa): </span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /Users/poet/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /Users/poet/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:Rky+UE83syyOMjaKYHeoGduGBaPqnU+rtrcyl7TMdL8 poet@192.168.0.101</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 2048]----+</span></span><br><span class="line"><span class="string">|        o . +    |</span></span><br><span class="line"><span class="string">|       = o o +   |</span></span><br><span class="line"><span class="string">| o    . + o o    |</span></span><br><span class="line"><span class="string">|. o .  o + .     |</span></span><br><span class="line"><span class="string">|oo + .= S .      |</span></span><br><span class="line"><span class="string">|o.X..= *         |</span></span><br><span class="line"><span class="string">|.=.o*.+ .        |</span></span><br><span class="line"><span class="string">|. o+oB.  .       |</span></span><br><span class="line"><span class="string">| ..=O+.  E.      |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br><span class="line"><span class="string">192:git poet$ cat /Users/poet/.ssh/id_rsa.pub</span></span><br><span class="line"><span class="string">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDQVX+tOytAUJq3pKNvIFX2HETKvalq4rlqIFJ04KtKIDykzbct5FxK1jR92oIP+ylEsQGz6dJ3FqIsXSn200UIbGvdCvSX5uSFFu8psV4eX1J7DsA6gcLMXElTEHDr82U6MwFmOR6Vb8RkSwsNzRqv8uDdxrmayvbUnQL3VK+/VNcfTdPl2O4YyrYp/DBtFe8b61QvlmU6x4UaX40Sg/r9/JyFMSEDduse9bvVkqg3xkTpaZqwquY7384Ou2iIr4bzlb5mAjW222foM6YBuBhxlovu5kVhLx4GpPsCcxPBJe8lgiGyAGG4yvJ1CH7Rv658eIFqVUyVeOJGP871pLkR poet@192.168.0.101</span></span><br></pre></td></tr></table></figure>


<h2 id="5-创建证书登录，如果没有该文件就创建它："><a href="#5-创建证书登录，如果没有该文件就创建它：" class="headerlink" title="5.创建证书登录，如果没有该文件就创建它："></a>5.创建证书登录，如果没有该文件就创建它：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /home/git/</span><br><span class="line">$ mkdir .ssh</span><br><span class="line">$ chmod 755 .ssh</span><br><span class="line">$ touch .ssh/authorized_keys</span><br><span class="line">$ chmod 644 .ssh/authorized_keys</span><br></pre></td></tr></table></figure>


<h2 id="6-将生成客户端公钥并复制到服务器上"><a href="#6-将生成客户端公钥并复制到服务器上" class="headerlink" title="6.将生成客户端公钥并复制到服务器上"></a>6.将生成客户端公钥并复制到服务器上</h2><p>收集所有需要登录的用户的公钥，公钥位于id_rsa.pub文件中，把我们的公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。<br>下面我们复制id_rsa.pub里的公钥到服务器的authorized_keys文件中。<br>首先使用ssh连接远程的服务器,然后进入目录/home/git，然后执行如下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost git]<span class="comment"># vim .ssh/authorized_keys</span></span><br></pre></td></tr></table></figure>
<p>然后将上面生成的公钥复制到服务器的公钥文件中。复制万保存，查看公钥文件中的内容:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost git]<span class="comment"># cat .ssh/authorized_keys</span></span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDQVX+tOytAUJq3pKNvIFX2HETKvalq4rlqIFJ04KtKIDykzbct5FxK1jR92oIP+ylEsQGz6dJ3FqIsXSn200UIbGvdCvSX5uSFFu8psV4eX1J7DsA6gcLMXElTEHDr82U6MwFmOR6Vb8RkSwsNzRqv8uDdxrmayvbUnQL3VK+/VNcfTdPl2O4YyrYp/DBtFe8b61QvlmU6x4UaX40Sg/r9/JyFMSEDduse9bvVkqg3xkTpaZqwquY7384Ou2iIr4bzlb5mAjW222foM6YBuBhxlovu5kVhLx4GpPsCcxPBJe8lgiGyAGG4yvJ1CH7Rv658eIFqVUyVeOJGP871pLkR poet@192.168.0.101</span><br></pre></td></tr></table></figure>


<h2 id="7-初始化Git仓库"><a href="#7-初始化Git仓库" class="headerlink" title="7.初始化Git仓库"></a>7.初始化Git仓库</h2><p>首先我们选定一个目录作为Git仓库，假定是/home/gitrepo/helloword.git，在/home/gitrepo目录下输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /home</span><br><span class="line">$ mkdir gitrepo</span><br><span class="line">$ chown git:git gitrepo/</span><br><span class="line">$ <span class="built_in">cd</span> gitrepo</span><br><span class="line"></span><br><span class="line">$ git init --bare helloword.git</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /home/gitrepo/helloword.git/</span><br></pre></td></tr></table></figure>


<h2 id="8-以上命令Git创建一个空仓库，服务器上的Git仓库通常都以-git结尾。然后，把仓库所属用户改为git："><a href="#8-以上命令Git创建一个空仓库，服务器上的Git仓库通常都以-git结尾。然后，把仓库所属用户改为git：" class="headerlink" title="8.以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git："></a>8.以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chown -R git:git helloword.git</span><br></pre></td></tr></table></figure>


<h2 id="9-克隆仓库"><a href="#9-克隆仓库" class="headerlink" title="9.克隆仓库"></a>9.克隆仓库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@104.224.156.100:/home/gitrepo/helloword.git</span><br><span class="line">Cloning into <span class="string">&#x27;helloword&#x27;</span>...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>
<p>104.224.156.100 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip。</p>
<p>但是我克隆的时候却报错了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192:git poet$ git <span class="built_in">clone</span> git@104.224.156.100:2022:/home/gitrepo/helloword.git</span><br><span class="line">Cloning into <span class="string">&#x27;helloword&#x27;</span>...</span><br><span class="line">ssh: connect to host 104.224.156.100 port 22: Connection refused</span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">192:git poet$ </span><br></pre></td></tr></table></figure>

<h2 id="10-克隆仓库的时候出了点小差错，因为ssh的端口号被我改了，而Git是依赖于ssh，所以Git的连接请求也会失败。第9步的命令应该换一下"><a href="#10-克隆仓库的时候出了点小差错，因为ssh的端口号被我改了，而Git是依赖于ssh，所以Git的连接请求也会失败。第9步的命令应该换一下" class="headerlink" title="10.克隆仓库的时候出了点小差错，因为ssh的端口号被我改了，而Git是依赖于ssh，所以Git的连接请求也会失败。第9步的命令应该换一下:"></a>10.克隆仓库的时候出了点小差错，因为ssh的端口号被我改了，而Git是依赖于ssh，所以Git的连接请求也会失败。第9步的命令应该换一下:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> ssh://git@104.224.156.100:2022/home/gitrepo/helloword.git</span><br></pre></td></tr></table></figure>
<p>如果你添加到服务器的公钥有效果，则上述命令会自动把项目克隆下来，但是如果公钥无效或者生成公钥的时候设置了密码，则克隆的步骤中会提示输入密码。</p>
<p>这样我们的 Git 服务器安装就完成。</p>
<h2 id="11-如果需要继续添加新的仓库，请到服务器的-home-gitrepo目录下输入命令："><a href="#11-如果需要继续添加新的仓库，请到服务器的-home-gitrepo目录下输入命令：" class="headerlink" title="11.如果需要继续添加新的仓库，请到服务器的/home/gitrepo目录下输入命令："></a>11.如果需要继续添加新的仓库，请到服务器的/home/gitrepo目录下输入命令：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init --bare second.git</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /home/gitrepo/second.git/</span><br></pre></td></tr></table></figure>
<p>以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chown -R git:git second.git</span><br></pre></td></tr></table></figure>
<p>然后你就可以在客户端使用git clone正常的克隆项目了。具体操作命令如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> ssh://git@104.224.156.100:2022/home/gitrepo/second.git</span><br></pre></td></tr></table></figure>


<h2 id="12-克隆了空项目，想在本地试下git是否好用，可以试试下面的命令。"><a href="#12-克隆了空项目，想在本地试下git是否好用，可以试试下面的命令。" class="headerlink" title="12.克隆了空项目，想在本地试下git是否好用，可以试试下面的命令。"></a>12.克隆了空项目，想在本地试下git是否好用，可以试试下面的命令。</h2><p>创建Readme.txt文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ touch Readme.txt</span><br></pre></td></tr></table></figure>

<p>查看当前项目的Git仓库的状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status -s</span><br></pre></td></tr></table></figure>

<p>将Readme.txt文件添加到本地的Git仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add Readme.txt</span><br></pre></td></tr></table></figure>

<p>继续查看本地的Git仓库的状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status -s</span><br></pre></td></tr></table></figure>

<p>将操作提交到本地的Git仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;add Readme.txt file&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果你没有设置本地Git的全局用户名和邮箱，有时候会报错，设置方法如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config  --global user.name 你的目标用户名</span><br><span class="line">$ git config  --global user.email 你的目标邮箱名</span><br></pre></td></tr></table></figure>

<p>将操作推送到远程的Git仓库的master分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<p>在另外一个客户端拉取Git远程仓库master分支的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure>

<p>在本地按时间倒序查看提交的log记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>


<h2 id="13-禁用shell登录"><a href="#13-禁用shell登录" class="headerlink" title="13.禁用shell登录"></a>13.禁用shell登录</h2><p>网上流传在搭建服务器的过程中创建的git用户可以免密登录远程的ssh，试了一把，果不其然登录了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192:~ poet$ ssh git@104.224.156.100 -p 2022</span><br><span class="line">[git@localhost ~]$ ls</span><br><span class="line">[git@localhost ~]$ ls -a</span><br><span class="line">.  ..  .bash_logout  .bash_profile  .bashrc  .ssh</span><br><span class="line">[git@localhost ~]$ </span><br></pre></td></tr></table></figure>

<p>出于安全考虑，第三步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@git ~]<span class="comment"># cat /etc/passwd | grep git</span></span><br><span class="line"></span><br><span class="line">git:x:1001:1001:git version control:/home/git:/bin/bash</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@git ~]<span class="comment"># vim /etc/passwd</span></span><br><span class="line"></span><br><span class="line">git:x:1001:1001:git version control:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure>
<p>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p>
<p>修改完再试一把，发现已经连接不了远程ssh了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192:~ poet$ ssh git@104.224.156.100 -p 2022</span><br><span class="line">Last login: Fri Aug 23 07:56:10 2019 from 222.93.190.219</span><br><span class="line">fatal: What <span class="keyword">do</span> you think I am? A shell?</span><br><span class="line">Connection to 104.224.156.100 closed.</span><br><span class="line">192:~ poet$ ssh git@104.224.156.100 -p 2022</span><br><span class="line">Last login: Fri Aug 23 07:56:39 2019 from 222.93.190.219</span><br><span class="line">fatal: What <span class="keyword">do</span> you think I am? A shell?</span><br><span class="line">Connection to 104.224.156.100 closed.</span><br><span class="line">192:~ poet$ </span><br></pre></td></tr></table></figure>

<h2 id="14-Git报错收集"><a href="#14-Git报错收集" class="headerlink" title="14.Git报错收集"></a>14.Git报错收集</h2><ul>
<li><p>git clone does not appear to be a git repository<br>错误示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">poetmacbook-pro:git kris$ git <span class="built_in">clone</span> ssh://git@10.211.55.4:/home/gitrepo/IMBasic.git</span><br><span class="line">正克隆到 <span class="string">&#x27;IMBasic&#x27;</span>...</span><br><span class="line">fatal: <span class="string">&#x27;/home/gitrepo/IMBasic.git&#x27;</span> does not appear to be a git repository</span><br><span class="line">fatal: 无法读取远程仓库。</span><br><span class="line"></span><br><span class="line">请确认您有正确的访问权限并且仓库存在。</span><br></pre></td></tr></table></figure>

<p>问题产生的原因：git仓库的路径不对，请确认<code>/home/gitrepo/IMBasic.git</code>是否确实存在，还要注意此处应该使用服务器上的绝对路径，不能使用相对路径。</p>
</li>
</ul>
<h2 id="15-关联远程仓库"><a href="#15-关联远程仓库" class="headerlink" title="15.关联远程仓库"></a>15.关联远程仓库</h2><p>如果已经关联过远程仓库，可以先删除关联的远程Git仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote rm origin</span><br></pre></td></tr></table></figure>

<p>再添加关联的远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:xxx/xxx.git</span><br></pre></td></tr></table></figure>



<p>参考链接:<br><a href="https://www.runoob.com/git/git-server.html">Git 服务器搭建</a><br><a href="https://www.linuxidc.com/Linux/2014-05/101830.htm">Git 服务器搭建与客户端安装</a><br><a href="https://www.cnblogs.com/bass6/p/6382633.html">git 从远程git服务上拉代码 git服务器非默认端口</a><br><a href="https://baijiahao.baidu.com/s?id=1621628813408131040&wfr=spider&for=pc">Git常用命令总结及其用法说明</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客添加评论功能</title>
    <url>/Blog/2020/08/29/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="为什么添加gitalk评论？"><a href="#为什么添加gitalk评论？" class="headerlink" title="为什么添加gitalk评论？"></a>为什么添加gitalk评论？</h2><p>Next主题支持的评论有<code>disqus</code>、<code>disqusjs</code>、<code>changyan</code>、<code>gitalk</code>、<code>livere</code>、<code>valine</code>。前面两个都需要翻墙才可以使用；畅言需要注册；<code>valine</code>需要注册，并且绑定身份证号后才可以使用；<code>livere</code>是韩国的，注册页面没有国际化，看不懂。综合下来选了<code>gitalk</code>,<code>gitalk</code>是使用github上仓库的issue来存储用户的评论，非常方便。</p>
<h2 id="如何给自己的博客添加gitalk评论呢？"><a href="#如何给自己的博客添加gitalk评论呢？" class="headerlink" title="如何给自己的博客添加gitalk评论呢？"></a>如何给自己的博客添加gitalk评论呢？</h2><p>参考<a href="https://github.com/gitalk/gitalk/blob/master/readme-cn.md">gitalk官网</a>和<a href="https://gitalk.github.io/">gitalk的Demo</a>来尝试在Next中接入gitalk。<br>1.首先需要选择一个公共的github仓库（已存在或创建一个新的github存储库）用于存储评论。<br>2.需要创建<em>GitHub Application</em>, 如果没有<a href="https://github.com/settings/applications/new">点击这里申请</a>，Authorization callback URL填写当前博客的首页地址。</p>
<img src="/Blog/2020/08/29/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/%E7%94%B3%E8%AF%B7GitApplicationKey%E6%88%AA%E5%9B%BE.png" class="" title="申请GitApplicationKey截图">
<p>3.修改Next主题的<code>_config.yml</code>，开启gitalk评论。配置内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Gitalk</span></span><br><span class="line"><span class="comment"># For more information: https://gitalk.github.io, https://github.com/gitalk/gitalk</span></span><br><span class="line">gitalk:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  github_id: DavidWanderer(从博客地址中获取：https://davidwanderer.github.io/Blog/，自己的依次类推)</span><br><span class="line">  id: location.pathname</span><br><span class="line">  repo: Blog(这里只需要最终的仓库名，不需要全路径，我把评论直接存储在自己的博客仓库里)</span><br><span class="line">  client_id: ce08****8271(此id从第2步申请结果中获取)</span><br><span class="line">  client_secret: 1d47***9a608(此secret从第二步申请结果中获取)</span><br><span class="line">  admin_user: DavidWanderer(此处需要和github_id保持一致)</span><br><span class="line">  distraction_free_mode: <span class="literal">true</span> <span class="comment"># Facebook-like distraction free mode</span></span><br><span class="line">  <span class="comment"># Gitalk&#x27;s display language depends on user&#x27;s browser or system environment</span></span><br><span class="line">  <span class="comment"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span></span><br><span class="line">  <span class="comment"># Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span></span><br><span class="line">  language: zh-CN</span><br></pre></td></tr></table></figure>

<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>1.博客的评论在使用之前需要登录配置的<code>admin_user</code>进行初始化评论，包括github授权等等操作，否则会出现如下问题。</p>
<img src="/Blog/2020/08/29/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98.png" class="" title="博客评论未初始化问题截图">

<p>2.博客的评论有时候会出现<code>Network Error</code>的问题，一般情况下，使用自己的Github账号登录一下，就不会出现问题了。但是如果问题还是没有消除，请检查<code>Next</code>配置文件中的<code>Gitalk</code>配置中的<code>github_id</code>、<code>admin_user</code>、<code>repo</code>填写的是否正确，可以结合Chrome的网页调试工具调试查看是否是认证失败，如果是认证失败，请检查<code>Gitalk</code>配置。<br>评论Network Error截图：</p>
<img src="/Blog/2020/08/29/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/%E8%AF%84%E8%AE%BANetworkError%E9%97%AE%E9%A2%98.png" class="" title="评论NetworkError问题截图">

<p>评论接入成功后的截图：</p>
<img src="/Blog/2020/08/29/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/%E8%AF%84%E8%AE%BA%E6%8E%A5%E5%85%A5%E6%88%90%E5%8A%9F.png" class="" title="评论接入成功的截图">

]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>通用</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins问题汇总</title>
    <url>/Blog/2021/01/24/Jenkins%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="Jenkins执行Shell脚本，控制台出现中文乱码怎么办？"><a href="#Jenkins执行Shell脚本，控制台出现中文乱码怎么办？" class="headerlink" title="Jenkins执行Shell脚本，控制台出现中文乱码怎么办？"></a>Jenkins执行Shell脚本，控制台出现中文乱码怎么办？</h1><p>使用Jenkins执行Shell脚本，默认的情况下，Jenkins的控制台展示的中文会出现部分乱码，如下图所示：</p>
<img src="/Blog/2021/01/24/Jenkins%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/2.jpg" class="" title="Jenkins部分中文乱码问题截图">
<p>解决办法：</p>
<ul>
<li>1.在<code>系统管理-&gt;系统配置-&gt;全局属性</code>添加一个键值对，键的名称<code>LANG</code>，值的名称<code>zh.CH.UTF-8</code>，然后划到网页的底部保存并应用。</li>
<li>2.并且在Shell脚本的最开始添加<code>#!/bin/bash</code>来指定使用系统的Shell命令来执行。<br>截图1:<img src="/Blog/2021/01/24/Jenkins%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/3.jpg" class="" title="解决Jenkins终端乱码问题-添加全局属性">
截图2:<img src="/Blog/2021/01/24/Jenkins%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/4.jpg" class="" title="解决Jenkins终端乱码问题-指定使用系统的Shell来执行命令">
解决完乱码之后的截图：<img src="/Blog/2021/01/24/Jenkins%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/6.jpg" class="" title="解决完Jenkins乱码的截图">

</li>
</ul>
<h1 id="Jenkins提示invalid-byte-sequence-in-US-ASCII怎么办"><a href="#Jenkins提示invalid-byte-sequence-in-US-ASCII怎么办" class="headerlink" title="Jenkins提示invalid byte sequence in US-ASCII怎么办?"></a>Jenkins提示<code>invalid byte sequence in US-ASCII</code>怎么办?</h1><p>使用Jenkins执行Shell脚本的时候，出现了这个提示，截图如下：</p>
<img src="/Blog/2021/01/24/Jenkins%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/1.jpeg" class="" title="invalid byte sequence in US-ASCII问题截图">
<p>解决办法：<br>在<code>系统管理-&gt;系统配置-&gt;全局属性</code>添加一个键值对，键的名称<code>LC_ALL</code>，值的名称<code>en_US.UTF-8</code>，然后划到网页的底部保存并应用。</p>
<img src="/Blog/2021/01/24/Jenkins%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/5.jpg" class="" title="解决Jenkins提示字符无效的问题">
<p>解决完乱码之后的截图：</p>
<img src="/Blog/2021/01/24/Jenkins%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/7.jpg" class="" title="解决完Jenkins提示字符无效问题的截图">

<h1 id="如果Jenkins控制台提示无权限访问文件或路径怎么办？"><a href="#如果Jenkins控制台提示无权限访问文件或路径怎么办？" class="headerlink" title="如果Jenkins控制台提示无权限访问文件或路径怎么办？"></a>如果Jenkins控制台提示无权限访问文件或路径怎么办？</h1><p>解决办法：<br>需要找到Jenkins的配置文件，我的Jenkins是使用<code>Homebrew</code>安装的，配置文件路径是<code>/Library/LaunchDaemons/org.jenkins-ci.plist</code>。<br>找到这个文件之后，修改<code>GroupName</code>和<code>UserName</code>，让这两个值和电脑登录的组名和用户名保持一致。</p>
<img src="/Blog/2021/01/24/Jenkins%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/8.png" class="" title="修改Jenkins执行的组名和用户名">

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/fa546f723724">Jenkins执行脚本提示没有权限的解决办法</a><br><a href="http://www.voidcn.com/article/p-oybichjy-bep.html">Jenkins上，xcpretty编译报错：invalid byte sequence in US-ASCII</a></p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>KVC</title>
    <url>/Blog/2019/06/27/KVC/</url>
    <content><![CDATA[<h2 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h2><p>KVC（Key-value coding）键值编码，指iOS的开发中，可以允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值而不需要调用明确的存取方法。</p>
<h3 id="1、KVC中常见方法"><a href="#1、KVC中常见方法" class="headerlink" title="1、KVC中常见方法"></a>1、KVC中常见方法</h3><p>我们随便点击进入<code>setValue:forKey</code>方法，我们可以发现里面的方法基本上都是基于<code>NSObject</code>的<code>NSKeyValueCoding</code>分类写的，所以对于所有继承了NSObject的类型，也就是几乎所有的Objective-C对象都能使用KVC(一些纯Swift类和结构体是不支持KVC的)，下面是KVC最为重要的四个方法：</p>
<img src="/Blog/2019/06/27/KVC/KVC1.png" class="" title="KVC截图">

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;                          <span class="comment">//直接通过Key来取值</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;          <span class="comment">//通过Key来设值</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;                  <span class="comment">//通过KeyPath来取值</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;  <span class="comment">//通过KeyPath来设值</span></span><br></pre></td></tr></table></figure>
<p><code>NSKeyValueCoding</code>类别中还有其他的一些方法，这些方法在碰到特殊情况或者有特殊需求还是会用到的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认返回YES，表示如果没有找到Set&lt;Key&gt;方法的话，会按照_key，_iskey，key，iskey的顺序搜索成员，设置成NO就不这样搜索</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)accessInstanceVariablesDirectly;</span><br><span class="line"></span><br><span class="line"><span class="comment">//KVC提供属性值正确性验证的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)validateValue:(<span class="keyword">inout</span> <span class="keyword">id</span> __<span class="keyword">nullable</span> * __<span class="keyword">nonnull</span>)ioValue forKey:(<span class="built_in">NSString</span> *)inKey error:(<span class="keyword">out</span> <span class="built_in">NSError</span> **)outError;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是集合操作的API，里面还有一系列这样的API，如果属性是一个NSMutableArray，那么可以用这个方法来返回。</span></span><br><span class="line">- (<span class="built_in">NSMutableArray</span> *)mutableArrayValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果Key不存在，且没有KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常。</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和上一个方法一样，但这个方法是设值。</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你在SetValue方法时面给Value传nil，则会调用这个方法</span></span><br><span class="line">- (<span class="keyword">void</span>)setNilValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入一组key,返回该组key对应的Value，再转成字典返回，用于将Model转到字典。</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br></pre></td></tr></table></figure>


<h3 id="2、KVC的内部实现机制"><a href="#2、KVC的内部实现机制" class="headerlink" title="2、KVC的内部实现机制"></a>2、KVC的内部实现机制</h3><h4 id="KVC的setValue-forKey原理"><a href="#KVC的setValue-forKey原理" class="headerlink" title="KVC的setValue:forKey原理"></a>KVC的<code>setValue:forKey</code>原理</h4><p>我们先来一张图片可以直接明了的看清楚实现原理</p>
<img src="/Blog/2019/06/27/KVC/KVC2.png" class="" title="KVC截图">

<ul>
<li>1、按照<code>setKey</code>，<code>_setKey</code>的顺序查找<code>成员方法</code>，如果找到方法，传递参数，调用方法</li>
<li>2、如果没有找到，查看<code>accessInstanceVariablesDirectly</code>的返回值（<code>accessInstanceVariablesDirectly</code>的返回值默认是<code>YES</code>），<ul>
<li>返回值为YES，按照<code>_Key,_isKey,Key,isKey</code>的顺序查找<code>成员变量</code>，如果找到，直接赋值，如果没有找到，调用<code>setValue:forUndefinedKey:</code>，抛出异常</li>
<li>返回NO，直接调用<code>setValue:forUndefinedKey:</code>，抛出异常</li>
</ul>
</li>
</ul>
<h4 id="KVC的ValueforKey原理"><a href="#KVC的ValueforKey原理" class="headerlink" title="KVC的ValueforKey原理"></a>KVC的<code>ValueforKey</code>原理</h4><img src="/Blog/2019/06/27/KVC/KVC3.png" class="" title="KVC截图">
<ul>
<li>1、按照<code>getKey,key,isKey,_key</code>的顺序查找<code>成员方法</code>，如果找到直接调用<code>取值</code></li>
<li>2、如果没有找到，查看<code>accessInstanceVariablesDirectly</code>的返回值</li>
<li>返回值为YES，按照<code>_Key,_isKey,Key,isKey</code>的顺序查找<code>成员变量</code>，如果找到，直接<code>取值</code>，如果没有找到，调用<code>setValue:forUndefinedKey:</code>，抛出异常</li>
<li>返回NO，直接调用<code>setValue:forUndefinedKey:</code>，抛出异常</li>
</ul>
<h3 id="3、KVC的使用"><a href="#3、KVC的使用" class="headerlink" title="3、KVC的使用"></a>3、KVC的使用</h3><h4 id="KVC基础使用"><a href="#KVC基础使用" class="headerlink" title="KVC基础使用"></a>KVC基础使用</h4><p>假设我们有一个<code>Person</code>类，里面有一个<code>age</code>属性，我们给<code>age</code>赋值和取值</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">[p setValue:@<span class="number">10</span> forKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line"><span class="comment">//取值</span></span><br><span class="line">[p valueForKey:<span class="string">@&quot;age&quot;</span>];</span><br></pre></td></tr></table></figure>
<p>这也是最简单的使用方法了，也是我们平时项目中最常使用的方法了。</p>
<h4 id="KVC中使用keyPath"><a href="#KVC中使用keyPath" class="headerlink" title="KVC中使用keyPath"></a>KVC中使用keyPath</h4><p>但是当<code>Person</code>类里面有一个<code>Student</code>类，里面有一个<code>height</code>属性，我们怎么赋值<code>height</code>属性呢，</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) Student *stu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>我们能否这样写呢</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Person *p = [[Person alloc]init];</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">[p setValue:@<span class="number">10</span> forKey:<span class="string">@&quot;stu.height&quot;</span>];</span><br><span class="line"><span class="comment">//取值</span></span><br><span class="line">[p valueForKey:<span class="string">@&quot;stu.height&quot;</span>];</span><br></pre></td></tr></table></figure>
<p>我们运行程序打印结果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">41</span>:<span class="number">13.085990</span>+<span class="number">0800</span> KVC[<span class="number">2974</span>:<span class="number">107108</span>] *** Terminating app due to uncaught exception <span class="string">&#x27;NSUnknownKeyException&#x27;</span>, reason: <span class="string">&#x27;[&lt;Person 0x600000d90160&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key stu.height.&#x27;</span></span><br><span class="line">*** First throw call stack:</span><br><span class="line">(</span><br><span class="line">	<span class="number">0</span>   CoreFoundation                      <span class="number">0x00007fff23c7127e</span> __exceptionPreprocess + <span class="number">350</span></span><br><span class="line">	<span class="number">1</span>   libobjc.A.dylib                     <span class="number">0x00007fff513fbb20</span> objc_exception_throw + <span class="number">48</span></span><br><span class="line">	<span class="number">2</span>   CoreFoundation                      <span class="number">0x00007fff23c70e49</span> -[<span class="built_in">NSException</span> raise] + <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>打印结果是<code>this class is not key value coding-compliant for the key stu.height.</code>,所以这个方法是不可以的，但是iOS为我们提供了另一个方法<code>KeyPath</code>:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Person *p = [[Person alloc]init];</span><br><span class="line">p.stu = [[Student alloc]init];</span><br><span class="line">[p setValue:@<span class="number">180</span> forKeyPath:<span class="string">@&quot;stu.height&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;valueForKey:%@&quot;</span>,[p valueForKeyPath:<span class="string">@&quot;stu.height&quot;</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;stu.height:%f&quot;</span>,p.stu.height);</span><br></pre></td></tr></table></figure>
<p>打印结果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">43</span>:<span class="number">31.258661</span>+<span class="number">0800</span> KVC[<span class="number">3012</span>:<span class="number">108720</span>] valueForKey:<span class="number">180</span></span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">43</span>:<span class="number">31.258805</span>+<span class="number">0800</span> KVC[<span class="number">3012</span>:<span class="number">108720</span>] stu.height:<span class="number">180.000000</span></span><br></pre></td></tr></table></figure>


<p><code>keyPath</code>除了对当前对象的属性进行赋值外，还可以对其更“深层”的对象进行赋值。KVC进行多级访问时，直接类似于属性调用一样用点语法进行访问即可。</p>
<h4 id="KVC之集合属性"><a href="#KVC之集合属性" class="headerlink" title="KVC之集合属性"></a>KVC之集合属性</h4><p>如果我们想要修改集合类型，我们该怎么办呢，不要着急，系统还是很友好的给我们提供了一些方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableArray</span> *)mutableArrayValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="built_in">NSMutableArray</span> *)mutableArrayValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMutableSet</span> *)mutableSetValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">- (<span class="built_in">NSMutableSet</span> *)mutableSetValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMutableOrderedSet</span> *)mutableOrderedSetValueForKey:(<span class="built_in">NSString</span> *)key </span><br><span class="line">- (<span class="built_in">NSMutableOrderedSet</span> *)mutableOrderedSetValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br></pre></td></tr></table></figure>


<p>简单使用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">[[p mutableArrayValueForKey:<span class="string">@&quot;list&quot;</span>] addObject:<span class="string">@&quot;test&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;mutableArrayValueForKey:%@&quot;</span>,[p valueForKeyPath:<span class="string">@&quot;list&quot;</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,p.list);</span><br></pre></td></tr></table></figure>

<p>关于<code>mutableArrayValueForKey:</code>的适用场景，网上一般说是在<code>KVO</code>中，因为<code>KVO的本质是系统监测到某个属性的内存地址或常量改变</code>时会添加上<code>- (void)willChangeValueForKey:(NSString *)key</code>和<code>- (void)didChangeValueForKey:(NSString *)key</code>方法来发送通知，但是如果直接改数组的话，内存地址并没有改变。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">	[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">	<span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span>|<span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">	_p = [[Person alloc]init];</span><br><span class="line">	[_p addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;list&quot;</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line"><span class="comment">//    [_p.list addObject:@(arc4random()%255)];</span></span><br><span class="line"><span class="comment">//    NSLog(@&quot;打印内存地址：%x&quot;,self.p.list);</span></span><br><span class="line"><span class="comment">//    NSLog(@&quot;打印内容:%@&quot;,self.p.list);</span></span><br><span class="line"></span><br><span class="line">	[[<span class="keyword">self</span>.p mutableArrayValueForKey:<span class="string">@&quot;list&quot;</span>] addObject:@(arc4random()%<span class="number">255</span>)];</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;打印内存地址：%x&quot;</span>,<span class="keyword">self</span>.p.list);</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;打印内容:%@&quot;</span>,<span class="keyword">self</span>.p.list);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line">	[_p removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;list&quot;</span>]; <span class="comment">//一定要在dealloc里面移除观察</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们分别用<code> [_p.list addObject:@(arc4random()%255)];</code>和<code>[[self.p mutableArrayValueForKey:@&quot;list&quot;] addObject:@(arc4random()%255)];</code>两个方法修改<code>list</code>内容，我们打印可知<code> [_p.list addObject:@(arc4random()%255)];</code>方法并没有改变<code>list</code>的内存地址，而使用<code>[[self.p mutableArrayValueForKey:@&quot;list&quot;] addObject:@(arc4random()%255)];</code>  ， <code>list</code>的内存地址改变了。</p>
<h4 id="KVC之字典属性"><a href="#KVC之字典属性" class="headerlink" title="KVC之字典属性"></a>KVC之字典属性</h4><p>KVC里面还有两个关于NSDictionary的方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br><span class="line">- (<span class="keyword">void</span>)setValuesForKeysWithDictionary:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)keyedValues;</span><br></pre></td></tr></table></figure>

<p><code>dictionaryWithValuesForKeys:</code>是指输入一组key，返回这组key对应的属性，再组成一个字典<br><code>setValuesForKeysWithDictionary</code>是用来修改dic中对应key的属性</p>
<p>这个属性最常用到的地方就是字典转模型<br>例如我们有一个<code>Student</code>类，</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">float</span> height;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>我们正常是怎么赋值呢</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Student *stu = [[Student alloc]init];</span><br><span class="line">stu.age = <span class="number">10</span>;</span><br><span class="line">stu.name = <span class="string">@&quot;jack&quot;</span>;</span><br><span class="line">stu.height = <span class="number">180</span>;</span><br></pre></td></tr></table></figure>
<p>如果里面有100个属性呢，我们就需要写100遍。如果使用<code>setValuesForKeysWithDictionary</code>方法呢</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Student *stu = [[Student alloc]init];</span><br><span class="line"><span class="comment">//在进行网络请求的时候dic不需要我们手写，是后台返回的</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *dic = @&#123;<span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;jack&quot;</span>,<span class="string">@&quot;height&quot;</span>:@<span class="number">180</span>,<span class="string">@&quot;age&quot;</span>:@<span class="number">10</span>&#125;;</span><br><span class="line">[stu setValuesForKeysWithDictionary:dic];</span><br></pre></td></tr></table></figure>
<p>这样是不是简单了好多。</p>
<h3 id="4、KVC异常处理"><a href="#4、KVC异常处理" class="headerlink" title="4、KVC异常处理"></a>4、KVC异常处理</h3><p>当根据KVC搜索规则，没有搜索到对应的key或者keyPath，则会调用对应的异常方法。异常方法的默认实现，在异常发生时会抛出一个<code>NSUndefinedKeyException</code>的异常，并且应用程序<code>Crash</code>。我们可以重写下面两个方法，根据业务需求合理的处理KVC导致的异常。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)setNilValueForKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure>

<p>其中重写这两个方法，在<code>key</code>值不存在的时候，会走下面方法，而不会异常抛出</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure>
<p>重写这个方法，当value值为nil的时候，会走下面方法，而不会异常抛出</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setNilValueForKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure>



<h3 id="5、KVC的正确性验证"><a href="#5、KVC的正确性验证" class="headerlink" title="5、KVC的正确性验证"></a>5、KVC的正确性验证</h3><p>在调用KVC时可以先进行验证，验证通过下面两个方法进行，支持key和keyPath两种方式。验证方法默认实现返回YES，可以通过重写对应的方法修改验证逻辑。</p>
<p>验证方法需要我们手动调用，并不会在进行KVC的过程中自动调用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)validateValue:(<span class="keyword">inout</span> <span class="keyword">id</span> _Nullable * _Nonnull)ioValue forKey:(<span class="built_in">NSString</span> *)inKey error:(<span class="keyword">out</span> <span class="built_in">NSError</span> **)outError;</span><br><span class="line">- (<span class="built_in">BOOL</span>)validateValue:(<span class="keyword">inout</span> <span class="keyword">id</span> _Nullable * _Nonnull)ioValue forKeyPath:(<span class="built_in">NSString</span> *)inKeyPath error:(<span class="keyword">out</span> <span class="built_in">NSError</span> **)outError;</span><br></pre></td></tr></table></figure>
<p> 在validateValue方法的内部实现中，如果传入的value或key有问题，可以通过返回NO来表示错误，并设置NSError对象。</p>
<p><a href="https://github.com/DavidWanderer/iOS_Examples">参考demo</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>KVO实现原理</title>
    <url>/Blog/2019/06/22/KVO%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="KVO实现原理"><a href="#KVO实现原理" class="headerlink" title="KVO实现原理"></a>KVO实现原理</h2><p><code>KVO(key value observing)</code>键值监听是我们在开发中常使用的用于监听特定对象属性值变化的方法，常用于监听数据模型的变化 。<br>KVO是为了监听一个对象的某个属性值是否发生变化。在属性值发生变化的时候，肯定会调用其setter方法。所以<code>KVO的本质就是监听对象有没有调用被监听属性对应的setter方法</code>。<br>在学习实现原理之前我们首先先了解一下<code>KVO</code>常用的有哪些方法。</p>
<h3 id="KVO常用方法"><a href="#KVO常用方法" class="headerlink" title="KVO常用方法"></a>KVO常用方法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注册监听器</span></span><br><span class="line"><span class="comment">监听器对象为observer，被监听对象为消息的发送者即方法的调用者在回调函数中会被回传</span></span><br><span class="line"><span class="comment">监听的属性路径为keyPath支持点语法的嵌套</span></span><br><span class="line"><span class="comment">监听类型为options支持按位或来监听多个事件类型</span></span><br><span class="line"><span class="comment">监听上下文context主要用于在多个监听器对象监听相同keyPath时进行区分</span></span><br><span class="line"><span class="comment">添加监听器只会保留监听器对象的地址，不会增加引用，也不会在对象释放后置空，因此需要自己持有监听对象的强引用，该参数也会在回调函数中回传</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">删除监听器</span></span><br><span class="line"><span class="comment">监听器对象为observer，被监听对象为消息的发送者即方法的调用者，应与addObserver方法匹配</span></span><br><span class="line"><span class="comment">监听的属性路径为keyPath，应与addObserver方法的keyPath匹配</span></span><br><span class="line"><span class="comment">监听上下文context，应与addObserver方法的context匹配</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">与上一个方法相同，只是少了context参数</span></span><br><span class="line"><span class="comment">推荐使用上一个方法，该方法由于没有传递context可能会产生异常结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">监听器对象的监听回调方法</span></span><br><span class="line"><span class="comment">keyPath即为监听的属性路径</span></span><br><span class="line"><span class="comment">object为被监听的对象</span></span><br><span class="line"><span class="comment">change保存被监听的值产生的变化</span></span><br><span class="line"><span class="comment">context为监听上下文，由add方法回传</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="KVO简单实现"><a href="#KVO简单实现" class="headerlink" title="KVO简单实现"></a>KVO简单实现</h3><p>我们创建一个<code>person</code>对象，然后在里面添加一个<code>age</code>属性，我们就来观察一下<code>age</code>属性。<br><strong>person对象</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>简单实现</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) Person *p1;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) Person *p2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.p1 = [[Person alloc]init];</span><br><span class="line">    <span class="keyword">self</span>.p2 = [[Person alloc]init];</span><br><span class="line">    <span class="keyword">self</span>.p1.age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">self</span>.p2.age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给person1对象添加KVO监听</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [<span class="keyword">self</span>.p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:options context:<span class="string">@&quot;123&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="keyword">self</span>.p1.age = arc4random()%<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">self</span>.p2.age = arc4random()%<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.p1 removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> context:<span class="string">@&quot;123&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当监听对象的属性值发生改变时，就会调用</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;监听到%@的%@属性值改变了 - %@ - %@&quot;</span>, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上代码就是一个<code>KVO</code>的简单实现，但是我们有没有想过他的内部到底是怎样实现的呢，今天我们就来探究一下<code>KVO</code>的内部实现原理。</p>
<h3 id="KVO的内部实现"><a href="#KVO的内部实现" class="headerlink" title="KVO的内部实现"></a>KVO的内部实现</h3><p>探究一个对象底层实现最简单的办法就行打印一些对象信息，看看有什么改变，我们在给<code>person1</code>添加监听之前分别打印<code>p1,p2</code>的类信息。<br>代码实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;person1添加KVO监听之前 - %@ %@&quot;</span>, object_getClass(<span class="keyword">self</span>.p1), object_getClass(<span class="keyword">self</span>.p2));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给person1对象添加KVO监听</span></span><br><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">[<span class="keyword">self</span>.p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:options context:<span class="string">@&quot;123&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;person1添加KVO监听之后 - %@ %@&quot;</span>, object_getClass(<span class="keyword">self</span>.p1), object_getClass(<span class="keyword">self</span>.p2));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">17</span>:<span class="number">41.812979</span>+<span class="number">0800</span> KVO[<span class="number">28865</span>:<span class="number">5328765</span>] person1添加KVO监听之前 - Person Person</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">17</span>:<span class="number">41.814729</span>+<span class="number">0800</span> KVO[<span class="number">28865</span>:<span class="number">5328765</span>] person1添加KVO监听之后 - <span class="built_in">NSKVONotifying_Person</span> Person</span><br></pre></td></tr></table></figure>

<p>我们根据结果看到，在添加KVO观察者之后<code>p1</code>的类对象由<code>Person</code>变成了<code>NSKVONotifying_Person</code>，虽然<code>p1</code>的类对象变成了<code>NSKVONotifying_Person</code>，但是我们在调用的时候感觉我们的<code>p1</code>的类对象还是<code>Person</code>，所以，我们可以猜测<code>KVO</code>会在运行时动态创建一个新类，将对象的<code>isa</code>指向新创建的类，<code>新类是原类的子类</code>，命名规则是<code>NSKVONotifying_xxx</code>的格式。KVO为了使其更像之前的类，还会将对象的<code>class实例方法重写</code>，使其更像原类。</p>
<p> <strong>查看P1内部方法是否改变</strong></p>
<p>我们在发现<code>p1</code>的类对象由<code>Person</code>变成了<code>NSKVONotifying_Person</code>，那我们也随便打印一下<code>Person</code>和<code>NSKVONotifying_Person</code>内部方法都变成了什么。</p>
<p>打印一下方法名：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)printMethodNamesOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// 获得方法数组</span></span><br><span class="line">    Method *methodList = class_copyMethodList(cls, &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储方法名</span></span><br><span class="line">    <span class="built_in">NSMutableString</span> *methodNames = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 获得方法</span></span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        <span class="comment">// 获得方法名</span></span><br><span class="line">        <span class="built_in">NSString</span> *methodName = <span class="built_in">NSStringFromSelector</span>(method_getName(method));</span><br><span class="line">        <span class="comment">// 拼接方法名</span></span><br><span class="line">        [methodNames appendString:methodName];</span><br><span class="line">        [methodNames appendString:<span class="string">@&quot;, &quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放</span></span><br><span class="line">    free(methodList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印方法名</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %@&quot;</span>, cls, methodNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们分别在KVO监听前后在分别打印一下<code>p1</code>的类对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;person1添加KVO监听之前的内部方法===&quot;</span>);</span><br><span class="line">[<span class="keyword">self</span> printMethodNamesOfClass:object_getClass(<span class="keyword">self</span>.p1)];</span><br><span class="line"><span class="comment">// 给person1对象添加KVO监听</span></span><br><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">[<span class="keyword">self</span>.p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:options context:<span class="string">@&quot;123&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;person1添加KVO监听之后的内部方法===&quot;</span>);</span><br><span class="line">[<span class="keyword">self</span> printMethodNamesOfClass:object_getClass(<span class="keyword">self</span>.p1)];</span><br></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">21</span>:<span class="number">35.457729</span>+<span class="number">0800</span> KVO[<span class="number">28868</span>:<span class="number">5329249</span>] person1添加KVO监听之前的内部方法===</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">21</span>:<span class="number">35.458094</span>+<span class="number">0800</span> KVO[<span class="number">28868</span>:<span class="number">5329249</span>] Person setAge:, age,</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">21</span>:<span class="number">35.459171</span>+<span class="number">0800</span> KVO[<span class="number">28868</span>:<span class="number">5329249</span>] person1添加KVO监听之后的内部方法===</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">21</span>:<span class="number">35.459334</span>+<span class="number">0800</span> KVO[<span class="number">28868</span>:<span class="number">5329249</span>] <span class="built_in">NSKVONotifying_Person</span> setAge:, <span class="keyword">class</span>, dealloc, _isKVOA,</span><br></pre></td></tr></table></figure>

<p>我们在来打印一些KVO监听前后<code>setAge</code>方法发生了什么改变，因为值得改变肯定是因为<code>set</code>方法导致的，所以我们打印一下<code>setAge</code>方法。<code>methodForSelector</code>可以打印方法地址，我们分别在KVO监听前后打印。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;person1添加KVO监听之前 - %p %p&quot;</span>,</span><br><span class="line">[<span class="keyword">self</span>.p1 methodForSelector:<span class="keyword">@selector</span>(setAge:)],</span><br><span class="line">[<span class="keyword">self</span>.p2 methodForSelector:<span class="keyword">@selector</span>(setAge:)]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给person1对象添加KVO监听</span></span><br><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">[<span class="keyword">self</span>.p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:options context:<span class="string">@&quot;123&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;person1添加KVO监听之后 - %p %p&quot;</span>,</span><br><span class="line">[<span class="keyword">self</span>.p1 methodForSelector:<span class="keyword">@selector</span>(setAge:)],</span><br><span class="line">[<span class="keyword">self</span>.p2 methodForSelector:<span class="keyword">@selector</span>(setAge:)]);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">25</span>:<span class="number">12.925158</span>+<span class="number">0800</span> KVO[<span class="number">28871</span>:<span class="number">5329672</span>] person1添加KVO监听之前 - <span class="number">0x100192338</span> <span class="number">0x100192338</span></span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">25</span>:<span class="number">12.925468</span>+<span class="number">0800</span> KVO[<span class="number">28871</span>:<span class="number">5329672</span>] person1添加KVO监听之后 - <span class="number">0x2269f0a38</span> <span class="number">0x100192338</span></span><br></pre></td></tr></table></figure>
<p>我们可以利用lldb分别看一下具体的方法实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">25</span>:<span class="number">12.925158</span>+<span class="number">0800</span> KVO[<span class="number">28871</span>:<span class="number">5329672</span>] person1添加KVO监听之前 - <span class="number">0x100192338</span> <span class="number">0x100192338</span></span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">25</span>:<span class="number">12.925468</span>+<span class="number">0800</span> KVO[<span class="number">28871</span>:<span class="number">5329672</span>] person1添加KVO监听之后 - <span class="number">0x2269f0a38</span> <span class="number">0x100192338</span></span><br><span class="line">(lldb) p (IMP)<span class="number">0x100192338</span></span><br><span class="line">(IMP) $<span class="number">0</span> = <span class="number">0x0000000100192338</span> (KVO`-[Person setAge:] at Person.h:<span class="number">12</span>)</span><br><span class="line">(lldb) p (IMP)<span class="number">0x2269f0a38</span></span><br><span class="line">(IMP) $<span class="number">1</span> = <span class="number">0x00000002269f0a38</span> (Foundation`_NSSetLongLongValueAndNotify)</span><br><span class="line">(lldb) </span><br></pre></td></tr></table></figure>

<p>根据以上总结，我们大概猜到在使用KVO前后对象的改变了。<br><strong>未使用KVO监听的对象</strong></p>
<img src="/Blog/2019/06/22/KVO%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/KVO3.png" class="" title="KVO截图">

<p><strong>使用KVO监听的对象</strong></p>
<img src="/Blog/2019/06/22/KVO%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/KVO4.png" class="" title="KVO截图">


<ul>
<li><p>1、重写class方法是为了我们调用它的时候返回跟重写继承类之前同样的内容。KVO底层交换了 NSKVONotifying_Person 的 class 方法，让其返回 Person。</p>
</li>
<li><p>2、重写setter方法:在新的类中会重写对应的set方法，是为了在set方法中增加另外两个方法的调用。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key</span><br></pre></td></tr></table></figure>
<p>在didChangeValueForKey:方法再调用：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context</span><br></pre></td></tr></table></figure>
</li>
<li><p>3、重写dealloc方法，销毁新生成的NSKVONotifying_类。</p>
</li>
<li><p>4、重写_isKVOA方法，这个私有方法估计可能是用来标示该类是一个 KVO 机制声称的类。</p>
</li>
</ul>
<h3 id="NSSetLongLongValueAndNotify"><a href="#NSSetLongLongValueAndNotify" class="headerlink" title="_NSSetLongLongValueAndNotify"></a>_NSSetLongLongValueAndNotify</h3><p>在添加KVO监听方法以后<code>setAge</code>方法变成了<code>_NSSetLongLongValueAndNotify</code>,所以我们可以大概猜测动态监听方法主要就是在这里面实现的。我们可以在终端使用命令来查看<code>NSSet * ValueAndNotify</code>的类型。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nm -a /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation | grep ValueAndNotify</span><br></pre></td></tr></table></figure>

<img src="/Blog/2019/06/22/KVO%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/KVO6.png" class="" title="KVO截图">

<p>我们可以在<code>Person</code>类中重写<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>,来猜测一下<code>_NSSetLongLongValueAndNotify</code>的内部实现。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="built_in">NSInteger</span>)age&#123;</span><br><span class="line">    _age = age;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;调用set方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key&#123;</span><br><span class="line">    [<span class="keyword">super</span> willChangeValueForKey:key];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;willChangeValueForKey&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;didChangeValueForKey - begin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">super</span> didChangeValueForKey:key];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;didChangeValueForKey - end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台打印的截图:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-24</span> <span class="number">22</span>:<span class="number">48</span>:<span class="number">59.344573</span>+<span class="number">0800</span> KVO[<span class="number">1762</span>:<span class="number">38744</span>] willChangeValueForKey</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-24</span> <span class="number">22</span>:<span class="number">48</span>:<span class="number">59.344766</span>+<span class="number">0800</span> KVO[<span class="number">1762</span>:<span class="number">38744</span>] 调用set方法</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-24</span> <span class="number">22</span>:<span class="number">48</span>:<span class="number">59.344915</span>+<span class="number">0800</span> KVO[<span class="number">1762</span>:<span class="number">38744</span>] didChangeValueForKey - begin</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-24</span> <span class="number">22</span>:<span class="number">48</span>:<span class="number">59.345209</span>+<span class="number">0800</span> KVO[<span class="number">1762</span>:<span class="number">38744</span>] 监听到&lt;Person: <span class="number">0x6000018a4250</span>&gt;的age属性值改变了 - &#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = <span class="number">61</span>;</span><br><span class="line">    old = <span class="number">10</span>;</span><br><span class="line">&#125; - <span class="number">123</span></span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-24</span> <span class="number">22</span>:<span class="number">48</span>:<span class="number">59.345340</span>+<span class="number">0800</span> KVO[<span class="number">1762</span>:<span class="number">38744</span>] didChangeValueForKey - end</span><br></pre></td></tr></table></figure>

<p>根据打印结果我们可以推断<code>_NSSetLongLongValueAndNotify</code>内部实现为:<br>1.调用<code>willChangeValueForKey</code>方法。<br>2.调用<code>setAge</code>方法。<br>3.调用<code>didChangeValueForKey</code>方法。<br>4.在<code>didChangeValueForKey</code>方法内部调用<code>oberser</code>的<br><code>observeValueForKeyPath: ofObject: change: context: </code>方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">void</span> _NSSetIntValueAndNotify() &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">    [<span class="keyword">super</span> setAge:age];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">// 通知监听器，某某属性值发生了改变</span></span><br><span class="line">    [oberser observeValueForKeyPath:key ofObject:<span class="keyword">self</span> change:<span class="literal">nil</span> context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>讲了这些，我们来讨论面试题吧</p>
<p><strong>1、iOS用什么方式实现对一个对象的KVO？(KVO的本质是什么？)</strong></p>
<ul>
<li>1、利用RuntimeAPI动态生成一个子类<code>NSKVONotifying_XXX</code>，并且让instance对象的isa指向这个全新的子类<code>NSKVONotifying_XXX</code>。</li>
<li>2、当修改对象的属性时，会在子类<code>NSKVONotifying_XXX</code>调用Foundation的<code>_NSSetXXXValueAndNotify</code>函数。</li>
<li>3、在<code>_NSSetXXXValueAndNotify</code>函数中依次调用：<pre><code>  - 1、willChangeValueForKey
  - 2、父类原来的setter
  - 3、didChangeValueForKey，didChangeValueForKey:内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）</code></pre>
</li>
</ul>
<p><strong>2、如何手动触发KVO方法</strong><br>手动调用<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>方法。</p>
<p>键值观察通知依赖于 NSObject 的两个方法: <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey</code>。在一个被观察属性发生改变之前， <code>willChangeValueForKey:</code> 一定会被调用，这就会记录旧的值。而当改变发生后， <code>didChangeValueForKey</code> 会被调用，继而<code>observeValueForKey:ofObject:change:context: </code>也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了有人可能会问只调用<code>didChangeValueForKey</code>方法可以触发KVO方法，其实是不能的，因为<code>willChangeValueForKey:</code> 记录旧的值，如果不记录旧的值，那就没有改变一说了。</p>
<p><strong>3、直接修改成员变量会触发KVO吗</strong><br>不会触发KVO，因为<code>KVO的本质就是监听对象有没有调用被监听属性对应的setter方法</code>，直接修改成员变量，是在内存中修改的，不走<code>set</code>方法。</p>
<p><strong>4、不移除KVO监听，会发生什么</strong></p>
<ul>
<li>不移除会造成内存泄漏。</li>
<li>但是多次重复移除会崩溃。系统为了实现KVO，为NSObject添加了一个名为NSKeyValueObserverRegistration的Category，KVO的add和remove的实现都在里面。在移除的时候，系统会判断当前KVO的key是否已经被移除，如果已经被移除，则主动抛出一个NSException的异常。</li>
</ul>
<p><a href="https://github.com/DavidWanderer/iOS_Examples">参考demo</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>KVO本质分析</title>
    <url>/Blog/2019/03/31/KVO%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>iOS中如何实现对一个对象的KVO？(KVO的本质是什么？)<br>答: 当给一个对象添加KVO监听之后，iOS系统会修改这个对象的isa指针，将这个指针指向Runtime动态创建的这个对象的子类。子类拥有自己的set方法的实现，set方法内部会顺序调用willChangeValueForKey方法、父类的set方法、didChangeValueForKey方法，这样会触发observeValueForKeyPath:ofObject:change:context:监听方法。</li>
<li>如何手动触发KVO？<br>答: 被监听的属性值被修改时，就会触发KVO。如果想要手动触发KVO，则需要我们手动同时调用willChangeValueForKey方法和didChangeValueForKey方法，这两个方法缺一不可。</li>
<li>KVO执行的条件？<br>答: 对象添加观察者(addObserver:forKeyPath:)、修改对象被监听的属性、对象在dealloc方法中移除观察者。</li>
</ul>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html#//apple_ref/doc/uid/20002307-BAJEAIEE">官方文档</a>:</p>
<h2 id="Key-Value-Observing-Implementation-Details"><a href="#Key-Value-Observing-Implementation-Details" class="headerlink" title="Key-Value Observing Implementation Details"></a>Key-Value Observing Implementation Details</h2><p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p>
<p>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>
<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>
<p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.<br>大致意思是：KVO使用isa-swizzling技术实现，对象添加观察者之后，isa指针会指向一个临时的类，不能依赖isa的值来判断类的关系，应该使用class方法来判断实例对象真实的类。<br>接下来使用代码来验证KVO的执行过程：<br>Person.h (Person.m中什么也没有)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) int age;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure>
<p>ViewController.m (ViewController.h中什么也没有)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &lt;objc&#x2F;runtime.h&gt;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong) Person *p1;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    &#x2F;&#x2F; 移除观察者</span><br><span class="line">    [self.p1 removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    </span><br><span class="line">    Person *p1 &#x3D; [[Person alloc] init];</span><br><span class="line">    [self printMethods:object_getClass(p1)];</span><br><span class="line">    self.p1 &#x3D; p1;</span><br><span class="line">    &#x2F;&#x2F; 打印p1对象所属类的内部方法列表</span><br><span class="line">    NSLog(@&quot;p1 class &#x3D; %@&quot;, [p1 class]);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 添加观察者</span><br><span class="line">    [p1 addObserver:self forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 打印p1对象所属类的内部方法列表</span><br><span class="line">    [self printMethods:object_getClass(p1)];</span><br><span class="line">    NSLog(@&quot;p1 class &#x3D; %@&quot;, [p1 class]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** 打印类中所有的方法  *&#x2F;</span><br><span class="line">- (void) printMethods:(Class)cls</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int count ;</span><br><span class="line">    Method *methods &#x3D; class_copyMethodList(cls, &amp;count);</span><br><span class="line">    NSMutableString *methodNames &#x3D; [NSMutableString string];</span><br><span class="line">    [methodNames appendFormat:@&quot;%@ - &quot;, cls];</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0 ; i &lt; count; i++) &#123;</span><br><span class="line">        Method method &#x3D; methods[i];</span><br><span class="line">        NSString *methodName  &#x3D; NSStringFromSelector(method_getName(method));</span><br><span class="line">        </span><br><span class="line">        [methodNames appendString: methodName];</span><br><span class="line">        [methodNames appendString:@&quot; &quot;];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;,methodNames);</span><br><span class="line">    free(methods);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    NSLog(@&quot;执行了监听方法:%@&quot;, change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-03-31 19:06:48.896565+0800 KVO测试Demo[29498:3594134] Person - setAge: age</span><br><span class="line">2019-03-31 19:06:48.897033+0800 KVO测试Demo[29498:3594134] p1 class &#x3D; Person</span><br><span class="line">2019-03-31 19:06:48.897503+0800 KVO测试Demo[29498:3594134] NSKVONotifying_Person - setAge: class dealloc _isKVOA</span><br><span class="line">2019-03-31 19:06:48.897638+0800 KVO测试Demo[29498:3594134] p1 class &#x3D; Person</span><br></pre></td></tr></table></figure>
<p>由此可见，对象p1添加观察者之后，p1的所属类由原来的Person类变成了NSKVONotifying_Person类，原来的Person类内部只实现了setAge:方法和age方法，新类NSKVONotifying_Person中有setAge:、class、dealloc、_isKVOA方法。经过分析判断，NSKVONotifying_Person是Person的子类，它重写了父类的setAge:和class方法，使NSKVONotifying_Person的class方法的返回值也是Person,隐藏了内部的实现。</p>
<h2 id="如何手动触发KVO？"><a href="#如何手动触发KVO？" class="headerlink" title="如何手动触发KVO？"></a>如何手动触发KVO？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    </span><br><span class="line">    Person *p1 &#x3D; [[Person alloc] init];</span><br><span class="line">    [self printMethods:object_getClass(p1)];</span><br><span class="line">    self.p1 &#x3D; p1;</span><br><span class="line">    &#x2F;&#x2F; 打印p1对象所属类的内部方法列表</span><br><span class="line">    NSLog(@&quot;p1 class &#x3D; %@&quot;, [p1 class]);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 添加观察者</span><br><span class="line">    [p1 addObserver:self forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 打印p1对象所属类的内部方法列表</span><br><span class="line">    [self printMethods:object_getClass(p1)];</span><br><span class="line">    NSLog(@&quot;p1 class &#x3D; %@&quot;, [p1 class]);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 手动触发KVO</span><br><span class="line">    [p1 willChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">    [p1 didChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-03-31 19:37:41.217175+0800 KVO测试Demo[29990:3611620] Person - setAge: age</span><br><span class="line">2019-03-31 19:37:41.217409+0800 KVO测试Demo[29990:3611620] p1 class &#x3D; Person</span><br><span class="line">2019-03-31 19:37:41.217999+0800 KVO测试Demo[29990:3611620] NSKVONotifying_Person - setAge: class dealloc _isKVOA</span><br><span class="line">2019-03-31 19:37:41.218145+0800 KVO测试Demo[29990:3611620] p1 class &#x3D; Person</span><br><span class="line">2019-03-31 19:37:41.218488+0800 KVO测试Demo[29990:3611620] 执行了监听方法:&#123;</span><br><span class="line">    kind &#x3D; 1;</span><br><span class="line">    new &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何关闭自动KVO？<br>Person.m</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key &#123;</span><br><span class="line">    if ([key isEqualToString:@&quot;age&quot;]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>当返回值为NO的时候，即使改变p1的值也无法触发KVO，此时要想触发KVO只有手动模式，手动调用willChangeValueForKey和didChangeValueForKey。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>LLDB使用</title>
    <url>/Blog/2020/06/30/LLDB%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h2><p>LLDB 是一个有着 REPL 的特性和 C++ ,Python 插件的开源调试器。LLDB 绑定在 Xcode 内部，存在于主窗口底部的控制台中。调试器允许你在程序运行的特定时暂停它，你可以查看变量的值，执行自定的指令，并且按照你所认为合适的步骤来操作程序的进展。</p>
<h3 id="expression"><a href="#expression" class="headerlink" title="expression"></a>expression</h3><p>可简写为e，作用为执行一个表达式。</p>
<ul>
<li>1、查询当前堆栈变量的值</li>
<li>2、动态修改当前线程堆栈变量的值</li>
</ul>
<img src="/Blog/2020/06/30/LLDB%E4%BD%BF%E7%94%A8/LLDB1.png" class="" title="LLDB">

<p>我们在调试数据的时候，有的时候需要动态修改变量值，使用<code>expression</code>那是十分方便的调试。</p>
<h4 id="po-amp-p"><a href="#po-amp-p" class="headerlink" title="po &amp; p"></a><code>po</code> &amp; <code>p</code></h4><p><code>po</code>的作用为打印对象，事实上，我们可以通过<code>help po</code>得知，<code>po</code>是<code>expression -O --</code>的简写，我们可以通过它打印出对象，而不是打印对象的指针。而值得一提的是，在 <code>help expression</code> 返回的帮助信息中，我们可以知道，<code>po</code>命令会尝试调用对象的 <code>description</code> 方法来取得对象信息，因此我们也可以重载某个对象的<code>description方法</code>，使我们调试的时候能获得可读性更强，更全面的信息。</p>
<img src="/Blog/2020/06/30/LLDB%E4%BD%BF%E7%94%A8/LLDB2.png" class="" title="LLDB">

<p><code>p</code>即是<code>print</code>，也是<code>expression --</code>的缩写，与<code>po</code>不同，它不会打出对象的详细信息，只会打印出一个$符号，数字，再加上一段地址信息。打印对象的时候我们也可以指定特定格式。</p>
<ul>
<li><code>x</code> ：十六进制打印</li>
<li><code>d</code>:十进制打印</li>
<li><code>u</code>:无符号十进制打印</li>
<li><code>o</code>:八进制打印</li>
<li><code>t</code>:二进制形式打印</li>
<li><code>f</code>:浮点数</li>
</ul>
<img src="/Blog/2020/06/30/LLDB%E4%BD%BF%E7%94%A8/LLDB3.png" class="" title="LLDB">


<h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p><code>bt</code>即是<code>thread backtrace</code>，作用是打印出当前线程的堆栈信息。</p>
<img src="/Blog/2020/06/30/LLDB%E4%BD%BF%E7%94%A8/LLDB4.png" class="" title="LLDB">

<p>我们在打印断点的时候，我们可以在左侧看到一些堆栈信息，但是看不完全，这个时候使用<code>bt</code>指令可以打印出完整的堆栈信息。</p>
<p>输入<code>frame select</code>指令我们可以任意的去选择一个作用域去查看。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">(lldb)frame select <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><code>thread</code>另一个比较常用的用法是 <code>thread return</code>，调试的时候，我们希望在当前执行的程序堆栈直接返回一个自己想要的值，可以执行该命令直接返回。<br><code>thread return &lt;expr&gt;</code><br>在这个断点中，我们可以执行 <code>thread return NO</code>让该函数调用直接返回<code>NO </code>，在调试中轻松覆盖任何函数的返回路径。</p>
<img src="/Blog/2020/06/30/LLDB%E4%BD%BF%E7%94%A8/LLDB5.png" class="" title="LLDB">

<p><code>frame</code>即是帧，其实就是当前的程序堆栈，我们输入<code>bt</code>命令，打印出来的其实是当前线程的<code>frame</code>。</p>
<ul>
<li>展示当前作用域下的参数和局部变量<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">(lldb)frame variable</span><br><span class="line">(lldb)fr v</span><br><span class="line">frame variable --no-summary-depth</span><br></pre></td></tr></table></figure></li>
<li>展示当前作用域下的局部变量<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">(lldb)frame variable --no-args</span><br><span class="line">(lldb)fr v -a</span><br></pre></td></tr></table></figure></li>
<li>展示指定变量var的具体内容<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">(lldb)frame variable var</span><br><span class="line">(lldb)fr v var</span><br><span class="line">(lldb)p var</span><br><span class="line">(lldb)po var</span><br></pre></td></tr></table></figure></li>
<li>展示当前对象的全局变量<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">(lldb)target variable</span><br><span class="line">(lldb)ta v</span><br></pre></td></tr></table></figure></li>
<li>打印某一方法具体的信息<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">frame select num（<span class="number">1</span>，<span class="number">2</span>，<span class="number">3.</span>）</span><br></pre></td></tr></table></figure>
<img src="/Blog/2020/06/30/LLDB%E4%BD%BF%E7%94%A8/LLDB7.png" class="" title="LLDB">

</li>
</ul>
<h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><h4 id="breakpoint"><a href="#breakpoint" class="headerlink" title="breakpoint"></a>breakpoint</h4><p>所有调试都是由断点开始的，我们接触的最多，就是以breakpoint命令为基础的断点。<br>一般我们对breakpoint命令使用得不多，而是在XCode的GUI界面中直接添加断点。除了直接触发程序暂停供调试外，我们可以进行进一步的配置。</p>
<img src="/Blog/2020/06/30/LLDB%E4%BD%BF%E7%94%A8/LLDB8.png" class="" title="LLDB">

<ul>
<li>添加condition，一般用于多次调用的函数或者循坏的代码中，在作用域内达到某个条件，才会触发程序暂停</li>
<li>忽略次数，这个很容易理解，在忽略触发几次后再触发暂停</li>
<li>添加Action，为这个断点添加子命令、脚本、shell命令、声效（有个毛线用）等Action，我的理解是一个脚本化的功能，我们可以在断点的基础上添加一些方便调试的脚本，提高调试效率。</li>
<li>自动继续，配合上面的添加Action，我们就可以不用一次又一次的暂停程序进行调试来查询某些值（大型程序中断一次还是会有卡顿），直接用Action将需要的信息打印在控制台，一次性查看即可。</li>
</ul>
<h4 id="watchpoint"><a href="#watchpoint" class="headerlink" title="watchpoint"></a>watchpoint</h4><p>有时候我们会关心类的某个属性什么时候被人修改了，最简单的方法当然就是在setter的方法打断点，或者在<code>@property</code>的属性生命行打上断点。这样当对象的setter方法被调用时，就会触发这个断点<br>当然这么做是有缺点的，对于直接访问内存地址的修改，setter方法的断点并没有办法监控得到，因此我们需要用到<code>watchpoint</code>命令。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">watchpoint set variable str</span><br><span class="line">watchpoint list <span class="comment">//列出所有watchpoint</span></span><br><span class="line">watchpoint delete <span class="comment">// 删除所有watchpoint</span></span><br></pre></td></tr></table></figure>



<h2 id="Chisel"><a href="#Chisel" class="headerlink" title="Chisel"></a>Chisel</h2><p><a href="https://github.com/facebook/chisel">Chisel</a>是facebook开源的一个LLDB命令的集合，它里面简化和扩展了LLDB的命令。使用它会更方便的调试我们的程序。在它的GitHub上有详细的安装方式，这里就不赘述了。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong>1. pviews</strong></p>
<p>这个命令可以按层级递归打印指定view的所有subView，相当于 UIView 的私有辅助方法 [view recursiveDescription]。如果不指定view的话就是默认window：</p>
<img src="/Blog/2020/06/30/LLDB%E4%BD%BF%E7%94%A8/LLDB9.png" class="" title="LLDB">

<img src="/Blog/2020/06/30/LLDB%E4%BD%BF%E7%94%A8/LLDB10.png" class="" title="LLDB">


<p><strong>2. pvc</strong></p>
<p>这个命令递归打印出viewController的层级，相当于 UIViewController 的一个私有辅助方法 [UIViewController _printHierarchy] ：</p>
<img src="/Blog/2020/06/30/LLDB%E4%BD%BF%E7%94%A8/LLDB11.png" class="" title="LLDB">

<p><strong>3. visualize</strong></p>
<p>它可以使用Mac的预览打开一个 UIImage, CGImageRef, UIView, 或 CALayer。 我们其实可以用这个功能来截图或者查看一个view的具体内容：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">(lldb) visualize <span class="number">0x7feb5cf18210</span></span><br><span class="line">(lldb) visualize <span class="keyword">self</span>.view</span><br></pre></td></tr></table></figure>


<p><strong>4. mask/unmask</strong></p>
<p>mask用来在view或者layer上覆盖一个半透明的矩形， unmask解除。当我们想找一个view的时候可以使用。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">(lldb) mask <span class="keyword">self</span>.imageView</span><br><span class="line">(lldb) unmask <span class="number">0x7f8732e037b0</span></span><br></pre></td></tr></table></figure>
<img src="/Blog/2020/06/30/LLDB%E4%BD%BF%E7%94%A8/LLDB12.png" class="" title="LLDB">

<p><strong>5. border/unborder</strong></p>
<p>border可以给view或者layer添加边框，unborder解除。当我们想找一个view的时候可以使用。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">(lldb) border <span class="keyword">self</span>.imageView</span><br><span class="line">(lldb) unborder <span class="number">0x7f8732e037b0</span></span><br></pre></td></tr></table></figure>

<p><strong>6. show/hide</strong></p>
<p>显示隐藏一个view或者layer。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">(lldb) hide <span class="keyword">self</span>.imageView</span><br><span class="line">(lldb) show <span class="keyword">self</span>.imageView</span><br></pre></td></tr></table></figure>
<p><strong>7. caflush</strong></p>
<p>这个命令用来刷新UI，当我们改变了UI的时候，不用重新启动，使用caflush刷新UI就行。</p>
<p><strong>8. presponder</strong></p>
<p>打印响应者链：</p>
<img src="/Blog/2020/06/30/LLDB%E4%BD%BF%E7%94%A8/LLDB13.png" class="" title="LLDB">


<p><strong>9. pclass</strong></p>
<p>打印指定对象的class的继承关系：</p>
<img src="/Blog/2020/06/30/LLDB%E4%BD%BF%E7%94%A8/LLDB14.png" class="" title="LLDB">

<p><strong>10. pjson</strong></p>
<p>打印一个字典或者数组的json样式。</p>
<img src="/Blog/2020/06/30/LLDB%E4%BD%BF%E7%94%A8/LLDB15.png" class="" title="LLDB">


<p><strong>11. slowanim/unslowanim</strong></p>
<p>减慢动画的效果，检查一个动画哪里有问题时可以使用。</p>
<p><strong>12. pdocspath</strong></p>
<p>打印App的Documents路径：</p>
<img src="/Blog/2020/06/30/LLDB%E4%BD%BF%E7%94%A8/LLDB16.png" class="" title="LLDB">

<p><strong>13. fv &amp; fvc</strong></p>
<p>这两个命令是用来搜索当前内存中存在的view和viewController实例的命令，支持正则搜索。</p>
<img src="/Blog/2020/06/30/LLDB%E4%BD%BF%E7%94%A8/LLDB17.png" class="" title="LLDB">

<p><strong>14. vs</strong><br>这个命令可以移动正在调试的对象，让对象切换到其父视图之前，或切换到其兄弟视图之前。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">(lldb) vs <span class="number">0x128430c50</span></span><br><span class="line"></span><br><span class="line">Use the following and (q) to quit.</span><br><span class="line">(w) move to superview</span><br><span class="line">(s) move to first subview</span><br><span class="line">(a) move to previous sibling</span><br><span class="line">(d) move to next sibling</span><br><span class="line">(p) print the hierarchy</span><br></pre></td></tr></table></figure>

<h2 id="Chisel安装步骤"><a href="#Chisel安装步骤" class="headerlink" title="Chisel安装步骤"></a>Chisel安装步骤</h2><p>官网地址：<a href="https://github.com/facebook/chisel">https://github.com/facebook/chisel</a> ，官网推荐使用<code>Homebrew</code>安装，但是实际测试下来发现<code>Homebrew</code>安装的版本有问题，所以这里推荐使用<code>git clone</code>最新的版本，然后配置路径使用。</p>
<h3 id="下载仓库最新的代码"><a href="#下载仓库最新的代码" class="headerlink" title="下载仓库最新的代码"></a>下载仓库最新的代码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/facebook/chisel.git</span><br></pre></td></tr></table></figure>

<h3 id="配置～-lldbinit文件"><a href="#配置～-lldbinit文件" class="headerlink" title="配置～/.lldbinit文件"></a>配置<code>～/.lldbinit</code>文件</h3><p>查找<code>～/.lldbinit</code>文件是否存在，如果不存在，创建一个。如果存在，就修改这个文件。下面创建一个这样的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ touch .lldbinit</span><br><span class="line">$ open .lldbinit</span><br></pre></td></tr></table></figure>

<p>打开<code>.lldbinit</code>文件后，在这个文件中配置第1步中克隆下来的代码里<code>fbchisellldb.py</code>文件的路径，我这里提供我自己的<code>.lldbinit</code>文件的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ~/.lldbinit</span></span><br><span class="line"><span class="built_in">command</span> script import /Users/kris/Documents/git/chisel/fbchisellldb.py</span><br></pre></td></tr></table></figure>

<h3 id="配置完这些操作后，重新启动Xcode，打个断点，使用新的LLDB命令试下"><a href="#配置完这些操作后，重新启动Xcode，打个断点，使用新的LLDB命令试下" class="headerlink" title="配置完这些操作后，重新启动Xcode，打个断点，使用新的LLDB命令试下"></a>配置完这些操作后，重新启动Xcode，打个断点，使用新的LLDB命令试下</h3><img src="/Blog/2020/06/30/LLDB%E4%BD%BF%E7%94%A8/LLDB19.png" class="" title="LLDB">



<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/d6a0a5e39b0e">iOS调试-LLDB学习总结</a></p>
<p><a href="https://www.jianshu.com/p/67f08a4d8cf2">iOS开发调试 - LLDB使用概览</a></p>
<p><a href="https://blog.csdn.net/u011374318/article/details/79648178">LLDB 常用命令</a></p>
<p><a href="https://github.com/facebook/chisel/wiki">chisel命令列表</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下安装FTP</title>
    <url>/Blog/2019/08/24/Linux%E4%B8%8B%E5%AE%89%E8%A3%85FTP/</url>
    <content><![CDATA[<h2 id="1-什么是vsftpd"><a href="#1-什么是vsftpd" class="headerlink" title="1.什么是vsftpd"></a>1.什么是vsftpd</h2><p>vsftpd是一款在Linux发行版中最受推崇的FTP服务器程序。特点是小巧轻快，安全易用。<br>vsftpd 的名字代表”very secure FTP daemon”, 安全是它的开发者 Chris Evans 考虑的首要问题之一。在这个 FTP 服务器设计开发的最开始的时候，高安全性就是一个目标。</p>
<h2 id="2-查看当前服务器是否安装过"><a href="#2-查看当前服务器是否安装过" class="headerlink" title="2.查看当前服务器是否安装过"></a>2.查看当前服务器是否安装过</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rpm -qa|grep vsftp</span><br></pre></td></tr></table></figure>
<p>如果显示版本号，说明安装成功，如果没有安装文件，什么都不显示，说明没有安装或者其他情况。也可以通过which vsftp检查是否有ftp的安装文件。</p>
<h2 id="3-安装FTP"><a href="#3-安装FTP" class="headerlink" title="3.安装FTP"></a>3.安装FTP</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum -y install vsftpd</span><br></pre></td></tr></table></figure>
<p>安装完后，有/etc/vsftpd/vsftpd.conf 文件，是vsftp的配置文件。还新建了一个ftp用户和ftp的组，指向home目录为/var/ftp,默认是nologin（不能登录系统）。可以用cat /etc/passwd 命令查看用户。</p>
<h2 id="4-启动ftp，执行命令"><a href="#4-启动ftp，执行命令" class="headerlink" title="4.启动ftp，执行命令"></a>4.启动ftp，执行命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ service vsftpd start</span><br></pre></td></tr></table></figure>


<h2 id="5-查看ftp的状态"><a href="#5-查看ftp的状态" class="headerlink" title="5.查看ftp的状态"></a>5.查看ftp的状态</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ service vsftpd status</span><br></pre></td></tr></table></figure>


<h2 id="6-安装ftp客户端组件（用来验证登录vsftpd）"><a href="#6-安装ftp客户端组件（用来验证登录vsftpd）" class="headerlink" title="6.安装ftp客户端组件（用来验证登录vsftpd）"></a>6.安装ftp客户端组件（用来验证登录vsftpd）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum -y install ftp</span></span><br></pre></td></tr></table></figure>
<p>执行命令尝试登录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ftp localhost</span></span><br></pre></td></tr></table></figure>
<p>输入用户名ftp，密码随便（因为默认是允许匿名的）<br>登录成功，就代表ftp服务可用了。<br>但是，外网是访问不了的，所以还要继续配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ftp localhost</span></span><br><span class="line">Trying ::1...</span><br><span class="line">ftp: connect to address ::1拒绝连接</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to localhost (127.0.0.1).</span><br><span class="line">220 (vsFTPd 2.2.2)</span><br><span class="line">Name (localhost:root): ftp</span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password:</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system <span class="built_in">type</span> is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt; ls</span><br><span class="line">227 Entering Passive Mode (127,0,0,1,177,184).</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">drwxr-xr-x    2 0        0            4096 Mar 22  2017 pub</span><br><span class="line">226 Directory send OK.</span><br><span class="line">ftp&gt; </span><br></pre></td></tr></table></figure>


<h2 id="7-添加一个ftp用户"><a href="#7-添加一个ftp用户" class="headerlink" title="7.添加一个ftp用户"></a>7.添加一个ftp用户</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># useradd ftpuser</span></span><br></pre></td></tr></table></figure>
<p>此用户就是用来登录ftp服务器用的。<br>这样一个用户建完，可以用这个登录，记得用普通登录不要用匿名了。登录后默认的路径为 /home/ftpuser.</p>
<h2 id="8-给ftp用户添加密码"><a href="#8-给ftp用户添加密码" class="headerlink" title="8.给ftp用户添加密码"></a>8.给ftp用户添加密码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># passwd ftpuser</span></span><br></pre></td></tr></table></figure>
<p>输入两次密码后修改密码。</p>
<h2 id="9-关闭匿名登录"><a href="#9-关闭匿名登录" class="headerlink" title="9.关闭匿名登录"></a>9.关闭匿名登录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/vsftpd/vsftpd.conf</span></span><br></pre></td></tr></table></figure>
<p>设置anonymous_enable=NO。</p>
<h2 id="10-重启ftp服务"><a href="#10-重启ftp服务" class="headerlink" title="10.重启ftp服务"></a>10.重启ftp服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># service vsftpd restart</span></span><br></pre></td></tr></table></figure>


<h2 id="11-开启passive模式"><a href="#11-开启passive模式" class="headerlink" title="11.开启passive模式"></a>11.开启passive模式</h2><p>默认是开启的，但是要指定一个端口范围，打开vsftpd.conf文件，在后面加上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pasv_min_port=30000   </span><br><span class="line">pasv_max_port=30999  </span><br></pre></td></tr></table></figure>
<p>表示端口范围为30000~30999，这个可以随意改。改完重启一下vsftpd。</p>
<h2 id="12-修改ftp默认的端口号"><a href="#12-修改ftp默认的端口号" class="headerlink" title="12.修改ftp默认的端口号"></a>12.修改ftp默认的端口号</h2><p>常规下21端口容易遭到别人的扫描、带来了一定程度的不安全。所以，最好的就是把21端口修改掉。默认修改为6069。</p>
<h2 id="12-1-修改vsftp的配置文件"><a href="#12-1-修改vsftp的配置文件" class="headerlink" title="12.1 修改vsftp的配置文件"></a>12.1 修改vsftp的配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /etc/vsftpd/vsftpd.conf</span><br></pre></td></tr></table></figure>
<p>在原来的基础上加上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen_port=6069</span><br><span class="line"></span><br><span class="line">pasv_enable=YES</span><br><span class="line"></span><br><span class="line">pasv_min_port=30000</span><br><span class="line"></span><br><span class="line">pasv_max_port=30999</span><br><span class="line"></span><br><span class="line">pasv_promiscuous=YES</span><br><span class="line"></span><br><span class="line">ftpd_banner=Welcome to Wander FTP service</span><br></pre></td></tr></table></figure>


<h2 id="12-2-修改-etc-services"><a href="#12-2-修改-etc-services" class="headerlink" title="12.2 修改/etc/services"></a>12.2 修改/etc/services</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /etc/services</span><br></pre></td></tr></table></figure>
<p>修改成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ftp             6069/tcp</span><br><span class="line">ftp             6069/udp</span><br></pre></td></tr></table></figure>


<h2 id="12-3-修改防火墙规则"><a href="#12-3-修改防火墙规则" class="headerlink" title="12.3 修改防火墙规则"></a>12.3 修改防火墙规则</h2><p>如果防火墙开启、并且做了端口限制、请添加相应的规则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /etc/sysconfig/iptables</span><br><span class="line"></span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 30000:30999 -j ACCEPT</span><br><span class="line">-A INPUT -p udp -m state --state NEW -m udp --dport 6069 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 6069 -j ACCEPT</span><br></pre></td></tr></table></figure>


<h2 id="12-4-重启服务"><a href="#12-4-重启服务" class="headerlink" title="12.4 重启服务"></a>12.4 重启服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># service iptables restart</span></span><br><span class="line"><span class="comment"># service vsftpd restart</span></span><br></pre></td></tr></table></figure>
<p>然后就可以通过客户端6069端口连接ftp（选择被动模式连接）。</p>
<h2 id="13-配置-vsftpd-使用-SSL-TLS"><a href="#13-配置-vsftpd-使用-SSL-TLS" class="headerlink" title="13.配置 vsftpd 使用 SSL / TLS"></a>13.配置 vsftpd 使用 SSL / TLS</h2><h2 id="13-1-检查-vsftpd-是否支持-ssl-模块"><a href="#13-1-检查-vsftpd-是否支持-ssl-模块" class="headerlink" title="13.1 检查 vsftpd 是否支持 ssl 模块"></a>13.1 检查 vsftpd 是否支持 ssl 模块</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ldd $(which vsftpd) | grep ssl</span></span><br></pre></td></tr></table></figure>


<h2 id="13-2-建立专门给vsftpd使用的凭证数据。CentOS有一个建立凭证的地方-etc-pki-tls-certs-。"><a href="#13-2-建立专门给vsftpd使用的凭证数据。CentOS有一个建立凭证的地方-etc-pki-tls-certs-。" class="headerlink" title="13.2 建立专门给vsftpd使用的凭证数据。CentOS有一个建立凭证的地方/etc/pki/tls/certs/。"></a>13.2 建立专门给vsftpd使用的凭证数据。CentOS有一个建立凭证的地方/etc/pki/tls/certs/。</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd /etc/pki/tls/certs</span></span><br></pre></td></tr></table></figure>
<p>生成密钥文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make vsftpd.pem</span></span><br></pre></td></tr></table></figure>
<p>复制证书到vsftpd目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cp -a vsftpd.pem /etc/vsftpd/</span></span><br><span class="line"><span class="comment"># ll /etc/vsftpd/vsftpd.pem</span></span><br></pre></td></tr></table></figure>

<p>证书配置解析：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Country Name (2 letter code) [XX]:CN                            国家名称(2个字母代码)[XX]:CN</span><br><span class="line">State or Province Name (full name) []:CHINA                     国家或省名(全称)[]:中国</span><br><span class="line">Locality Name (eg, city) [Default City]:CHINA                   地名(如城市)[默认城市]:中国</span><br><span class="line">Organization Name (eg, company) [Default Company Ltd]:ORG       组织名称(如公司)[默认公司有限公司]:ORG</span><br><span class="line">Organizational Unit Name (eg, section) []:ORG                   组织单元名称(例如，节)[]:ORG</span><br><span class="line">Common Name (eg, your name or your server<span class="string">&#x27;s hostname) []:NAME   常用名称(例如，您的名称或服务器的主机名)[]:Name</span></span><br><span class="line"><span class="string">Email Address []:EMAIL@163.com                                  电子邮件地址[]:EMAIL@163.com</span></span><br></pre></td></tr></table></figure>


<h2 id="13-3-修改-vsftpd-conf-配置文件"><a href="#13-3-修改-vsftpd-conf-配置文件" class="headerlink" title="13.3 修改 vsftpd.conf 配置文件"></a>13.3 修改 vsftpd.conf 配置文件</h2><p>停止服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># service vsftpd stop</span></span><br></pre></td></tr></table></figure>
<p>在最后加上以下配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssl_enable=YES</span><br><span class="line">allow_anon_ssl=YES</span><br><span class="line">force_anon_data_ssl=YES</span><br><span class="line">force_anon_logins_ssl=YES</span><br><span class="line">force_local_data_ssl=YES</span><br><span class="line">force_local_logins_ssl=YES</span><br><span class="line">ssl_tlsv1=YES</span><br><span class="line">rsa_cert_file=/etc/vsftpd/vsftpd.pem</span><br></pre></td></tr></table></figure>

<p>配置解析：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">###SSL#####</span></span><br><span class="line"><span class="comment"># 是否启用SSL，默认值：NO</span></span><br><span class="line">ssl_enable=YES</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 仅适用于 ssl_enable 活动。如果设置为YES，匿名用户将被允许使用安全的SSL连接</span></span><br><span class="line">默认值：NO</span><br><span class="line">allow_anon_ssl=YES</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 仅适用于 ssl_enable 激活。如果激活，所有匿名登录将被强制使用安全的SSL连接，以便在数据连接上发送和接收数据。默认值：NO</span></span><br><span class="line">force_anon_data_ssl=YES</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 仅适用于 ssl_enable 激活。如果激活，所有匿名登录将被强制使用安全的SSL连接以发送密码。默认值：NO</span></span><br><span class="line">force_anon_logins_ssl=YES</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 仅适用于 ssl_enable 激活。如果激活，所有非匿名登录将被强制使用安全的SSL连接，以便在数据连接上发送和接收数据。默认值：YES</span></span><br><span class="line">force_local_data_ssl=YES</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 仅适用于 ssl_enable 激活。如果激活，所有非匿名登录将被强制使用安全的SSL连接以发送密码。默认值：YES</span></span><br><span class="line">force_local_logins_ssl=YES</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 仅适用于 ssl_enable 激活。如果启用，此选项将允许TLS v1协议连接。TLS v1连接是首选。默认值：YES</span></span><br><span class="line">ssl_tlsv1=YES</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 仅适用于 ssl_enable 激活。如果启用，此选项将允许SSL v2协议连接。TLS v1连接是首选。默认值：NO</span></span><br><span class="line"><span class="comment">#ssl_sslv2=NO</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 仅适用于 ssl_enable 激活。如果启用，此选项将允许SSL v3协议连接。TLS v1连接是首选。默认值：NO</span></span><br><span class="line"><span class="comment">#ssl_sslv3=NO</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 选项指定用于SSL加密连接的RSA证书的位置。默认值：/usr/share/ssl/certs/vsftpd.pem</span></span><br><span class="line">rsa_cert_file=/etc/vsftpd/vsftpd.pem</span><br></pre></td></tr></table></figure>


<h2 id="13-4-最后保存，重启服务就OK了"><a href="#13-4-最后保存，重启服务就OK了" class="headerlink" title="13.4 最后保存，重启服务就OK了"></a>13.4 最后保存，重启服务就OK了</h2><p>启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service vsftpd start</span><br></pre></td></tr></table></figure>
<p>重启服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service vsftpd restart</span><br></pre></td></tr></table></figure>


<h2 id="13-5-连接-Vsftpd"><a href="#13-5-连接-Vsftpd" class="headerlink" title="13.5 连接 Vsftpd"></a>13.5 连接 Vsftpd</h2><p>在连接的时候勾选信任证书就行。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h2><p><a href="https://blog.csdn.net/csdn_lqr/article/details/53333946">Linux安装ftp组件(8步完成)</a><br><a href="https://blog.csdn.net/lizexing1/article/details/79308961">小白教程：linux下安装FTP的过程和使用的整体过程</a><br><a href="https://www.cnblogs.com/chenmh/p/5365274.html">Linux 搭建FTP服务器</a><br><a href="https://www.kancloud.cn/chandler/bc-linux/52710">centos启用ftp功能</a><br><a href="https://blog.csdn.net/caihuashen/article/details/80306131">修改ftp默认端口</a><br><a href="https://blog.51cto.com/13481789/2366720">”不安全的服务器，不支持 FTP over TLS“ 配置 vsftpd 使用 SSL / TLS</a></p>
]]></content>
      <categories>
        <category>FTP</category>
      </categories>
      <tags>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Load和initialize加载顺序</title>
    <url>/Blog/2019/06/27/Load%E5%92%8Cinitialize%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="Load和Initialize实现原理"><a href="#Load和Initialize实现原理" class="headerlink" title="Load和Initialize实现原理"></a>Load和Initialize实现原理</h2><h3 id="Load实现原理"><a href="#Load实现原理" class="headerlink" title="+Load实现原理"></a>+Load实现原理</h3><blockquote>
<p>+load方法会在<code>runtime</code>加载<code>类</code>、<code>分类</code>时调用</p>
</blockquote>
<blockquote>
<p>每个类、分类的+load，在程序运行过程中<code>只调用一次</code></p>
</blockquote>
<blockquote>
<p>+load方法是根据方法<code>地址</code>直接调用，并不是经过objc_msgSend函数调用</p>
</blockquote>
<p><strong>调用顺序</strong></p>
<ul>
<li>1、先调用类的+load<ul>
<li>按照编译先后顺序调用（先编译，先调用）</li>
<li>调用子类的+load之前会先调用父类的+load</li>
</ul>
</li>
<li>2、再调用分类的+load<ul>
<li>按照编译先后顺序调用（先编译，先调用）</li>
</ul>
</li>
</ul>
<p><strong>objc4源码解读过程</strong><br>objc-os.mm 文件</p>
<ul>
<li>_objc_init</li>
<li>load_images</li>
<li>prepare_load_methods<ul>
<li>schedule_class_load</li>
<li>add_class_to_loadable_list</li>
<li>add_category_to_loadable_list</li>
</ul>
</li>
<li>call_load_methods<ul>
<li>call_class_loads</li>
<li>call_category_loads</li>
</ul>
</li>
</ul>
<p><code>_objc_init</code>方法是RunTime运行的入口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小知识：<code>images</code>是镜像的意思</p>
</blockquote>
<p>我们在<code>_objc_init</code>方法中找到<code>load_images</code>，<code>load_images</code>是Load加载镜像的意思，所有我们可以猜测这个里面应该有我们load的加载方法的相关实现</p>
<p>我们点击进入<code>load_images</code>方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">recursive_mutex_locker_t</span> <span class="title">lock</span><span class="params">(loadMethodLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">rwlock_writer_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面有两个需要我们注意的</p>
<ul>
<li>1、<code>prepare_load_methods((const headerType *)mh)</code>准备加载Load方法，我们也可以看到上面的官方文档解释也是这个意思</li>
<li>2、<code>call_load_methods()</code> 加载load方法</li>
</ul>
<p>我们点击进入<code>prepare_load_methods((const headerType *)mh)</code>准备加载Load方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">classref_t</span> *classlist = </span><br><span class="line">    _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">category_t</span> **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">    Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到执行顺序</p>
<ul>
<li>1、<code>schedule_class_load(remapClass(classlist[i]));</code>,这个是把类中的<code>Load</code>方法添加到数组中</li>
<li>2、<code>add_category_to_loadable_list(cat);</code>这个是把分类中的<code>load</code>方法添加到数组中</li>
</ul>
<p><strong>查看类的load方法</strong></p>
<p>我们查看<code>schedule_class_load(remapClass(classlist[i]));</code>方法里面还有哪些实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1、<code>schedule_class_load(cls-&gt;superclass);</code> 把父类load先添加到数组中</li>
<li>2、<code>add_class_to_loadable_list(cls);</code>把自己的load方法添加到数组中</li>
</ul>
<p>走到这里我们大概是清楚了类中load方法的加载添加过程，就是先把<code>父类添加到数组中，然后再把自己添加到数组中</code></p>
<p><strong>查看分类的load方法</strong></p>
<p>我们点击<code>add_category_to_loadable_list(cat)</code>进入查看方法实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_category_to_loadable_list</span><span class="params">(Category cat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = _category_getLoadMethod(cat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t bother if cat has no +load method</span></span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;LOAD: category &#x27;%s(%s)&#x27; scheduled for +load&quot;</span>, </span><br><span class="line">        _category_getClassName(cat), _category_getName(cat));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loadable_categories_used == loadable_categories_allocated) &#123;</span><br><span class="line">        loadable_categories_allocated = loadable_categories_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_categories = (struct loadable_category *)</span><br><span class="line">        <span class="built_in">realloc</span>(loadable_categories,</span><br><span class="line">        loadable_categories_allocated *</span><br><span class="line">        <span class="keyword">sizeof</span>(struct loadable_category));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadable_categories[loadable_categories_used].cat = cat;</span><br><span class="line">    loadable_categories[loadable_categories_used].method = method;</span><br><span class="line">    loadable_categories_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>loadable_categories_used++;</code>分类没有什么特殊的方法，应该就是按照编译顺序添加到数组的。</p>
<p><strong>实现</strong></p>
<p>我们刚才看到了类分类中的添加顺序，我们在来看看加载顺序<br>点击<code>call_load_methods();</code>进入相关实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren&#x27;t any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        call_class_loads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">    more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面直接有官方文档给我们的顺序</p>
<ul>
<li>1、<code>call_class_loads();</code>加载类中load方法</li>
<li>2、<code>more_categories = call_category_loads()</code>加载分类中load方法</li>
</ul>
<p><strong>Demo</strong><br>我们这里来一个测试demo</p>
<ul>
<li>父类<code>Person</code><ul>
<li>1、分类<code>Person+Run.h</code></li>
<li>2、分类<code>Person+Eat</code></li>
</ul>
</li>
<li>2、子类<ul>
<li>1、<code>Student</code></li>
<li>2、<code>Teacher</code></li>
</ul>
</li>
</ul>
<p>编译顺序:</p>
<img src="/Blog/2019/06/27/Load%E5%92%8Cinitialize%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/Load1.png" class="" title="Load">

<p>打印顺序:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">07.407021</span>+<span class="number">0800</span> 分类<span class="number">2</span>[<span class="number">4819</span>:<span class="number">145771</span>] +[Person load]</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">07.407358</span>+<span class="number">0800</span> 分类<span class="number">2</span>[<span class="number">4819</span>:<span class="number">145771</span>] +[Teacher load]</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">07.407394</span>+<span class="number">0800</span> 分类<span class="number">2</span>[<span class="number">4819</span>:<span class="number">145771</span>] +[Student load]</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">07.407417</span>+<span class="number">0800</span> 分类<span class="number">2</span>[<span class="number">4819</span>:<span class="number">145771</span>] +[Person(Eat) load]</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">07.407453</span>+<span class="number">0800</span> 分类<span class="number">2</span>[<span class="number">4819</span>:<span class="number">145771</span>] +[Person(Run) load]</span><br><span class="line">Program ended with exit code: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>1、先编译<code>Teacher</code>但是最先打印<code>Person</code></li>
<li>2、分类<code>Person+Run</code>在子类<code>Student</code>之前编译，但是打印确实先打印<code>Student</code></li>
</ul>
<p>所有上面总结是十分准确的</p>
<ul>
<li>1、先调用类的+load<ul>
<li>按照编译先后顺序调用（先编译，先调用）</li>
<li>调用子类的+load之前会先调用父类的+load</li>
</ul>
</li>
<li>2、再调用分类的+load<ul>
<li>按照编译先后顺序调用（先编译，先调用）</li>
</ul>
</li>
</ul>
<p>我们是否注意到了另一个问题，为什么在有分类的时候还加载类的<code>load</code>方法，不应该是分类覆盖类吗？</p>
<p>我们在查看<code>load</code>的源码实现的时候发现，+load方法是根据方法<code>地址</code>直接调用，并不是经过<code>objc_msgSend</code>函数调用，如果使用<code>objc_msgSend</code>会出现分类覆盖类，但是<code>load</code>直接是根据<code>指针</code>找方法的，所以不会覆盖。</p>
<h3 id="Initialize实现原理"><a href="#Initialize实现原理" class="headerlink" title="Initialize实现原理"></a>Initialize实现原理</h3><blockquote>
<p>+initialize方法会在类<code>第一次接收到消息</code>时调用</p>
</blockquote>
<p><strong>调用顺序</strong></p>
<ul>
<li>先调用父类的+initialize，再调用子类的+initialize(先初始化父类，再初始化子类，每个类只会初始化1次)</li>
<li>+initialize和+load的很大区别是，+initialize是通过objc_msgSend进行调用的，所以有以下特点<ul>
<li>如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次）</li>
<li>如果分类实现了+initialize，就覆盖类本身的+initialize调用</li>
</ul>
</li>
</ul>
<p><strong>objc4源码解读过程</strong></p>
<p>objc-runtime-new.mm</p>
<ul>
<li>class_getInstanceMethod</li>
<li>lookUpImpOrNil</li>
<li>lookUpImpOrForward</li>
<li>_class_initialize</li>
<li>callInitialize</li>
<li>objc_msgSend(cls, SEL_initialize)</li>
</ul>
<p>我们在<code>objc-runtime-new.mm</code>文件中找到<code>class_getInstanceMethod</code>，里面就有一个主要实现方法<code>lookUpImpOrNil</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Method <span class="title">class_getInstanceMethod</span><span class="params">(Class cls, SEL sel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls  ||  !sel) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">warning</span> fixme build and search caches</span></span><br><span class="line">    lookUpImpOrNil(cls, sel, nil, </span><br><span class="line">    NO<span class="comment">/*initialize*/</span>, NO<span class="comment">/*cache*/</span>, YES<span class="comment">/*resolver*/</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">warning</span> fixme build and search caches</span></span><br><span class="line">    <span class="keyword">return</span> _class_getMethod(cls, sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面没有什么实现我们继续点击<code>lookUpImpOrNil</code>进入实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">IMP <span class="title">lookUpImpOrNil</span><span class="params">(Class cls, SEL sel, id inst, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);</span><br><span class="line">    <span class="keyword">if</span> (imp == _objc_msgForward_impcache) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面好像还是没有我们想要的具体实现，继续点击<code>lookUpImpOrForward</code>查看实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">    runtimeLock.unlockRead();</span><br><span class="line">    _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">    runtimeLock.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个里面有一个<code>if</code>判断里面有一些东西，就是在没有实现<code>isInitialized</code>的时候，调用<code>_class_initialize</code>方法，我们点击进入查看相关实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">    _class_initialize(supercls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">callInitialize(cls);</span><br></pre></td></tr></table></figure>
<p>里面有这两个主要的函数</p>
<ul>
<li>1、第一个是判断是否存在父类，以及父类是否实现<code>initialize</code>方法，如果没有实现就去实现</li>
<li>2、去实现自己的<code>initialize</code>方法。</li>
</ul>
<p>我们在点击<code>callInitialize</code>发现具体是通过<code>objc_msgSend</code>来实现的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callInitialize</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Demo</strong><br>测试案例1<br>我们创建父类<code>Person</code>，然后创建子类<code>Student</code>&amp;<code>Teacher</code>，子类不实现<code>initialize</code>方法，父类实现该方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[Teacher alloc];</span><br><span class="line">[Student alloc];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">51</span>:<span class="number">34.924111</span>+<span class="number">0800</span> 分类<span class="number">2</span>[<span class="number">4965</span>:<span class="number">150760</span>] +[Person initialize]</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">51</span>:<span class="number">34.924518</span>+<span class="number">0800</span> 分类<span class="number">2</span>[<span class="number">4965</span>:<span class="number">150760</span>] +[Person initialize]</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">51</span>:<span class="number">34.924562</span>+<span class="number">0800</span> 分类<span class="number">2</span>[<span class="number">4965</span>:<span class="number">150760</span>] +[Person initialize]</span><br><span class="line">Program ended with exit code: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>结果打印三次<code>[Person initialize]</code>方法，打印一次我们是能够想到了，因为实现过程是先看看父类有没有已经实现，如果没有实现就先实现父类的。但是另外两次是怎么来的呢。</p>
<p><code>[Student alloc]</code>的实现大概是这样的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">objc_msgSend([Person <span class="keyword">class</span>], <span class="keyword">@selector</span>(initialize));</span><br><span class="line">objc_msgSend([Student <span class="keyword">class</span>], <span class="keyword">@selector</span>(initialize));</span><br></pre></td></tr></table></figure>
<ul>
<li>1、第一步就是实现父类的<code>initialize</code>方法</li>
<li>2、第二步，Student先查找自己元类有没有<code>initialize</code>方法，如果自己元类没有实现，就向上查找父类元类有没有<code>initialize</code>方法，如果有就执行，没有继续向上查找 </li>
</ul>
<p>测试案例2</p>
<p>我们创建父类<code>Person</code>，然后创建分类<code>Person+Eat</code>，都是实现<code>initialize</code>方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[Person alloc];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">07.870498</span>+<span class="number">0800</span> 分类<span class="number">2</span>[<span class="number">4993</span>:<span class="number">151954</span>] +[Person(Eat) initialize]</span><br><span class="line">Program ended with exit code: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这句代码就是证明了<code>如果分类实现了+initialize，就覆盖类本身的+initialize调用</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>load、initialize方法的区别什么？</p>
<ul>
<li>1.调用方式</li>
<li>1&gt; load是根据函数地址直接调用</li>
<li>2&gt; initialize是通过objc_msgSend调用</li>
</ul>
<p>-2.调用时刻<br>    - 1&gt; load是runtime加载类、分类的时候调用（只会调用1次）<br>    - 2&gt; initialize是类第一次接收到消息的时候调用，每一个类只会initialize一次（父类的initialize方法可能会被调用多次）</p>
<p>load、initialize的调用顺序？</p>
<p>1.load</p>
<ul>
<li><p>1&gt; 先调用类的load</p>
<ul>
<li>a) 先编译的类，优先调用load</li>
<li>b) 调用子类的load之前，会先调用父类的load</li>
</ul>
</li>
<li><p>2&gt; 再调用分类的load</p>
<ul>
<li>a) 先编译的分类，优先调用load</li>
</ul>
</li>
</ul>
<p>2.initialize</p>
<ul>
<li>1&gt; 先初始化父类</li>
<li>2&gt; 再初始化子类（可能最终调用的是父类的initialize方法）</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>MAC破解WiFi</title>
    <url>/Blog/2020/03/15/MAC%E7%A0%B4%E8%A7%A3WiFi/</url>
    <content><![CDATA[<p>1.安装airport</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ln -s /System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport /usr/sbin/airport</span><br></pre></td></tr></table></figure>

<p>2.扫描周围的Wifi</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo airport -s</span><br></pre></td></tr></table></figure>

<p>3.嗅探指定的信道</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo airport en0 sniff <span class="variable">$CHANNEL</span></span><br></pre></td></tr></table></figure>

<p>如果出现错误，Segmentation fault: 11，可以使用 tcpdump 抓包<br>4.1 断开airport的连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo airport -z</span><br></pre></td></tr></table></figure>

<p>4.2 设置信道，-c和信道号之间没有空格</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：sudo airport -c6</span></span><br><span class="line">$ sudo airport -c<span class="variable">$CHANNEL</span></span><br></pre></td></tr></table></figure>

<p>4.3 从指定AP开始抓包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：sudo tcpdump &quot;type mgt subtype beacon and ether src 98:13:33:b4:35:a4&quot; -I -c 1 -i en0 -w beacon.cap</span></span><br><span class="line">$ sudo tcpdump <span class="string">&quot;type mgt subtype beacon and ether src <span class="variable">$BSSID</span>&quot;</span> -I -c 1 -i en0 -w beacon.cap</span><br></pre></td></tr></table></figure>

<p>4.4 等待WPA的握手</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：sudo tcpdump &quot;ether proto 0x888e and ether host 98:13:33:b4:35:a4&quot; -I -U -vvv -i en0 -w handshake.cap</span></span><br><span class="line">$ sudo tcpdump <span class="string">&quot;ether proto 0x888e and ether host <span class="variable">$BSSID</span>&quot;</span> -I -U -vvv -i en0 -w handshake.cap</span><br></pre></td></tr></table></figure>

<p>4.5 安装wireshark，下一步会用到它的合包命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install wireshark</span><br></pre></td></tr></table></figure>

<p>4.6 将2个cap文件合并成一个cap文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mergecap -a -F pcap -w capture.cap beacon.cap handshake.cap</span><br></pre></td></tr></table></figure>

<p>至少要等到4.4获取到4 frames或更多的包才可以Ctrl-C终止抓包。</p>
<p>4.7 安装 aircrack-ng</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install aircrack-ng</span><br></pre></td></tr></table></figure>

<p>4.8 将 aircrack-ng 路径添加到 /etc/paths 中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/paths</span><br></pre></td></tr></table></figure>
<p>然后将 aircrack-ng 路径添加到最后一行。</p>
<p>4.9 查看抓到的包中是否包含握手包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#$ aircrack-ng capture.cap</span></span><br><span class="line">Hu-YupingdeMacBook-Pro:wifi kris$ aircrack-ng capture.cap</span><br><span class="line">Opening capture.capease <span class="built_in">wait</span>...</span><br><span class="line">Read 4 packets.</span><br><span class="line"></span><br><span class="line">   <span class="comment">#  BSSID              ESSID                     Encryption</span></span><br><span class="line"></span><br><span class="line">   1  74:7D:24:D7:AF:DC  @PHICOMM_DA               WPA (0 handshake)</span><br><span class="line"></span><br><span class="line">Choosing first network as target.</span><br><span class="line"></span><br><span class="line">Opening capture.capease <span class="built_in">wait</span>...</span><br><span class="line">Read 4 packets.</span><br><span class="line"></span><br><span class="line">1 potential targets</span><br><span class="line"></span><br><span class="line">Please specify a dictionary (option -w).</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><p>撞击密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ aircrack-ng -w alphaDic.txt -b 98:13:33:B4:35:A4 capture1.cap</span><br></pre></td></tr></table></figure>
</li>
<li><p>转换包格式,如果使用上面的cap无法爆破，或者爆破比较麻烦，可以将cap包转换成hcccapx格式，然后再破解。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./cap2hccapx.bin /Users/kris/Desktop/wifi/20200208/capture.cap /Users/kris/Desktop/wifi/20200208/capture.hccapx</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>下面是一个破解示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Aircrack-ng 1.5.2 </span><br><span class="line"></span><br><span class="line">      [00:03:20] 2018576/13516904 keys tested (10197.95 k/s) </span><br><span class="line"></span><br><span class="line">      Time left: 18 minutes, 47 seconds                         14.93%</span><br><span class="line"></span><br><span class="line">                          KEY FOUND! [ 19731009qiu ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Master Key     : A8 36 07 C4 68 42 71 E0 B9 38 6E 16 B7 1B 7A 77 </span><br><span class="line">                       DA 07 E9 A1 82 CE 95 56 22 C2 76 16 93 B1 8E 9B </span><br><span class="line"></span><br><span class="line">      Transient Key  : 34 83 20 8E B0 2E F2 11 FF 5B 68 A4 A3 16 94 FE </span><br><span class="line">                       74 28 4D D9 99 BA 10 38 F4 20 6D 14 D1 47 89 C9 </span><br><span class="line">                       22 75 EB B5 29 FD CF 9B 01 32 38 B7 51 10 94 88 </span><br><span class="line">                       90 4D 52 D5 88 E4 B1 58 DA 2D DC 35 5F 61 88 92 </span><br><span class="line"></span><br><span class="line">      EAPOL HMAC     : F6 4D 5F 02 77 F9 96 8A F4 E3 C7 8C DA E4 C6 E0 </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>通用</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/Blog/2020/05/23/Markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="标题的使用"><a href="#标题的使用" class="headerlink" title="标题的使用"></a>标题的使用</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>



<h2 id="无序列表使用"><a href="#无序列表使用" class="headerlink" title="无序列表使用"></a>无序列表使用</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 无序列表1</span><br><span class="line"><span class="bullet">-</span> 无序列表2</span><br></pre></td></tr></table></figure>

<ul>
<li>无序列表1</li>
<li>无序列表2</li>
</ul>
<h2 id="有序列表使用"><a href="#有序列表使用" class="headerlink" title="有序列表使用"></a>有序列表使用</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 有序列表1</span><br><span class="line"><span class="bullet">2.</span> 有序列表2</span><br></pre></td></tr></table></figure>

<ol>
<li>有序列表1</li>
<li>有序列表2</li>
</ol>
<h2 id="引用使用"><a href="#引用使用" class="headerlink" title="引用使用"></a>引用使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 注意不同的Xcode版本，打的iPA大小不同。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意不同的Xcode版本，打的iPA大小不同。</p>
</blockquote>
<h2 id="表格使用"><a href="#表格使用" class="headerlink" title="表格使用"></a>表格使用</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|ID|姓名|年龄|</span><br><span class="line">|---|---|---|</span><br><span class="line">|1|小明|18|</span><br><span class="line">|2|小李|25|</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>ID</th>
<th>姓名</th>
<th>年龄</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>小明</td>
<td>18</td>
</tr>
<tr>
<td>2</td>
<td>小李</td>
<td>25</td>
</tr>
</tbody></table>
<h3 id="表格居中对齐"><a href="#表格居中对齐" class="headerlink" title="表格居中对齐"></a>表格居中对齐</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|ID|姓名|年龄|</span><br><span class="line">|:---:|:---:|:---:|</span><br><span class="line">|1|小明|18|</span><br><span class="line">|2|小李|25|</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="center">姓名</th>
<th align="center">年龄</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">小明</td>
<td align="center">18</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">小李</td>
<td align="center">25</td>
</tr>
</tbody></table>
<h3 id="表格右对齐"><a href="#表格右对齐" class="headerlink" title="表格右对齐"></a>表格右对齐</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|ID|姓名|年龄|</span><br><span class="line">|---:|---:|---:|</span><br><span class="line">|1|小明|18|</span><br><span class="line">|2|小李|25|</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="right">ID</th>
<th align="right">姓名</th>
<th align="right">年龄</th>
</tr>
</thead>
<tbody><tr>
<td align="right">1</td>
<td align="right">小明</td>
<td align="right">18</td>
</tr>
<tr>
<td align="right">2</td>
<td align="right">小李</td>
<td align="right">25</td>
</tr>
</tbody></table>
<h2 id="链接使用"><a href="#链接使用" class="headerlink" title="链接使用"></a>链接使用</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">https://www.baidu.com</span>)</span><br><span class="line">[<span class="string">谷歌</span>](<span class="link">https://www.google.com</span>)</span><br></pre></td></tr></table></figure>

<p><a href="https://www.baidu.com/">百度</a><br><a href="https://www.google.com/">谷歌</a></p>
<h2 id="图片使用"><a href="#图片使用" class="headerlink" title="图片使用"></a>图片使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![]()</span><br><span class="line">![]()</span><br></pre></td></tr></table></figure>



<h2 id="HEXO图片引用"><a href="#HEXO图片引用" class="headerlink" title="HEXO图片引用"></a>HEXO图片引用</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% asset<span class="emphasis">_image 1.png 截图注释 %&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基本命令</title>
    <url>/Blog/2019/07/07/MySQL%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>MAC OSX上安装MySQL有多种方法：</p>
<ul>
<li><ol>
<li>使用DMG文件安装，安装完在系统偏好设置中有相应的管理面板可以控制MySQL服务器开启和关闭，详情可访问<a href="https://dev.mysql.com/downloads/mysql/">官网下载地址</a></li>
</ol>
</li>
<li><ol start="2">
<li>使用Homebrew安装，打开终端，输入命令<code>brew install mysql</code> ,这个安装过程中可能需要升级Homebrew，Homebrew的升级需要翻墙</li>
</ol>
</li>
</ul>
<h2 id="安装完测试MySQL需要使用的基本命令如下："><a href="#安装完测试MySQL需要使用的基本命令如下：" class="headerlink" title="安装完测试MySQL需要使用的基本命令如下："></a>安装完测试MySQL需要使用的基本命令如下：</h2><p>1.使用brew安装完MySQL时,root密码默认为空，如果要设置MySQL的相关安全策略，使用命令: <code>mysql_secure_installation</code></p>
<p>2.打开mysql,带后台线程（电脑重启后会自己开启）:<code>brew services start mysql</code></p>
<p>3.打开mysql，不带后台线程:<code>mysql.server start</code></p>
<p>4.退出mysql:<code>brew services stop mysql</code></p>
<p>5.登录MySQL:<code>mysql -u root -p</code></p>
<p>6.查看MySQL的版本号:mysql&gt; <code>select Version();</code></p>
<p>7.查看当前登录的MySQL运行的端口号:mysql&gt; <code>show global variables like &#39;port&#39;;</code></p>
<p>8.显示可用的数据库:<code>SHOW DATABASES;</code></p>
<p>9.选择数据库:mysql&gt; <code>USE crashcourse;</code></p>
<p>10.显示数据库中所有可用的表:mysql&gt; <code>SHOW TABLES;</code></p>
<p>11.显示表列: <code>SHOW COLUMNS FROM customers;</code> 或 <code>DESCRIBE customers;</code></p>
<p>12.显示服务器状态信息:<code>SHOW STATUS;</code></p>
<p>13.显示用户的安全权限:<code>SHOW GRANTS;</code></p>
<p>14.显示服务器错误信息:<code>SHOW ERRORS;</code></p>
<p>15.显示服务器警告信息:<code>SHOW WARNINGS;</code></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>NSOperation介绍</title>
    <url>/Blog/2020/07/04/NSOperation%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<img src="/Blog/2020/07/04/NSOperation%E4%BB%8B%E7%BB%8D/NSOperation.png" class="" title="NSOperation思维导图">

<h2 id="NSOperation介绍"><a href="#NSOperation介绍" class="headerlink" title="NSOperation介绍"></a>NSOperation介绍</h2><p>NSOperation、NSOperationQueue 是苹果提供给我们的一套多线程解决方案。实际上 NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象。</p>
<p>好处：</p>
<ul>
<li>1、可添加完成的代码块，在操作完成后执行</li>
<li>2、添加操作之间的依赖关系，方便的控制执行顺序</li>
<li>3、设定操作执行的优先级</li>
<li>4、可以很方便的取消一个操作的执行</li>
<li>5、使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled</li>
</ul>
<p>既然是基于 GCD 的更高一层的封装。那么，GCD 中的一些概念同样适用于 NSOperation、NSOperationQueue。在 NSOperation、NSOperationQueue 中也有类似的任务（操作）和队列（操作队列）的概念。</p>
<p><strong>操作（Operation）</strong></p>
<ul>
<li>1、执行操作的意思，换句话说就是你在线程中执行的那段代码</li>
<li>2、在 <code>GCD </code>中是放在 <code>block</code> 中的。在 <code>NSOperation</code> 中，我们使用 NSOperation 子类 <code>NSInvocationOperation</code>、<code>NSBlockOperation</code>，或者自定义子类来封装操作</li>
</ul>
<p><strong>操作队列（Operation Queues）</strong></p>
<ul>
<li>1、这里的队列指操作队列，即用来存放操作的队列。不同于 GCD 中的调度队列 FIFO（先进先出）的原则。NSOperationQueue 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。</li>
<li>2、操作队列通过设置最大并发操作数（maxConcurrentOperationCount）来控制并发、串行</li>
<li>3、NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行</li>
</ul>
<h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><p><strong>NSOperation常用属性和方法</strong></p>
<ul>
<li><p>1、开始取消操作</p>
<ul>
<li><code>- (void)start;</code>：对于并发Operation需要重写该方法，也可以不把operation加入到队列中，手动触发执行，与调用普通方法一样</li>
<li><code>- (void)main;</code>：非并发Operation需要重写该方法</li>
<li><code>- (void)cancel;</code>：可取消操作，实质是标记 isCancelled 状态</li>
</ul>
</li>
<li><p>2、判断操作状态方法</p>
<ul>
<li><code>- (BOOL)isFinished;</code> 判断操作是否已经结束</li>
<li><code>- (BOOL)isCancelled;</code> 判断操作是否已经标记为取消</li>
<li><code>- (BOOL)isExecuting;</code>判断操作是否正在在运行</li>
<li><code>- (BOOL)isReady;</code>判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。</li>
</ul>
</li>
<li><p>3、操作同步</p>
<ul>
<li><code>- (void)waitUntilFinished;</code>阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步</li>
<li><code>- (void)setCompletionBlock:(void (^)(void))block;</code>  会在当前操作执行完毕时执行 completionBlock </li>
<li><code>- (void)addDependency:(NSOperation *)op;</code> 添加依赖，使当前操作依赖于操作 op 的完成</li>
<li><code>- (void)removeDependency:(NSOperation *)op;</code> 移除依赖，取消当前操作对操作 op 的依赖。</li>
<li><code>@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies;</code> 在当前操作开始执行之前完成执行的所有操作对象数组。</li>
</ul>
</li>
</ul>
<p><strong>NSOperationQueue 常用属性和方法</strong></p>
<ul>
<li><p>1、取消/暂停/恢复操作</p>
<ul>
<li><code>- (void)cancelAllOperations;</code> 可以取消队列的所有操作</li>
<li><code>- (BOOL)isSuspended;</code> 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态</li>
<li><code>- (void)setSuspended:(BOOL)b;</code> 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列</li>
</ul>
</li>
<li><p>2、操作同步</p>
<ul>
<li><code>- (void)waitUntilAllOperationsAreFinished;</code> 阻塞当前线程，直到队列中的操作全部执行完毕。</li>
</ul>
</li>
<li><p>3、添加/获取操作</p>
<ul>
<li><code>- (void)addOperationWithBlock:(void (^)(void))block;</code> 向队列中添加一个 NSBlockOperation 类型操作对象</li>
<li><code>- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait;</code>向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束</li>
<li><code>- (NSArray *)operations;</code> 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）</li>
<li><code>- (NSUInteger)operationCount;</code> 当前队列中的操作数</li>
</ul>
</li>
<li><p>4、获取队列</p>
<ul>
<li><code>+ (id)currentQueue;</code> 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。</li>
<li><code>+ (id)mainQueue;</code>  获取主队列。</li>
</ul>
</li>
</ul>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>NSOperation 需要配合 NSOperationQueue 来实现多线程。因为默认情况下，NSOperation 单独使用时系统同步执行操作，配合 NSOperationQueue 我们能更好的实现异步执行。</p>
<p>实现步骤：</p>
<ul>
<li>1、创建操作：先将需要执行的操作封装到一个 NSOperation 对象中</li>
<li>2、创建队列：创建 NSOperationQueue 对象</li>
<li>3、将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中</li>
</ul>
<p>NSOperation 是个抽象类，不能用来封装操作。我们只有使用它的子类来封装操作：</p>
<ul>
<li>1、使用子类 NSInvocationOperation</li>
<li>2、使用子类 NSBlockOperation</li>
<li>3、自定义继承自 NSOperation 的子类，通过实现内部相应的方法来封装操作</li>
</ul>
<h4 id="使用子类-NSInvocationOperation"><a href="#使用子类-NSInvocationOperation" class="headerlink" title="使用子类 NSInvocationOperation"></a>使用子类 <code>NSInvocationOperation</code></h4><p>在主线程中操作:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)Operation1 &#123;</span><br><span class="line">  <span class="comment">//1、创建NSInvocationOperation对象</span></span><br><span class="line">  <span class="built_in">NSInvocationOperation</span> *op = [[<span class="built_in">NSInvocationOperation</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(test) object:<span class="literal">nil</span>];</span><br><span class="line">  <span class="comment">//2、开始调用</span></span><br><span class="line">  [op start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;当前线程:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">23.108524</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">2211</span>:<span class="number">95115</span>] 当前线程:&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000028c2d00</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">23.108688</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">2211</span>:<span class="number">95115</span>] 当前线程:&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000028c2d00</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>

<p>如果在其他线程中操作:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(Operation1) object:<span class="string">@&quot;Hello, World&quot;</span>];</span><br><span class="line"><span class="comment">//设置线程的名字，方便查看</span></span><br><span class="line">[thread setName:<span class="string">@&quot;firstThread&quot;</span>];</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">15</span>:<span class="number">33</span>:<span class="number">54.722270</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">2373</span>:<span class="number">105328</span>] 当前线程:&lt;<span class="built_in">NSThread</span>: <span class="number">0x60000242f9c0</span>&gt;&#123;number = <span class="number">6</span>, name = firstThread&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">15</span>:<span class="number">33</span>:<span class="number">54.722442</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">2373</span>:<span class="number">105328</span>] 当前线程:&lt;<span class="built_in">NSThread</span>: <span class="number">0x60000242f9c0</span>&gt;&#123;number = <span class="number">6</span>, name = firstThread&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：在没有使用 <code>NSOperationQueue</code>、在主线程中单独使用使用子类 <code>NSInvocationOperation</code> 执行一个操作的情况下，操作是在当前线程执行的，并<code>没有开启新线程</code>。</p>
<h4 id="使用子类-NSBlockOperation"><a href="#使用子类-NSBlockOperation" class="headerlink" title="使用子类 NSBlockOperation"></a>使用子类 <code>NSBlockOperation</code></h4><p>在主线程中:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)Operation2&#123;</span><br><span class="line">  <span class="comment">//1、使用NSBlockOperation</span></span><br><span class="line">  <span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;当前线程:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="comment">//2、开始调用</span></span><br><span class="line">  [op start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">15</span>:<span class="number">31</span>:<span class="number">49.650987</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">2329</span>:<span class="number">102582</span>] 当前线程:&lt;<span class="built_in">NSThread</span>: <span class="number">0x600001d5ad40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>

<p>如果在其他线程中操作:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(Operation2) object:<span class="string">@&quot;Hello, World&quot;</span>];</span><br><span class="line"><span class="comment">//设置线程的名字，方便查看</span></span><br><span class="line">[thread setName:<span class="string">@&quot;firstThread&quot;</span>];</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">15</span>:<span class="number">26</span>:<span class="number">06.006847</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">2264</span>:<span class="number">97942</span>] 当前线程:&lt;<span class="built_in">NSThread</span>: <span class="number">0x600003f63080</span>&gt;&#123;number = <span class="number">6</span>, name = firstThread&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">15</span>:<span class="number">26</span>:<span class="number">06.006998</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">2264</span>:<span class="number">97942</span>] 当前线程:&lt;<span class="built_in">NSThread</span>: <span class="number">0x600003f63080</span>&gt;&#123;number = <span class="number">6</span>, name = firstThread&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：在没有使用 <code>NSOperationQueue</code>、在主线程中单独使用使用子类 <code>NSBlockOperation</code> 执行一个操作的情况下，操作是在当前线程执行的，并<code>没有开启新线程</code>。</p>
<p><strong>addExecutionBlock</strong></p>
<p><code>NSBlockOperation</code> 还提供了一个方法 <code>addExecutionBlock:</code>，通过 <code>addExecutionBlock:</code> 就可以为 <code>NSBlockOperation</code> 添加额外的操作。这些操作（包括 blockOperationWithBlock 中的操作）可以在不同的线程中同时<code>（并发）</code>执行。只有当所有相关的操作已经完成执行时，才视为完成。每添加一个<code>addExecutionBlock:</code>就是开启一个异步并发执行事件。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、使用NSBlockOperation</span></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;当前线程:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">[op addExecutionBlock:^&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;当前线程2：%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br><span class="line">[op addExecutionBlock:^&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;当前线程3：%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br><span class="line">[op addExecutionBlock:^&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;当前线程4：%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、开始调用</span></span><br><span class="line">[op start];</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">00.036304</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">2449</span>:<span class="number">111971</span>] 当前线程<span class="number">2</span>：&lt;<span class="built_in">NSThread</span>: <span class="number">0x600001201600</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">00.036307</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">2449</span>:<span class="number">111970</span>] 当前线程:&lt;<span class="built_in">NSThread</span>: <span class="number">0x600001226100</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">00.036317</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">2449</span>:<span class="number">111972</span>] 当前线程<span class="number">4</span>：&lt;<span class="built_in">NSThread</span>: <span class="number">0x600001226e00</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">00.036328</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">2449</span>:<span class="number">111776</span>] 当前线程<span class="number">3</span>：&lt;<span class="built_in">NSThread</span>: <span class="number">0x600001249e40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">00.036459</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">2449</span>:<span class="number">111971</span>] 当前线程<span class="number">2</span>：&lt;<span class="built_in">NSThread</span>: <span class="number">0x600001201600</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">00.036460</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">2449</span>:<span class="number">111972</span>] 当前线程<span class="number">4</span>：&lt;<span class="built_in">NSThread</span>: <span class="number">0x600001226e00</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">00.036533</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">2449</span>:<span class="number">111776</span>] 当前线程<span class="number">3</span>：&lt;<span class="built_in">NSThread</span>: <span class="number">0x600001249e40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义继承自-NSOperation-的子类"><a href="#自定义继承自-NSOperation-的子类" class="headerlink" title="自定义继承自 NSOperation 的子类"></a>自定义继承自 NSOperation 的子类</h4><p>如果使用子类<code> NSInvocationOperation</code>、<code>NSBlockOperation </code>不能满足日常需求，我们可以使用自定义继承自 NSOperation 的子类。可以通过重写 <code>main </code>或者 <code>start </code>方法 来定义自己的 <code>NSOperation 对象</code>。重写<code>main</code>方法比较简单，我们不需要管理操作的状态属性<code> isExecuting</code> 和 <code>isFinished</code>。当 <code>main</code> 执行完返回的时候，这个操作就结束了。<br>HHOperation.h</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HHOperation</span> : <span class="title">NSOperation</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>

<p>HHOperation.m</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;HHOperation.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HHOperation</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)main &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;当前线程：%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>调用:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)Operation3&#123;</span><br><span class="line">    <span class="comment">// 1.创建 HHOperation 对象</span></span><br><span class="line">    HHOperation *op = [[HHOperation alloc] init];</span><br><span class="line">    <span class="comment">// 2.调用 start 方法开始执行操作</span></span><br><span class="line">    [op start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NSOperationQueue-创建队列"><a href="#NSOperationQueue-创建队列" class="headerlink" title="NSOperationQueue 创建队列"></a><code>NSOperationQueue</code> 创建队列</h3><p> NSOperationQueue 一共有两种队列：主队列、自定义队列。其中自定义队列同时包含了串行、并发功能。</p>
<p><strong>主队列</strong><br>凡是添加到主队列中的操作，都会放到主线程中执行（注：不包括操作使用addExecutionBlock:添加的额外操作)。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主队列获取方法</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [<span class="built_in">NSOperationQueue</span> mainQueue];</span><br></pre></td></tr></table></figure>
<p><strong>自定义队列</strong><br>添加到这种队列中的操作，就会自动放到子线程中执行。同时包含了：串行、并发功能。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义队列创建方法</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br></pre></td></tr></table></figure>

<h4 id="将操作加入到队列中"><a href="#将操作加入到队列中" class="headerlink" title="将操作加入到队列中"></a>将操作加入到队列中</h4><p>NSOperation 需要配合 NSOperationQueue 来实现多线程，总共有两种方法：</p>
<ul>
<li>1、<code>- (void)addOperation:(NSOperation *)op;</code> 需要先创建操作，再将创建好的操作加入到创建好的队列中去。</li>
<li>2、<code>- (void)addOperationWithBlock:(void (^)(void))block;</code> 无需先创建操作，在 block 中添加操作，直接将包含操作的 block 加入到队列中。</li>
</ul>
<p><strong>addOperation</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)Operation4&#123;</span><br><span class="line">  <span class="comment">//1、创建队列</span></span><br><span class="line">  <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line">  <span class="comment">//2、创建操作</span></span><br><span class="line">  <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;当前线程1:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;当前线程2:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="built_in">NSBlockOperation</span> *op3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;当前线程3:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//3、添加操作</span></span><br><span class="line">  [queue addOperation:op1];</span><br><span class="line">  [queue addOperation:op2];</span><br><span class="line">  [queue addOperation:op3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">16</span>:<span class="number">30</span>:<span class="number">38.843822</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">3307</span>:<span class="number">147785</span>] 当前线程<span class="number">2</span>:&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000029a2a40</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">16</span>:<span class="number">30</span>:<span class="number">38.843820</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">3307</span>:<span class="number">147786</span>] 当前线程<span class="number">3</span>:&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000029f19c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">16</span>:<span class="number">30</span>:<span class="number">38.843832</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">3307</span>:<span class="number">147787</span>] 当前线程<span class="number">1</span>:&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000029d46c0</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>


<p><strong>addOperationWithBlock</strong></p>
<p>无需先创建操作，在 block 中添加操作，直接将包含操作的 block 加入到队列中。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)Operation5&#123;</span><br><span class="line">  <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line">  [queue addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;当前线程1:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">  &#125;];</span><br><span class="line">  [queue addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;当前线程2:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">  &#125;];</span><br><span class="line">  [queue addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;当前线程3:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最大并发操作数量-maxConcurrentOperationCount"><a href="#最大并发操作数量-maxConcurrentOperationCount" class="headerlink" title="最大并发操作数量 maxConcurrentOperationCount"></a>最大并发操作数量 <code>maxConcurrentOperationCount</code></h4><p><code>maxConcurrentOperationCount</code>最大并发操作数量</p>
<ul>
<li><p>maxConcurrentOperationCount 默认情况下为-1，表示不进行限制，可进行并发执行。</p>
</li>
<li><p>maxConcurrentOperationCount 为1时，队列为串行队列。只能串行执行。</p>
</li>
<li><p>maxConcurrentOperationCount 大于1时，队列为并发队列。操作并发执行，当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为 min{自己设定的值，系统设定的默认最大值}</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line">queue.maxConcurrentOperationCount = <span class="number">1</span>; <span class="comment">// 串行队列</span></span><br><span class="line">queue.maxConcurrentOperationCount = <span class="number">2</span>; <span class="comment">// 并发队列，一次只能执行两个并发队列</span></span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;当前线程1:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;当前线程2:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;当前线程3:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="NSOperation-操作依赖"><a href="#NSOperation-操作依赖" class="headerlink" title="NSOperation 操作依赖"></a>NSOperation 操作依赖</h4><p>NSOperation、NSOperationQueue 最吸引人的地方是它能添加操作之间的依赖关系。通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序。</p>
<ul>
<li><code>- (void)addDependency:(NSOperation *)op; </code>添加依赖，使当前操作依赖于操作 op 的完成。</li>
<li><code>- (void)removeDependency:(NSOperation *)op; </code>移除依赖，取消当前操作对操作 op 的依赖。</li>
<li><code>@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies;</code> 在当前操作开始执行之前完成执行的所有操作对象数组</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)Operation6&#123;</span><br><span class="line">  <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line">  <span class="comment">//2、创建操作</span></span><br><span class="line">  <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;当前线程1:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;当前线程2:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="built_in">NSBlockOperation</span> *op3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;当前线程3:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//3、添加依赖</span></span><br><span class="line">  [op3 addDependency:op1];</span><br><span class="line">  [op3 addDependency:op2];</span><br><span class="line">  <span class="comment">//4、添加操作</span></span><br><span class="line">  [queue addOperation:op1];</span><br><span class="line">  [queue addOperation:op2];</span><br><span class="line">  [queue addOperation:op3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面<code>op3</code>依赖<code>op1&amp;op2</code>执行完成才能执行:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">16</span>:<span class="number">34</span>:<span class="number">12.396522</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">3346</span>:<span class="number">151090</span>] 当前线程<span class="number">1</span>:&lt;<span class="built_in">NSThread</span>: <span class="number">0x600000363580</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">16</span>:<span class="number">34</span>:<span class="number">13.398032</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">3346</span>:<span class="number">151088</span>] 当前线程<span class="number">2</span>:&lt;<span class="built_in">NSThread</span>: <span class="number">0x600000376cc0</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-04</span> <span class="number">16</span>:<span class="number">34</span>:<span class="number">13.398415</span>+<span class="number">0800</span> <span class="built_in">NSOperation</span>[<span class="number">3346</span>:<span class="number">151088</span>] 当前线程<span class="number">3</span>:&lt;<span class="built_in">NSThread</span>: <span class="number">0x600000376cc0</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.jianshu.com/p/4b1d77054b35">参考：iOS 多线程：『NSOperation、NSOperationQueue』详尽总结</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>NSThread介绍</title>
    <url>/Blog/2020/07/04/NSThread%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="NSThread介绍"><a href="#NSThread介绍" class="headerlink" title="NSThread介绍"></a>NSThread介绍</h2><p>NSThread 是苹果官方提供的，使用起来比 pthread 更加面向对象，简单易用，可以直接操作线程对象。不过也需要需要程序员自己管理线程的生命周期(主要是创建)，我们在开发的过程中偶尔使用 NSThread。比如我们会经常调用[NSThread currentThread]来显示当前的进程信息。</p>
<h4 id="NSThread的创建与运行"><a href="#NSThread的创建与运行" class="headerlink" title="NSThread的创建与运行"></a>NSThread的创建与运行</h4> <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//使用target对象的selector作为线程的任务执行体，该selector方法最多可以接收一个参数，该参数即为argument</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target selector:(SEL)selector object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)argument</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//使用block作为线程的任务执行体</span></span><br><span class="line"> - (<span class="keyword">instancetype</span>)initWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 类方法，返回值为void</span></span><br><span class="line"><span class="comment"> 使用一个block作为线程的执行体，并直接启动线程</span></span><br><span class="line"><span class="comment"> 上面的实例方法返回NSThread对象需要手动调用start方法来启动线程执行任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> + (<span class="keyword">void</span>)detachNewThreadWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 类方法，返回值为void</span></span><br><span class="line"><span class="comment"> 使用target对象的selector作为线程的任务执行体，该selector方法最多接收一个参数，该参数即为argument</span></span><br><span class="line"><span class="comment"> 同样的，该方法创建完县城后会自动启动线程不需要手动触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> + (<span class="keyword">void</span>)detachNewThreadSelector:(SEL)selector toTarget:(<span class="keyword">id</span>)target withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)argument</span><br></pre></td></tr></table></figure>
<p>简单运用:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">  [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">  <span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span></span><br><span class="line">                      selector:<span class="keyword">@selector</span>(firstThread:) object:<span class="string">@&quot;Hello, World&quot;</span>];</span><br><span class="line">  <span class="comment">//设置线程的名字，方便查看</span></span><br><span class="line">  [thread setName:<span class="string">@&quot;firstThread&quot;</span>];</span><br><span class="line">  <span class="comment">//启动线程</span></span><br><span class="line">  [thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的任务执行体并接收一个参数arg</span></span><br><span class="line">- (<span class="keyword">void</span>)firstThread:(<span class="keyword">id</span>)arg &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;Task %@ %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread], arg);</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;Thread Task Complete&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/Blog/2020/07/04/NSThread%E4%BB%8B%E7%BB%8D/NSThread1.png" class="" title="NSThread">


<h4 id="常见API"><a href="#常见API" class="headerlink" title="常见API"></a>常见API</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得主线程</span></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)mainThread;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为主线程(对象方法)</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isMainThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为主线程(类方法)</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isMainThread;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得当前线程</span></span><br><span class="line"><span class="built_in">NSThread</span> *current = [<span class="built_in">NSThread</span> currentThread];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的名字——setter方法</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)n;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的名字——getter方法</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)name;</span><br></pre></td></tr></table></figure>


<h4 id="线程状态控制方法"><a href="#线程状态控制方法" class="headerlink" title="线程状态控制方法"></a>线程状态控制方法</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态</span></span><br><span class="line">- (<span class="keyword">void</span>)start;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程进入阻塞状态</span></span><br><span class="line">+ (<span class="keyword">void</span>)sleepUntilDate:(<span class="built_in">NSDate</span> *)date;</span><br><span class="line">+ (<span class="keyword">void</span>)sleepForTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti;</span><br><span class="line"></span><br><span class="line"><span class="comment">//强制停止线程  线程进入死亡状态</span></span><br><span class="line">+ (<span class="keyword">void</span>)exit;</span><br></pre></td></tr></table></figure>

<h4 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h4><p>在开发中，我们经常会在子线程进行耗时操作，操作结束后再回到主线程去刷新 UI。这就涉及到了子线程和主线程之间的通信。我们先来了解一下官方关于 NSThread 的线程间通信的方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在主线程上执行操作</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</span><br><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array;</span><br><span class="line"><span class="comment">// equivalent to the first method with kCFRunLoopCommonModes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定线程上执行操作</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="built_in">NSArray</span> *)array <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在当前线程上执行操作，调用 NSObject 的 performSelector:相关方法</span></span><br><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector;</span><br><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)object;</span><br><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)object1 withObject:(<span class="keyword">id</span>)object2;</span><br></pre></td></tr></table></figure>


<h3 id="线程的状态转换"><a href="#线程的状态转换" class="headerlink" title="线程的状态转换"></a>线程的状态转换</h3><p>当我们新建一条线程NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];，在内存中的表现为：</p>
<img src="/Blog/2020/07/04/NSThread%E4%BB%8B%E7%BB%8D/NSThread2.png" class="" title="NSThread">

<p>当调用[thread start];后，系统把线程对象放入可调度线程池中，线程对象进入就绪状态，如下图所示。</p>
<img src="/Blog/2020/07/04/NSThread%E4%BB%8B%E7%BB%8D/NSThread3.png" class="" title="NSThread">

<ul>
<li>如果CPU现在调度当前线程对象，则当前线程对象进入运行状态，如果CPU调度其他线程对象，则当前线程对象回到就绪状态。</li>
<li>如果CPU在运行当前线程对象的时候调用了sleep方法\等待同步锁，则当前线程对象就进入了阻塞状态，等到sleep到时\得到同步锁，则回到就绪状态。</li>
<li>如果CPU在运行当前线程对象的时候线程任务执行完毕\异常强制退出，则当前线程对象进入死亡状态。</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS修改镜像源</title>
    <url>/Blog/2020/05/26/NodeJS%E4%BF%AE%E6%94%B9%E9%95%9C%E5%83%8F%E6%BA%90/</url>
    <content><![CDATA[<p>1.查看<code>NodeJS</code>当前使用的镜像源，使用命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 查看当前NodeJS使用的镜像源</span><br><span class="line">$ npm config get registry</span><br></pre></td></tr></table></figure>

<p>使用上述命令查看<code>NodeJS</code>使用的默认镜像源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">poetmacbook-pro:~ kris$ npm config get registry</span><br><span class="line">https://registry.npmjs.org/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   ╭────────────────────────────────────────────────────────────────╮</span><br><span class="line">   │                                                                │</span><br><span class="line">   │       New minor version of npm available! 6.4.1 → 6.14.5       │</span><br><span class="line">   │   Changelog: https://github.com/npm/cli/releases/tag/v6.14.5   │</span><br><span class="line">   │               Run npm install -g npm to update!                │</span><br><span class="line">   │                                                                │</span><br><span class="line">   ╰────────────────────────────────────────────────────────────────╯</span><br><span class="line"></span><br><span class="line">poetmacbook-pro:~ kris$ </span><br></pre></td></tr></table></figure>

<p>2.将<code>NodeJS</code>的源切换成淘宝的镜像源。<br>首先打开网址<code>https://developer.aliyun.com/mirror/NPM?from=tnpm</code>,根据网站提示在终端执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<blockquote>
<p>切记：如果淘宝镜像源不管用了，及时切回默认的镜像源。</p>
</blockquote>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.cnblogs.com/oukele/p/11592638.html">nodeJs修改镜像源</a></p>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title>OC对象的分类</title>
    <url>/Blog/2019/06/22/OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="OC对象的分类"><a href="#OC对象的分类" class="headerlink" title="OC对象的分类"></a>OC对象的分类</h2><p> OC对象主要可以分为3种</p>
<ul>
<li>1、instance对象（实例对象）：instance实例对象就是通过alloc出来的对象，每次调用alloc都会产生新的instance对象</li>
<li>2、class对象（类对象）：每个类在内存中有且只有一个类对象</li>
<li>3、meta-class对象（元类对象）：每个类在内存中有且只有一个元类对象</li>
</ul>
<p>实例对象的存储信息</p>
<ul>
<li>isa指针</li>
<li>其他成员变量</li>
</ul>
<p>类对象的存储信息</p>
<ul>
<li>isa指针</li>
<li>superclass指针</li>
<li>类的属性信息（@property），类的对象方法信息（instance method），类的协议信息（protocol），类的成员变量信息（ivar）</li>
</ul>
<p>元类的存储信息</p>
<ul>
<li>isa指针</li>
<li>superclass指针</li>
<li>类的类方法信息（class method）</li>
</ul>
<p><code>元类和类的存储结构是一样的，但是用途不一样</code></p>
<img src="/Blog/2019/06/22/OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB/OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB1.png" class="" title="OC对象的分类">

<ul>
<li>instance的isa指向class，当调用<code>对象方法</code>时，通过instance的isa找到class，最后找到对象方法的实现进行调用</li>
<li>class的isa指向meta-class，当调用<code>类方法</code>时，通过class的isa找到meta-class，最后找到<code>类方法</code></li>
</ul>
<h2 id="总览图"><a href="#总览图" class="headerlink" title="总览图"></a>总览图</h2> <img src="/Blog/2019/06/22/OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB/OC%E5%AF%B9%E8%B1%A1%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%9B%BE%E8%B0%B1.png" class="" title="OC对象类的继承图谱">

<ul>
<li>1、instance的<code>isa</code>指向class</li>
<li>2、class的<code>isa</code>指向meta-class</li>
<li>3、meta-class的<code>isa</code>指向基类的meta-class</li>
<li>4、class的<code>superclass</code>指向<code>父类的class</code>，如果没有父类，superclass指向nil</li>
<li>5、meta-class的<code>superclass</code>指向父类的meta-class，基类的meta-class的superclass指向基类的class</li>
<li>6、instance的调用轨迹：isa找class，方法不存在，就通过superclass找父类</li>
<li>7、class调用类方法的轨迹：isa找到meta-class，方法不存在，就通过superclass找父类</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习笔记(Python3编码)</title>
    <url>/Blog/2019/04/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Python3%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>Python3中的字符串是Unicode字符串而不是字节数组。这是与Python2相比最大的差别。在Python2中，我们需要区分普通的字节为单位的字符串以及Unicode字符串。</p>
<h2 id="使用UTF-8编码和解码"><a href="#使用UTF-8编码和解码" class="headerlink" title="使用UTF-8编码和解码"></a>使用UTF-8编码和解码</h2><p>对字符串进行处理时，并不需要在意Python中Unicode字符的存储细节。当需要与外界进行数据交互时则需要完成两件事情:</p>
<ul>
<li>将字符串__编码__为字节</li>
<li>将字节__解码__为字符串</li>
</ul>
<p>如果Unicode包含的字符种类不超过64000种，我们就可以将字符ID统一存储在2字节中。遗憾的是，Unicode所包含的字符种类远不只此。诚然，我们将字符ID统一编码在3或4字节中，但是这样会使空间开销(内存和硬盘)增加3到4倍。两位Unix开发大神设计出了UTF-8动态编码方案。这种方案会动态的为每个Unicode字符分配1到4字节不等:</p>
<ul>
<li>为ASCII字符分配1字节</li>
<li>为拉丁语系(除西里尔语)的语言分配2字节</li>
<li>为其他的位于基本多语言平面的字符分配3字节</li>
<li>为剩下的字符集分配4字节，这包括一些亚洲语言及符号</li>
</ul>
<p>UTF-8是Python、Linux以及HTML的标准文本编码格式。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>__编码是将字符串转化为一系列字节的过程__。字符串的__encode()__函数所接收的第一个参数是编码方式。可选的编码方式见下表。</p>
<div style="width:400px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2019/04/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Python3%E7%BC%96%E7%A0%81/Snip20190427_1.png" class="" title="编码方式的截图"> </div>

<p>下面使用代码进行说明:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个Unicode字符串，它含有一个中文字符</span></span><br><span class="line">name = <span class="string">&quot;中&quot;</span></span><br><span class="line"><span class="comment"># 打印字符串的类型</span></span><br><span class="line">print(<span class="built_in">type</span>(name))</span><br><span class="line"><span class="comment"># 打印字符串</span></span><br><span class="line">print(name)</span><br><span class="line"><span class="comment"># 打印字符串的长度，最后结果为1，说明len()获取的是字符串中字符的个数，不是字节长度</span></span><br><span class="line">print(<span class="built_in">len</span>(name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串编码为UTF-8的字节序列</span></span><br><span class="line">ds = name.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">print(<span class="string">&quot;--------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印字节序列的类型</span></span><br><span class="line">print(<span class="built_in">type</span>(ds))</span><br><span class="line"><span class="comment"># 打印字符串编码过后的字节序列</span></span><br><span class="line">print(ds)</span><br><span class="line"><span class="comment"># 打印字节序列的长度，发现一个中文字符在UTF-8编码中占3个字节</span></span><br><span class="line">print(<span class="built_in">len</span>(ds))</span><br></pre></td></tr></table></figure>

<p>程序的运行结果如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">中</span></span><br><span class="line"><span class="class">1</span></span><br><span class="line"><span class="class">--------</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">bytes</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">b</span>&#x27;\<span class="title">xe4</span>\<span class="title">xb8</span>\<span class="title">xad</span>&#x27;</span></span><br><span class="line"><span class="class">3</span></span><br></pre></td></tr></table></figure>
<p>由上面的运行结果可以知道，单个的Unicode中文字符在UTF-8编码的格式下占用了3字节的空间。当然，你也可以使用UTF-8以外的编码方式，但该Unicode字符串可能无法被指定的编码方式处理，此时Python会抛出异常。例如将上面的Unicode中文字符编码为ascii字节，就会报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;中&#x27;</span></span><br><span class="line">ds = name.encode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">print(ds)</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/kris/PycharmProjects/pythons_demo/Python语言及其应用/第七章/test.py&quot;</span>, line <span class="number">26</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    ds = name.encode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">UnicodeEncodeError: <span class="string">&#x27;ascii&#x27;</span> codec can<span class="string">&#x27;t encode character &#x27;</span>\u4e2d<span class="string">&#x27; in position 0: ordinal not in range(128)</span></span><br></pre></td></tr></table></figure>
<p>__encode()__函数可以接受额外的第二个参数来帮助你避免编码异常。它的默认值是’strict’,如上例所示,当函数检测到需要处理的字符串包含非ASCII字符时,会抛出UnicodeEncodeError异常。当然还有别的可选值,使用’ignore’会抛弃任何无法进行编码的字符;使用’replace’会将所有无法进行编码的字符替换为?;’backslashreplace’则会创建一个和Unicode-escape类似的Unicode字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;ab中cd&#x27;</span></span><br><span class="line">print(name)</span><br><span class="line">print(name.encode(<span class="string">&#x27;ascii&#x27;</span>, <span class="string">&#x27;ignore&#x27;</span>))</span><br><span class="line">print(name.encode(<span class="string">&#x27;ascii&#x27;</span>, <span class="string">&#x27;replace&#x27;</span>))</span><br><span class="line">print(name.encode(<span class="string">&#x27;ascii&#x27;</span>, <span class="string">&#x27;backslashreplace&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>程序的运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ab中cd</span><br><span class="line"><span class="string">b&#x27;abcd&#x27;</span></span><br><span class="line"><span class="string">b&#x27;ab?cd&#x27;</span></span><br><span class="line"><span class="string">b&#x27;ab\\u4e2dcd&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>__解码__是将字节序列转化为Unicode字符串的过程。我们从外界文本源(文件、数据库、网站、网络API等)获得的所有文本都是经过编码的字节序列。重要的是需要知道它是以何种方式编码的，这样才能逆转编码过程以获得Unicode字符串。</p>
<p>问题是字节序列本身不带有任何指明编码方式的信息。之前我也提到过网站随意复制粘贴文本的风险,你也可能遇到过网页乱码的情况,本应是ASCII字符的位置却被奇怪的字符占据了,这些都是编码和解码的方式不一致导致的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">place = <span class="string">&#x27;caf\u00e9&#x27;</span></span><br><span class="line">print(place)</span><br><span class="line">print(<span class="built_in">type</span>(place))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编码</span></span><br><span class="line">place_tytes = place.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">print(place_tytes)</span><br><span class="line">print(<span class="built_in">type</span>(place_tytes))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码</span></span><br><span class="line">place2 = place_tytes.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">print(place2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用ASCII解码,会报错</span></span><br><span class="line"><span class="comment"># place3 = place_tytes.decode(&#x27;ascii&#x27;)</span></span><br><span class="line"><span class="comment"># print(place3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用其他编码格式解码</span></span><br><span class="line">place4 = place_tytes.decode(<span class="string">&#x27;latin_1&#x27;</span>)</span><br><span class="line">print(place4)</span><br><span class="line"></span><br><span class="line">place5 = place_tytes.decode(<span class="string">&#x27;windows-1252&#x27;</span>)</span><br><span class="line">print(place5)</span><br></pre></td></tr></table></figure>
<p>程序的运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">café</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">b</span>&#x27;<span class="title">caf</span>\<span class="title">xc3</span>\<span class="title">xa9</span>&#x27;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">bytes</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">caf</span>é</span></span><br><span class="line"><span class="class"><span class="title">caf</span>Ã©</span></span><br><span class="line"><span class="class"><span class="title">caf</span>Ã©</span></span><br></pre></td></tr></table></figure>
<p>上面的运行结果说明，</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习笔记(使用for迭代)</title>
    <url>/Blog/2019/03/26/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BD%BF%E7%94%A8for%E8%BF%AD%E4%BB%A3/</url>
    <content><![CDATA[<h2 id="列表迭代"><a href="#列表迭代" class="headerlink" title="列表迭代"></a>列表迭代</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rabbits = [<span class="string">&#x27;Flopsy&#x27;</span>, <span class="string">&#x27;Mopsy&#x27;</span>, <span class="string">&#x27;Cottontail&#x27;</span>, <span class="string">&#x27;Peter&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> rabbit <span class="keyword">in</span> rabbits:</span><br><span class="line">    print(rabbit)</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Flopsy</span><br><span class="line">Mopsy</span><br><span class="line">Cottontail</span><br><span class="line">Peter</span><br></pre></td></tr></table></figure>

<h2 id="字符串迭代"><a href="#字符串迭代" class="headerlink" title="字符串迭代"></a>字符串迭代</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">word = <span class="string">&#x27;cat&#x27;</span></span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> word:</span><br><span class="line">	print(letter)</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c</span><br><span class="line">a</span><br><span class="line">t</span><br></pre></td></tr></table></figure>

<h2 id="字典的迭代"><a href="#字典的迭代" class="headerlink" title="字典的迭代"></a>字典的迭代</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">accusation = &#123;<span class="string">&#x27;room&#x27;</span>:<span class="string">&#x27;ballroom&#x27;</span>, <span class="string">&#x27;weapon&#x27;</span>:<span class="string">&#x27;lead pipe&#x27;</span>, <span class="string">&#x27;person&#x27;</span>:<span class="string">&#x27;Col. Mustard&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 对字典的Key进行迭代</span></span><br><span class="line"><span class="keyword">for</span> card <span class="keyword">in</span> accusation:</span><br><span class="line">	print(card)</span><br><span class="line"><span class="keyword">for</span> card <span class="keyword">in</span> accusation.keys():</span><br><span class="line">	print(card)</span><br><span class="line"><span class="comment"># 对字典的Value进行迭代</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> accusation.items():</span><br><span class="line">	print(item)</span><br><span class="line"><span class="keyword">for</span> card, contents <span class="keyword">in</span> accusation.items():</span><br><span class="line">	print(<span class="string">&#x27;Card&#x27;</span>, card, <span class="string">&#x27;has the contents&#x27;</span>, contents)</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">room</span><br><span class="line">weapon</span><br><span class="line">person</span><br><span class="line">room</span><br><span class="line">weapon</span><br><span class="line">person</span><br><span class="line">ballroom</span><br><span class="line">lead pipe</span><br><span class="line">Col. Mustard</span><br><span class="line">(<span class="string">&#x27;room&#x27;</span>, <span class="string">&#x27;ballroom&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;weapon&#x27;</span>, <span class="string">&#x27;lead pipe&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;person&#x27;</span>, <span class="string">&#x27;Col. Mustard&#x27;</span>)</span><br><span class="line">Card room has the contents ballroom</span><br><span class="line">Card weapon has the contents lead pipe</span><br><span class="line">Card person has the contents Col. Mustard</span><br></pre></td></tr></table></figure>


<h2 id="for-…-else-…-判断迭代是否正常结束-如果正常结束-执行else代码块-如果是break非正常结束-不执行else代码块"><a href="#for-…-else-…-判断迭代是否正常结束-如果正常结束-执行else代码块-如果是break非正常结束-不执行else代码块" class="headerlink" title="for … else … 判断迭代是否正常结束,如果正常结束,执行else代码块,如果是break非正常结束,不执行else代码块"></a>for … else … 判断迭代是否正常结束,如果正常结束,执行else代码块,如果是break非正常结束,不执行else代码块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cheeses = [<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> cheese <span class="keyword">in</span> cheeses:</span><br><span class="line">    <span class="keyword">if</span> cheese == <span class="string">&#x27;aa&#x27;</span>:</span><br><span class="line">        print(<span class="string">&#x27;找到目标break跳出循环&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;没找到&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;没有找到目标,执行了else的模块&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">没找到</span><br><span class="line">没找到</span><br><span class="line">没找到</span><br><span class="line">没有找到目标,执行了<span class="keyword">else</span>的模块</span><br></pre></td></tr></table></figure>


<h2 id="使用zip-进行并行迭代"><a href="#使用zip-进行并行迭代" class="headerlink" title="使用zip()进行并行迭代"></a>使用zip()进行并行迭代</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">days = [<span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>]</span><br><span class="line">fruits = [<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;peach&#x27;</span>]</span><br><span class="line">drinks = [<span class="string">&#x27;coffee&#x27;</span>, <span class="string">&#x27;tea&#x27;</span>, <span class="string">&#x27;beer&#x27;</span>]</span><br><span class="line">desserts = [<span class="string">&#x27;tiramiu&#x27;</span>, <span class="string">&#x27;ice cream&#x27;</span>, <span class="string">&#x27;pie&#x27;</span>, <span class="string">&#x27;pudding&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> day, fruit, drink, dessert <span class="keyword">in</span> <span class="built_in">zip</span>(days, fruits, drinks, desserts):</span><br><span class="line">    print(day, <span class="string">&quot;: drink&quot;</span>, drink, <span class="string">&quot;- eat&quot;</span>, fruit, <span class="string">&quot;- enjoy&quot;</span>, dessert)</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Card room has the contents ballroom</span><br><span class="line">Card weapon has the contents lead pipe</span><br><span class="line">Card person has the contents Col. Mustard</span><br></pre></td></tr></table></figure>


<h2 id="使用dict-和-zip-创建微型字典"><a href="#使用dict-和-zip-创建微型字典" class="headerlink" title="使用dict() 和 zip()创建微型字典"></a>使用dict() 和 zip()创建微型字典</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">english = <span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span></span><br><span class="line">french = <span class="string">&#x27;Lundi&#x27;</span>, <span class="string">&#x27;Mardi&#x27;</span>, <span class="string">&#x27;Mercredi&#x27;</span></span><br><span class="line">print(<span class="built_in">list</span>(<span class="built_in">zip</span>(english, french)))</span><br><span class="line">print(<span class="built_in">dict</span>(<span class="built_in">zip</span>(english, french)))</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(<span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Lundi&#x27;</span>), (<span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Mardi&#x27;</span>), (<span class="string">&#x27;Wednesday&#x27;</span>, <span class="string">&#x27;Mercredi&#x27;</span>)]</span><br><span class="line">&#123;<span class="string">&#x27;Monday&#x27;</span>: <span class="string">&#x27;Lundi&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>: <span class="string">&#x27;Mardi&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>: <span class="string">&#x27;Mercredi&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用range-生成自然数序列"><a href="#使用range-生成自然数序列" class="headerlink" title="使用range()生成自然数序列"></a>使用range()生成自然数序列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">	print(x)</span><br><span class="line">print(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>)))</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>


<h2 id="使用range-反向创建序列"><a href="#使用range-反向创建序列" class="headerlink" title="使用range()反向创建序列"></a>使用range()反向创建序列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">	print(x)</span><br><span class="line">print(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>)))</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>


<h2 id="获取从0到10的偶数"><a href="#获取从0到10的偶数" class="headerlink" title="获取从0到10的偶数"></a>获取从0到10的偶数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">11</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure>


<h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">number_list = [number <span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>)]</span><br><span class="line">print(number_list)</span><br><span class="line"></span><br><span class="line">number_list = [number<span class="number">-1</span> <span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>, <span class="number">16</span>)]</span><br><span class="line">print(number_list)</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]</span><br></pre></td></tr></table></figure>


<h2 id="创建1-5之间的奇数列表"><a href="#创建1-5之间的奇数列表" class="headerlink" title="创建1-5之间的奇数列表"></a>创建1-5之间的奇数列表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a_list = [number <span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>) <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">1</span>]</span><br><span class="line">print(a_list)</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<h2 id="创建1-5之间的偶数列表"><a href="#创建1-5之间的偶数列表" class="headerlink" title="创建1-5之间的偶数列表"></a>创建1-5之间的偶数列表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a_list = [number <span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>) <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">print(a_list)</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h2 id="多个for循环推导模拟嵌套循环"><a href="#多个for循环推导模拟嵌套循环" class="headerlink" title="多个for循环推导模拟嵌套循环"></a>多个for循环推导模拟嵌套循环</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rows = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">cols = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">cells = [(row, col) <span class="keyword">for</span> row <span class="keyword">in</span> rows <span class="keyword">for</span> col <span class="keyword">in</span> cols]</span><br><span class="line"><span class="keyword">for</span> cell <span class="keyword">in</span> cells:</span><br><span class="line">	print(cell)</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h2 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">word = <span class="string">&#x27;letters&#x27;</span></span><br><span class="line"><span class="comment"># 迭代单词中包含的字母，并计算该字母在单词中出现的次数</span></span><br><span class="line">letter_counts = &#123;letter: word.count(letter) <span class="keyword">for</span> letter <span class="keyword">in</span> word&#125;</span><br><span class="line">print(letter_counts)</span><br><span class="line"></span><br><span class="line">letter_counts = &#123;letter: word.count(letter) <span class="keyword">for</span> letter <span class="keyword">in</span> word&#125;</span><br><span class="line">print(letter_counts)</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;l&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;t&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;s&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;s&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;l&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;t&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a_set = &#123;number <span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>) <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">1</span>&#125;</span><br><span class="line">print(a_set)</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成器推导式"><a href="#生成器推导式" class="headerlink" title="生成器推导式"></a>生成器推导式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">number_thing = (number <span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 返回的是一个生成器对象</span></span><br><span class="line">print(<span class="built_in">type</span>(number_thing))</span><br><span class="line"><span class="comment"># 方式1：直接对生成器对象进行迭代，注意生成器对象只能被迭代一次，迭代完成之后被擦除</span></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> number_thing:</span><br><span class="line">    print(number)</span><br><span class="line"><span class="comment"># 方式2：将生成器对象转换成列表，然后再进行迭代</span></span><br><span class="line"><span class="comment"># number_list = list(number_thing)</span></span><br><span class="line"><span class="comment"># print(number_list)</span></span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">generator</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">1</span></span><br><span class="line"><span class="class">2</span></span><br><span class="line"><span class="class">3</span></span><br><span class="line"><span class="class">4</span></span><br><span class="line"><span class="class">5</span></span><br></pre></td></tr></table></figure>




















]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习笔记(函数)</title>
    <url>/Blog/2019/03/28/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="None作为布尔值和False是一样的，如何区分None和False"><a href="#None作为布尔值和False是一样的，如何区分None和False" class="headerlink" title="None作为布尔值和False是一样的，如何区分None和False?"></a>None作为布尔值和False是一样的，如何区分None和False?</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">thing = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> thing:</span><br><span class="line">    print(<span class="string">&quot;It&#x27;s some thing.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;It&#x27;s no thing.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> thing <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    print(<span class="string">&quot;It&#x27;s nothing&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;It&#x27;s something&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 你需要把None和不含任何值的空数据结构区分开来。0值的整型/浮点型、</span></span><br><span class="line"><span class="comment"># 空字符串(&#x27;&#x27;)、空列表([])、空元组((,))、空字典(&#123;&#125;)、</span></span><br><span class="line"><span class="comment"># 空集合(set())都等价于False，但是不等于None。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_none</span>(<span class="params">thing</span>):</span></span><br><span class="line">    <span class="keyword">if</span> thing <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="string">&quot;It&#x27;s None&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> thing:</span><br><span class="line">        print(<span class="string">&quot;It&#x27;s True&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;It&#x27;s False&quot;</span>)</span><br><span class="line"></span><br><span class="line">is_none(<span class="literal">None</span>)</span><br><span class="line">is_none(<span class="literal">True</span>)</span><br><span class="line">is_none(<span class="literal">False</span>)</span><br><span class="line">is_none(<span class="number">0</span>)</span><br><span class="line">is_none(<span class="number">0.0</span>)</span><br><span class="line">is_none(())</span><br><span class="line">is_none([])</span><br><span class="line">is_none(&#123;&#125;)</span><br><span class="line">is_none(<span class="built_in">set</span>())</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">It<span class="string">&#x27;s no thing.</span></span><br><span class="line"><span class="string">It&#x27;</span>s nothing</span><br><span class="line">It<span class="string">&#x27;s None</span></span><br><span class="line"><span class="string">It&#x27;</span>s <span class="literal">True</span></span><br><span class="line">It<span class="string">&#x27;s False</span></span><br><span class="line"><span class="string">It&#x27;</span>s <span class="literal">False</span></span><br><span class="line">It<span class="string">&#x27;s False</span></span><br><span class="line"><span class="string">It&#x27;</span>s <span class="literal">False</span></span><br><span class="line">It<span class="string">&#x27;s False</span></span><br><span class="line"><span class="string">It&#x27;</span>s <span class="literal">False</span></span><br><span class="line">It<span class="string">&#x27;s False</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习笔记-对象和类</title>
    <url>/Blog/2019/04/02/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="使用class定义类"><a href="#使用class定义类" class="headerlink" title="使用class定义类"></a>使用class定义类</h2><p>Python中使用class关键字来定义类，下面定义一个Person类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person():</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    hunter &#x3D; Person(&#39;Elmer Fudd&#39;)</span><br><span class="line">    print(hunter.name)</span><br></pre></td></tr></table></figure>
<p>其中 hunter = Person(‘Elmer Fudd’) 这一行代码执行的操作有:</p>
<ul>
<li><ol>
<li>查看Person类的定义</li>
</ol>
</li>
<li><ol start="2">
<li>在内存中创建一个新的对象</li>
</ol>
</li>
<li><ol start="3">
<li>调用对象的<code>__init__</code>方法,将这个新创建的对象作为self传入，并将另一个参数(‘Elmer Fudd’)作为name传入</li>
</ol>
</li>
<li><ol start="4">
<li>将name的值存入对象</li>
</ol>
</li>
<li><ol start="5">
<li>返回这个新的对象</li>
</ol>
</li>
<li><ol start="6">
<li>将名字hunter与这个对象关联<br>在类的定义中，<code>__init__</code>方法并不是必须的。只有当需要区分该类创建的不同对象时，才需要指定<code>__init__</code>方法。</li>
</ol>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>创建两个类，Car类和Yugo类，Yugo类继承自Car类，同时，Yugo类覆盖了Car类的exclaim方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exclaim</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;I&#x27;m a Car!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Yugo</span>(<span class="params">Car</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exclaim</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;I&#x27;m a Yugo! Much like a Car, but more Yugo-ish.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    give_me_a_car = Car()</span><br><span class="line">    give_me_a_yugo = Yugo()</span><br><span class="line">    give_me_a_car.exclaim()</span><br><span class="line">    give_me_a_yugo.exclaim()</span><br></pre></td></tr></table></figure>
<p>程序运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">I<span class="string">&#x27;m a Car!</span></span><br><span class="line"><span class="string">I&#x27;</span>m a Yugo! Much like a Car, but more Yugo-ish.</span><br></pre></td></tr></table></figure>
<p>在子类中，可以覆盖任何父类的方法，包括<code>__init__()</code>。下面使用代码来说明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MDPerson</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Doctor &quot;</span> + name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JDPerson</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name + <span class="string">&quot;, Esquire&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    person = Person(<span class="string">&#x27;Fudd&#x27;</span>)</span><br><span class="line">    doctor = MDPerson(<span class="string">&#x27;Fudd&#x27;</span>)</span><br><span class="line">    lawyer = JDPerson(<span class="string">&#x27;Fudd&#x27;</span>)</span><br><span class="line">    print(person.name)</span><br><span class="line">    print(doctor.name)</span><br><span class="line">    print(lawyer.name)</span><br></pre></td></tr></table></figure>
<p>程序的运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Fudd</span><br><span class="line">Doctor Fudd</span><br><span class="line">Fudd, Esquire</span><br></pre></td></tr></table></figure>
<p>子类可以添加父类中没有的方法。新增的方法子类对象可以调用，父类对象无法调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exclaim</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;I&#x27;m a Car!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Yugo</span>(<span class="params">Car</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exclaim</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;I&#x27;m a Yugo! Much like a Car, but more Yugo-ish.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">need_a_push</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;A little help here?&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    give_me_a_car = Car()</span><br><span class="line">    give_me_a_yugo = Yugo()</span><br><span class="line">    give_me_a_yugo.need_a_push()</span><br><span class="line">    give_me_a_car.need_a_push()</span><br></pre></td></tr></table></figure>
<p>程序的运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A little help here?</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/kris/PycharmProjects/pythons_demo/Python语言及其应用/对象和类/创建类.py&quot;</span>, line <span class="number">41</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    give_me_a_car.need_a_push()</span><br><span class="line">AttributeError: <span class="string">&#x27;Car&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;need_a_push&#x27;</span></span><br></pre></td></tr></table></figure>


<h2 id="使用super-从父类获得帮助。子类中想要调用父类的方法需要使用super"><a href="#使用super-从父类获得帮助。子类中想要调用父类的方法需要使用super" class="headerlink" title="使用super()从父类获得帮助。子类中想要调用父类的方法需要使用super()"></a>使用super()从父类获得帮助。子类中想要调用父类的方法需要使用super()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailPerson</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, email</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        self.email = email</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    bob = EmailPerson(<span class="string">&#x27;Bob Frapples&#x27;</span>, <span class="string">&#x27;bob@frapples.com&#x27;</span>)</span><br><span class="line">    print(bob.name)</span><br><span class="line">    print(bob.email)</span><br></pre></td></tr></table></figure>
<p>在子类中定义<code>__init__()</code>方法时，父类的<code>__init__()</code>方法会被覆盖。因此在子类中，父类的初始化方法并不会被自动调用，我们必须显式调用。这样有什么好处呢？这样处理的好处在于子类在实例化的时候会经过父类，如果父类中对name属性进行了业务处理，子类也会体现出来，否则父类的name将来需要修改还需要修改一遍子类的实现。<br>程序运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Bob Frapples</span><br><span class="line">bob@frapples.com</span><br></pre></td></tr></table></figure>
<p>Python使用self参数来找到正确对象所包含的特性和方法。通过下面的例子，说明Python在调用对象方法背后实际做的工作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exclaim</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;I&#x27;m a Car!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    car = Car()</span><br><span class="line">    car.exclaim()</span><br><span class="line">    Car.exclaim(car)</span><br></pre></td></tr></table></figure>
<p>Python在背后所做的事情：</p>
<ul>
<li><ol>
<li>查找car对象所属的类(Car)</li>
</ol>
</li>
<li><ol start="2">
<li>把car对象作为self参数传给Car类所包含的exclaim()方法<br>上面程序运行的结果：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">I<span class="string">&#x27;m a Car!</span></span><br><span class="line"><span class="string">I&#x27;</span>m a Car!</span><br></pre></td></tr></table></figure>
<h2 id="使用属性对特性进行访问和设置"><a href="#使用属性对特性进行访问和设置" class="headerlink" title="使用属性对特性进行访问和设置"></a>使用属性对特性进行访问和设置</h2>有一些面向对象的语言支持私有特性。这些特性无法从对象外部直接访问，我们需要编写getter和setter方法对这些私有特性进行读写操作。Python不需要getter和setter方法，因为Python里所有特性都是公开的。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, input_name</span>):</span></span><br><span class="line">        self.hidden_name = input_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;inside the getter&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.hidden_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span>(<span class="params">self, input_name</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;inside the setter&#x27;</span>)</span><br><span class="line">        self.hidden_name = input_name</span><br><span class="line"></span><br><span class="line">    name = <span class="built_in">property</span>(get_name, set_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fowl = Duck(<span class="string">&#x27;Howard&#x27;</span>)</span><br><span class="line">    print(fowl.name)</span><br><span class="line">    fowl.get_name()</span><br><span class="line">    fowl.name = <span class="string">&#x27;Daffy&#x27;</span></span><br><span class="line">    print(fowl.name)</span><br><span class="line">    fowl.set_name(<span class="string">&#x27;ZhangSan&#x27;</span>)</span><br><span class="line">    print(fowl.name)</span><br></pre></td></tr></table></figure>
这两个新方法在最后一行之前都与普通的getter和setter方法没有区别，而最后一行则把这两个方法定义为了name属性。property()的第一个参数是getter方法，第二个参数是setter方法。现在当你尝试访问Duck类对象的name属性时，get_name()会被自动调用，当然也可以显式调用get_name()方法，它就像普通的getter方法一样；当对name属性进行赋值的时候，set_name()方法会被调用，也可以显式调用set_name()方法。<br>运行的结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inside the getter</span><br><span class="line">Howard</span><br><span class="line">inside the getter</span><br><span class="line">inside the setter</span><br><span class="line">inside the getter</span><br><span class="line">Daffy</span><br><span class="line">inside the setter</span><br><span class="line">inside the getter</span><br><span class="line">ZhangSan</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<p>使用属性修饰符定义属性，@property 修饰符用于指示getter方法，@name.setter 用于指示setter方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, input_name</span>):</span></span><br><span class="line">        self.hidden_name = input_name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;inside the getter&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.hidden_name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self, input_name</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;inside the setter&#x27;</span>)</span><br><span class="line">        self.hidden_name = input_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fowl = Duck(<span class="string">&#x27;Howard&#x27;</span>)</span><br><span class="line">    print(fowl.name)</span><br><span class="line">    <span class="comment"># fowl.get_name()</span></span><br><span class="line">    fowl.name = <span class="string">&#x27;Daffy&#x27;</span></span><br><span class="line">    print(fowl.name)</span><br><span class="line">    <span class="comment"># fowl.set_name(&#x27;ZhangSan&#x27;)</span></span><br><span class="line">    print(fowl.name)</span><br><span class="line">    print(fowl.hidden_name)</span><br><span class="line">    fowl.hidden_name = <span class="string">&quot;lisi&quot;</span></span><br><span class="line">    print(fowl.hidden_name)</span><br></pre></td></tr></table></figure>
<p>仍然可以像之前一样访问属性一样访问name，但是这里没有了显式的get_name()和set_name()方法，所以我注掉了显式调用的代码，不然会报错。如果有人猜到在类的内部用的变量名是hidden_name,他仍然可以直接通过fowl.hidden_name进行读写操作。运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inside the getter</span><br><span class="line">Howard</span><br><span class="line">inside the setter</span><br><span class="line">inside the getter</span><br><span class="line">Daffy</span><br><span class="line">inside the getter</span><br><span class="line">Daffy</span><br><span class="line">Daffy</span><br><span class="line">lisi</span><br></pre></td></tr></table></figure>

<h2 id="使用名称重整保护私有变量"><a href="#使用名称重整保护私有变量" class="headerlink" title="使用名称重整保护私有变量"></a>使用名称重整保护私有变量</h2><p>前面的Duck例子中，为了隐藏内部的变量，我们曾将其命名为hidden_name。其实，Python对那些需要刻意隐藏在类内部的特性有自己的命名规范：由连续的两个下划线开头<code>(__)</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, input_name</span>):</span></span><br><span class="line">        self.__name = input_name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;inside the getter&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self, input_name</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;inside the setter&#x27;</span>)</span><br><span class="line">        self.__name = input_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    fowl = Duck(<span class="string">&#x27;Howard&#x27;</span>)</span><br><span class="line">    print(fowl.name)</span><br><span class="line">    fowl.name = <span class="string">&#x27;Donald&#x27;</span></span><br><span class="line">    print(fowl.name)</span><br><span class="line">    <span class="comment"># print(fowl.__name)</span></span><br><span class="line">    fowl.__name = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">    print(fowl.name)</span><br><span class="line">    print(fowl._Duck__name)</span><br></pre></td></tr></table></figure>
<p>这种命名规范本质上并没有把变量变成私有，但是Python确实将它的名字重整了，让外部的代码无法使用。最后一行打印可以成功绕过getter方法，但是这种命名重整能在一定程度上避免我们无意或有意的对变量进行直接访问。<br>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inside the getter</span><br><span class="line">Howard</span><br><span class="line">inside the setter</span><br><span class="line">inside the getter</span><br><span class="line">Donald</span><br><span class="line">inside the getter</span><br><span class="line">Donald</span><br><span class="line">Donald</span><br></pre></td></tr></table></figure>

<h2 id="方法的类型"><a href="#方法的类型" class="headerlink" title="方法的类型"></a>方法的类型</h2><ul>
<li>1.实例方法</li>
<li>2.类方法(@classmethod)</li>
<li>3.静态方法(@staticmethod)</li>
</ul>
<p>有些数据(变量) 和函数(方法)是类本身的一部分，还有一些是由类创建的实例的一部分。在类的定义中，以self作为第一个参数的方法都是实例方法。他们在创建自定义类时最常见。实例方法的首个参数是self，当它被调用时，Python会把调用该方法的对象作为self参数传入。与之相对，类方法会作用于整个类，对类作出的任何改变会对它的所有实例对象产生影响。在类定义内部，用前缀修饰符@classmethod指定的方法都是类方法。与实例方法类似，类方法的第一个参数是类本身。在Python中，这个参数常被写作cls,因为全程class是保留字，在这里我们无法使用。下面的例子中，我们为A定义一个类方法来记录一共多少个类A的对象被创建：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>():</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        A.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exclaim</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;I&#x27;m an A!&quot;</span>)</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kids</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(<span class="string">&quot;A has&quot;</span>, cls.count, <span class="string">&quot;little objects.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    easy_a = A()</span><br><span class="line">    breezy_a = A()</span><br><span class="line">    wheezy_a = A()</span><br><span class="line">    A.kids()</span><br><span class="line">    print(A.count)</span><br></pre></td></tr></table></figure>
<p>上面的代码中，在kids()方法中，我们使用的是cls.count，它与A.count的作用一样。<br>运行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A has <span class="number">3</span> little objects.</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>类定义中的方法还存在第三种类型，它既不会影响类，也不会影响对象。他们出现在类的定义中仅仅是为了方便，这种类型的方法被称为静态方法，使用@staticmethod修饰，它既不需要self参数也不需要class参数。下面的例子中的静态方法是一则CoyoteWeapon的广告:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoyoteWeapon</span>():</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">commercial</span>():</span></span><br><span class="line">        print(<span class="string">&#x27;This CoyoteWeapon has been brought to you by Acme&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    CoyoteWeapon.commercial()</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们甚至都不用创建任何CoyoteWeapon类的对象就可以调用这个方法，句法优雅不失风格!</p>
<h2 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h2><p>Python中有些特殊的方法，这些特殊方法的名称以双下划线<code>(__)</code>开头和结束，有时也被称作__魔术方法__。<br>下面列出常见的魔术方法：</p>
<ul>
<li>1.和比较相关的魔术方法</li>
</ul>
<div style="width:400px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2019/04/02/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/Snip20190418_1.png" class="" title="和比较相关的魔术方法截图"> </div>


<ul>
<li>2.和数学相关的魔术方法</li>
</ul>
<div style="width:400px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2019/04/02/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/Snip20190418_3.png" class="" title="和数学相关的魔术方法截图"> </div>


<ul>
<li>3.其他种类的魔术方法</li>
</ul>
<div style="width:400px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2019/04/02/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/Snip20190418_2.png" class="" title="其他种类的魔术方法截图"> </div>


<p>下面定义魔术方法<code>__eq__()</code>和<code>__str__()</code>、<code>__repr__()</code>,看看运行的结果如何。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, text</span>):</span></span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.text.lower() == other.text.lower()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.text</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Word(&quot;&#x27;</span>+self.text+<span class="string">&#x27;&quot;)&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    first = Word(<span class="string">&#x27;ha&#x27;</span>)</span><br><span class="line">    print(first)</span><br><span class="line">    print(first == Word(<span class="string">&#x27;Ha&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>定义<code>__eq__()</code>魔术方法方便同一类型的对象进行比较。定义 <code>__str__()</code>魔术方法方便print方法打印对象的相关信息，定义 <code>__repr__()</code> 魔术方法方便控制台输出对象的相关信息。<br>程序的运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ha</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby相关命令收集</title>
    <url>/Blog/2019/12/12/Ruby%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<p>RVM是一个命令行工具，它能帮你安装多个版本的Ruby，并切换不同的版本。</p>
<h2 id="安装RVM步骤"><a href="#安装RVM步骤" class="headerlink" title="安装RVM步骤"></a>安装RVM步骤</h2><p>1.安装rvm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3</span><br><span class="line">$ curl -sSL https://get.rvm.io | bash -s stable</span><br><span class="line"><span class="comment"># 如果上面的连接失败，可以尝试: </span></span><br><span class="line">$ curl -L https://raw.githubusercontent.com/wayneeseguin/rvm/master/binscripts/rvm-installer | bash -s stable</span><br></pre></td></tr></table></figure>
<p>2.载入rvm环境(新开Terminal,会自动重新载入)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ~/.rvm/scripts/rvm</span><br></pre></td></tr></table></figure>
<p>3.修改rvm下载的Ruby源，到RubyChina的镜像:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;ruby_url=https://cache.ruby-china.com/pub/ruby&quot;</span> &gt; ~/.rvm/user/db</span><br></pre></td></tr></table></figure>
<p>4.检查rvm是否安装正确</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rvm -v</span><br><span class="line">rvm 1.22.17 (stable) by Wayne E. Seguin &lt;wayneeseguin@gmail.com&gt;, Michal Papis &lt;mpapis@gmail.com&gt; [https://rvm.io/]</span><br></pre></td></tr></table></figure>
<h2 id="RVM常用指令"><a href="#RVM常用指令" class="headerlink" title="RVM常用指令"></a>RVM常用指令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ruby -v <span class="comment"># 查看ruby 版本</span></span><br><span class="line">$ rvm list known <span class="comment"># 列出已知的 ruby 版本</span></span><br><span class="line">$ rvm install 2.3.0 <span class="comment"># 选择指定 ruby 版本进行更新</span></span><br><span class="line">$ rvm get stable <span class="comment"># 更新 rvm</span></span><br><span class="line">$ rvm use 2.2.2 <span class="comment"># 切换到指定 ruby 版本</span></span><br><span class="line">$ rvm use 2.2.2 --default <span class="comment"># 设置指定 ruby 版本为默认版本</span></span><br><span class="line">$ rvm list <span class="comment"># 查询已安装的 ruby 版本</span></span><br><span class="line">$ rvm remove 1.9.2 <span class="comment"># 卸载移除 指定 ruby 版本</span></span><br><span class="line"></span><br><span class="line">$ curl -L https://get.rvm.io | bash -s stable <span class="comment"># 安装 rvm 环境</span></span><br><span class="line">$ curl -sSL https://get.rvm.io | bash -s stable --ruby <span class="comment"># 默认安装 rvm 最新版本</span></span><br><span class="line">$ curl -sSL https://get.rvm.io | bash -s stable --ruby=2.3.0 <span class="comment"># 安装 rvm 指定版本</span></span><br><span class="line">$ <span class="built_in">source</span> ~/.rvm/scripts/rvm <span class="comment"># 载入 rvm</span></span><br></pre></td></tr></table></figure>


<h2 id="Gem常用指令"><a href="#Gem常用指令" class="headerlink" title="Gem常用指令"></a>Gem常用指令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gem -v <span class="comment"># 查看 gem 版本</span></span><br><span class="line">$ gem <span class="built_in">source</span> <span class="comment"># 查看 gem 配置源</span></span><br><span class="line">$ gem <span class="built_in">source</span> -l <span class="comment"># 查看 gem 配置源目录</span></span><br><span class="line">$ gem sources -a url <span class="comment"># 添加 gem 配置源（url 需换成网址）</span></span><br><span class="line">$ gem sources --add url <span class="comment"># 添加 gem 配置源（url 需换成网址）</span></span><br><span class="line">$ gem sources -r url <span class="comment"># 删除 gem 配置源（url 需换成网址）</span></span><br><span class="line">$ gem sources --remove url <span class="comment"># 删除 gem 配置源（url 需换成网址）</span></span><br><span class="line">$ gem update <span class="comment"># 更新 所有包</span></span><br><span class="line">$ gem update --system <span class="comment"># 更新 Ruby Gems 软件</span></span><br><span class="line"></span><br><span class="line">$ gem install rake <span class="comment"># 安装 rake，从本地或远程服务器</span></span><br><span class="line">$ gem install rake --remote <span class="comment"># 安装 rake，从远程服务器</span></span><br><span class="line">$ gem install watir -v 1.6.2 <span class="comment"># 安装 指定版本的 watir</span></span><br><span class="line">$ gem install watir --version 1.6.2 <span class="comment"># 安装 指定版本的 watir</span></span><br><span class="line">$ gem uninstall rake <span class="comment"># 卸载 rake 包</span></span><br><span class="line">$ gem list d <span class="comment"># 列出 本地以 d 打头的包</span></span><br><span class="line">$ gem query -n <span class="string">&#x27;&#x27;</span>[0-9]<span class="string">&#x27;&#x27;</span> --<span class="built_in">local</span> <span class="comment"># 查找 本地含有数字的包</span></span><br><span class="line">$ gem search <span class="built_in">log</span> --both <span class="comment"># 查找 从本地和远程服务器上查找含有 log 字符串的包</span></span><br><span class="line">$ gem search <span class="built_in">log</span> --remoter <span class="comment"># 查找 只从远程服务器上查找含有 log 字符串的包</span></span><br><span class="line">$ gem search -r <span class="built_in">log</span> <span class="comment"># 查找 只从远程服务器上查找含有log字符串的包</span></span><br><span class="line"></span><br><span class="line">$ gem <span class="built_in">help</span> <span class="comment"># 提醒式的帮助</span></span><br><span class="line">$ gem <span class="built_in">help</span> install <span class="comment"># 列出 install 命令 帮助</span></span><br><span class="line">$ gem <span class="built_in">help</span> examples <span class="comment"># 列出 gem 命令使用一些例子</span></span><br><span class="line">$ gem build rake.gemspec <span class="comment"># 把 rake.gemspec 编译成 rake.gem</span></span><br><span class="line">$ gem check -v pkg/rake-0.4.0.gem <span class="comment"># 检测 rake 是否有效</span></span><br><span class="line">$ gem cleanup <span class="comment"># 清除 所有包旧版本，保留最新版本</span></span><br><span class="line">$ gem contents rake <span class="comment"># 显示 rake 包中所包含的文件</span></span><br><span class="line">$ gem dependency rails -v 0.10.1 <span class="comment"># 列出 与 rails 相互依赖的包</span></span><br><span class="line">$ gem environment <span class="comment"># 查看 gem 的环境</span></span><br><span class="line"></span><br><span class="line">$ sudo gem -v <span class="comment"># 查看 gem 版本（以管理员权限）</span></span><br><span class="line">$ sudo gem install cocoa pods <span class="comment"># 安装 CocoaPods（以管理员权限）</span></span><br><span class="line">$ sudo gem install cocoapods <span class="comment"># 安装 CocoaPods（以管理员权限）</span></span><br><span class="line">$ sudo gem install cocoapods --pre <span class="comment"># 安装 CocoaPods 至预览版（以管理员权限）</span></span><br><span class="line">$ sudo gem install cocoapods -v 1.4.0 <span class="comment"># 安装 CocoaPods 指定版本（以管理员权限）</span></span><br><span class="line">$ sudo gem update cocoapods <span class="comment"># 更新 CocoaPods 至最新版（以管理员权限）</span></span><br><span class="line">$ sudo gem update cocoapods --pre <span class="comment"># 更新 CocoaPods 至预览版（以管理员权限）</span></span><br><span class="line">$ sudo gem uninstall cocoapods -v 1.4.0 <span class="comment"># 移除 CocoaPods 指定版本（以管理员权限）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Catalina系统上执行上述命令会报无权限访问错误，需要使用下面的命令</span></span><br><span class="line">$ sudo gem install -n /usr/<span class="built_in">local</span>/bin cocoapods -v 1.9.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果安装失败的话，可以把需要安装的gem文件下载到本地然后在本地安装，使用命令</span></span><br><span class="line">$ sudo gem install -n /usr/<span class="built_in">local</span>/bin ~/Downloads/cocoapods-1.9.1.gem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cocoapods相关命令</span></span><br><span class="line"><span class="comment"># 更新Pod</span></span><br><span class="line">$ pod update --verbose --no-repo-update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除Pod的缓存</span></span><br><span class="line">$ pod cache clean --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除Pod库AAA的缓存</span></span><br><span class="line">$ pod cache clean AAA</span><br></pre></td></tr></table></figure>

<p>如果命令无法修改Gem源，可以手动修改Gem源，Gem的配置文件位置在<code>~/.gemrc</code>，编辑<code>~/.gemrc</code>文件，在:sources:配置行下添加<code>https://gems.ruby-china.com/</code>，这样就配置了ruby-china的Gem源。最终的配置文件如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">:backtrace: <span class="literal">false</span></span><br><span class="line">:bulk_threshold: 1000</span><br><span class="line">:sources:</span><br><span class="line">- https://gems.ruby-china.com</span><br><span class="line">:update_sources: <span class="literal">true</span></span><br><span class="line">:verbose: <span class="literal">true</span></span><br><span class="line">:ssl_verify_mode: 0</span><br><span class="line">concurrent_downloads: 8</span><br></pre></td></tr></table></figure>

<p>mac系统升级到Catalina时，使用cocoa pod时报错：-bash: /usr/local/bin/pod: /<br>System/Library/Frameworks/Ruby.framework/Versions/2.3/usr/bin/ruby: bad interpreter: No such file or directory”. </p>
<p>解决方案：<code>sudo gem install -n /usr/local/bin cocoapods -v 1.4.0</code></p>
<h2 id="Fastlane安装步骤"><a href="#Fastlane安装步骤" class="headerlink" title="Fastlane安装步骤"></a>Fastlane安装步骤</h2><p>指定版本安装fastlane</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">set</span> -ex</span><br><span class="line">$ gem uninstall fastlane --all --executables</span><br><span class="line">$ gem install fastlane --version 2.28.3 --no-document</span><br></pre></td></tr></table></figure>
<p>mac系统升级到Catalina时，安装Fastlane会报错，请尝试:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">set</span> -ex</span><br><span class="line">$ gem uninstall -n /usr/<span class="built_in">local</span>/bin fastlane --all --executables</span><br><span class="line">$ gem install -n /usr/<span class="built_in">local</span>/bin fastlane --version 2.28.3 --no-document</span><br></pre></td></tr></table></figure>
<p>如果尝试多次仍然无法安装Fastlane，可以尝试:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#brew cask安装fastlane的执行命令:</span></span><br><span class="line">$ brew cask uninstall fastlane</span><br><span class="line">$ brew cask install fastlane</span><br></pre></td></tr></table></figure>

<h2 id="Fastlane基本命令"><a href="#Fastlane基本命令" class="headerlink" title="Fastlane基本命令"></a>Fastlane基本命令</h2><p>初始化fastlane</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ fastlane init</span><br></pre></td></tr></table></figure>

<p>给fastlane安装插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ fastlane add_plugin git_pull_branch</span><br><span class="line">$ fastlane add_plugin fastlane-plugin-ipa_install_plist_generate</span><br></pre></td></tr></table></figure>

<p>使用fastlane进行重签名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">desc <span class="string">&quot;重签名&quot;</span></span><br><span class="line">lane :ad_hoc_resign <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 包的地址</span></span><br><span class="line">    ipa_path = <span class="string">&quot;/Users/kris/Desktop/wantong/Payload.ipa&quot;</span></span><br><span class="line">    signing_identity = <span class="string">&quot;iPhone Distribution: XXXXX Asia Limited&quot;</span></span><br><span class="line">    provision_profile = <span class="string">&quot;/Users/kris/Desktop/wantong/embedded.mobileprovision&quot;</span></span><br><span class="line"></span><br><span class="line">    result = resign(</span><br><span class="line">      ipa: ipa_path,</span><br><span class="line">      signing_identity: signing_identity,</span><br><span class="line">      provisioning_profile: provision_profile,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    puts result</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>


<h2 id="将homebrew的源换成阿里云，提高下载速度"><a href="#将homebrew的源换成阿里云，提高下载速度" class="headerlink" title="将homebrew的源换成阿里云，提高下载速度"></a>将homebrew的源换成阿里云，提高下载速度</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.替换brew.git:</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span></span><br><span class="line">$ git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.替换homebrew-core.git:</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core&quot;</span></span><br><span class="line">$ git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.替换homebrew-cask.git:</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span>/Library/Taps/homebrew/homebrew-cask</span><br><span class="line">$ git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.替换homebrew-bottles:</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line">$ <span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>

<h2 id="给Git添加代理访问，提高Git的访问速度"><a href="#给Git添加代理访问，提高Git的访问速度" class="headerlink" title="给Git添加代理访问，提高Git的访问速度"></a>给Git添加代理访问，提高Git的访问速度</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.编辑PAC用户自定义规则,添加以下地址:</span></span><br><span class="line">github.com</span><br><span class="line">githubusercontent.com</span><br><span class="line">githubassets.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.编辑~/.ssh/config文件，在文件中添加以下命令:</span></span><br><span class="line">Host github.com</span><br><span class="line">   HostName github.com</span><br><span class="line">   User git</span><br><span class="line">   ProxyCommand nc -v -x 127.0.0.1:1086 %h %p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.让配置立即生效:</span></span><br><span class="line">$ <span class="built_in">source</span> ~/.ssh/config</span><br></pre></td></tr></table></figure>

<h2 id="给终端添加代理访问"><a href="#给终端添加代理访问" class="headerlink" title="给终端添加代理访问"></a>给终端添加代理访问</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.编辑～/.bash_profile文件</span></span><br><span class="line">$ vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.在配置文件中加入如下内容，并保存</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:1087</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:1087</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.让配置立即生效</span></span><br><span class="line">$ <span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.测试代理是否成功</span></span><br><span class="line">$ curl cip.cc</span><br><span class="line">IP	: 192.3.249.219</span><br><span class="line">地址	: 美国  华盛顿州  西雅图</span><br><span class="line">运营商	: colocrossing.com</span><br><span class="line"></span><br><span class="line">数据二	: 美国</span><br><span class="line"></span><br><span class="line">数据三	: 美国华盛顿西雅图</span><br><span class="line"></span><br><span class="line">URL	: http://www.cip.cc/192.3.249.219</span><br></pre></td></tr></table></figure>

<h2 id="解决真机连接异常的问题"><a href="#解决真机连接异常的问题" class="headerlink" title="解决真机连接异常的问题"></a>解决真机连接异常的问题</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 杀掉USB服务</span></span><br><span class="line">$ sudo killall -STOP -c usbd</span><br></pre></td></tr></table></figure>


<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://ruby-china.org/wiki/install_ruby_guide">安装配置RVM环境</a><br><a href="https://stackoverflow.com/questions/20487849/how-to-downgrade-or-install-an-older-version-of-cocoapods">安装指定版本的cocoapods</a><br><a href="https://gist.github.com/neekey/4601713">手动安装RVM</a><br><a href="https://www.raydbg.com/2019/Homebrew-Update-Slow/">解决Homebrew下载更新极慢的问题</a><br><a href="http://skx926.me/2019/01/23/mac-proxy/">Mac上的各种代理设置</a><br><a href="https://www.jianshu.com/p/c44ef74d99f9">Mac安装Ruby版本管理器RVM</a></p>
]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>RunLoop</title>
    <url>/Blog/2020/06/29/RunLoop/</url>
    <content><![CDATA[<h2 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h2><p>RunLoop 运行循环，在程序运行过程中循环做一些事情。<br><strong>应用范畴</strong></p>
<ul>
<li>1、定时器（Timer）、PerformSelector</li>
<li>2、GCD </li>
<li>3、事件响应、手势识别、界面刷新</li>
<li>4、网络请求</li>
<li>5、AutoreleasePool</li>
</ul>
<h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>在我们命令行项目的<code>main</code>函数里面</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Hello, World!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完<code>NSLog(@&quot;Hello, World!&quot;);</code>这个代码以后，程序立即退出，但是在我们的正常项目<code>main</code>函数里面</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 如果用一个伪代码来简单的解释一下上面代码的意思，就是<br> <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">//休眠等待消息</span></span><br><span class="line">      <span class="keyword">int</span> message = sleep_and_wait();</span><br><span class="line">      <span class="comment">//处理消息</span></span><br><span class="line">      retVal = process_message(message)</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 程序不会马上退出，而是保持运行状态，RunLoop的基本作用：</p>
<ul>
<li>1、保持程序持续的运行</li>
<li>2、处理app中的各种事件（比如触摸事件，定时器事件）</li>
<li>3、节省CPU资源，提高程序性能，该做事的时候做事，改休息的时候休息</li>
</ul>
<p><strong>RunLoop对象</strong><br>iOS中有2套API来访问和使用RunLoop</p>
<ul>
<li>1、Fundataion：NSRunLoop</li>
<li>2、Core Fundataion：CFRunLoop</li>
</ul>
<p><code>NSRunLoop</code>是基于<code>CFRunLoop</code>的一层OC包装，<code>CFRunLoop</code>是开源的，地址:<a href="https://opensource.apple.com/tarballs/CF/">https://opensource.apple.com/tarballs/CF/</a></p>
<p><strong>RunLoop与线程</strong></p>
<ul>
<li>1、每一条线程都有唯一的一个与之对应的RunLoop对象</li>
<li>2、RunLoop保存在一个全局的Dictionary里，线程作为Key，RunLoop作为Value</li>
<li>3、线程刚创建时，并没有RunLoop对象，RunLoop会在第一次获取她时创建</li>
<li>4、RunLoop会在线程结束的时候销毁</li>
<li>5、主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop</li>
</ul>
<p><strong>获取RunLoop对象</strong></p>
<ul>
<li>1、Fundation<ul>
<li>1、获取当前线程的RunLoop对象<code>[NSRunLoop currentRunLoop]</code></li>
<li>2、获取主线程的RunLoop对象<code>[NSRunLoop mainRunLoop]</code></li>
</ul>
</li>
<li>2、Core Foundation<ul>
<li>1、获取当前线程的RunLoop对象<code>CFRunLoopGetCurrent()</code></li>
<li>2、获取主线程的RunLoop对象<code>CFRunLoopGetMain()</code></li>
</ul>
</li>
</ul>
<p><strong>RunLoop相关类</strong><br>Core Foundation中关于RunLoop一共有5个类</p>
<ul>
<li>1、CFRunLoopRef</li>
<li>2、CFRunLoopModeRef</li>
<li>3、CFRunLoopSourceRef</li>
<li>4、CFRunLoopTimerRef</li>
<li>5、CFRunLoopObserverRef</li>
</ul>
<p>我们下载<code>RunLoop</code>，然后搜索<code>CFRunLoop</code>的组成</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">  <span class="built_in">CFRuntimeBase</span> _base;</span><br><span class="line">  pthread_mutex_t _lock;            <span class="comment">/* locked for accessing mode list */</span></span><br><span class="line">  __CFPort _wakeUpPort;            <span class="comment">// used for CFRunLoopWakeUp </span></span><br><span class="line">  Boolean _unused;</span><br><span class="line">  <span class="keyword">volatile</span> _per_run_data *_perRunData;              <span class="comment">// reset for runs of the run loop</span></span><br><span class="line">  pthread_t _pthread;</span><br><span class="line">  uint32_t _winthread;</span><br><span class="line">  <span class="built_in">CFMutableSetRef</span> _commonModes;</span><br><span class="line">  <span class="built_in">CFMutableSetRef</span> _commonModeItems;</span><br><span class="line">  <span class="built_in">CFRunLoopModeRef</span> _currentMode;</span><br><span class="line">  <span class="built_in">CFMutableSetRef</span> _modes;</span><br><span class="line">  <span class="keyword">struct</span> _block_item *_blocks_head;</span><br><span class="line">  <span class="keyword">struct</span> _block_item *_blocks_tail;</span><br><span class="line">  <span class="built_in">CFAbsoluteTime</span> _runTime;</span><br><span class="line">  <span class="built_in">CFAbsoluteTime</span> _sleepTime;</span><br><span class="line">  <span class="built_in">CFTypeRef</span> _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们打印一下<code>NSLog(@&quot;%@&quot;,[NSRunLoop currentRunLoop]);</code></p>
<p>其中主要的有下面几个:</p>
<img src="/Blog/2020/06/29/RunLoop/RunLoop1.png" class="" title="RunLoop">

<ul>
<li>1、<code>_pthread</code>记录当前线程</li>
<li>2、<code>_commonModes</code></li>
<li>3、<code>_commonModeItems</code></li>
<li>4、<code>_currentMode</code>,当前mode类型</li>
<li>5、<code>_modes</code> 存放CFRunLoop里面的所有mode</li>
</ul>
<p>我们在RunLoop源码中搜索<code>CFRunLoopMode</code>来查看一下CFRunLoopMode都存放了哪些东西:</p>
<img src="/Blog/2020/06/29/RunLoop/RunLoop2.png" class="" title="RunLoop">

<ul>
<li>1、Source0：<ul>
<li>处理触摸事件，</li>
<li>performSelector:onThread:</li>
</ul>
</li>
<li>2、Source1：<ul>
<li>基于Port的线程间通信，</li>
<li>系统事件的捕捉</li>
</ul>
</li>
<li>3、Timer ：<ul>
<li>NSTimer，</li>
<li>performSelector:withObject:afterDelay:</li>
</ul>
</li>
<li>4、Observers：<ul>
<li>用于监听RunLoop的状态</li>
<li>UI刷新</li>
<li>Autorelease pool（BeforeWaiting）</li>
</ul>
</li>
</ul>
<p>我们来简单的证明一下<code>Source0</code>,我们随便写一个<code>touchesBegan</code>触摸事件，然后在里面打一个断点，<code>bt</code>指令就是打印线程执行的所有方法</p>
<img src="/Blog/2020/06/29/RunLoop/RunLoop4.png" class="" title="RunLoop">

<p>我们可以在线程执行方法中可以发现，在调用RunLoop相关方法的时候，第一个是调用的<code>__CFRunLoopDoSources0</code></p>
<p>RunLoop里面会有多个Mode，但是只有一个<code>_currentMode</code></p>
<img src="/Blog/2020/06/29/RunLoop/RunLoop3.png" class="" title="RunLoop">



<p><strong>CFRunLoopModeRef</strong></p>
<ul>
<li>1、CFRunLoopModeRef代表着RunLoop的运行模式</li>
<li>2、一个RunLoop包含若干个<code>Mode</code>，每个<code>Mode</code>又包含若干个<code>Source0/Source1/Timer/Observer</code></li>
<li>3、RunLoop启动的时候只能选择其中一个Mode作为currentMode</li>
<li>4、如果要切换Mode，只能退出当前Loop，再重新选择一个Mode进入，不同组的<code>Source0/Source1/Timer/Observer</code>互不影响</li>
<li>5、如果Mode里面没有任何<code>Source0/Source1/Timer/Observer</code>，RunLoop会立刻退出</li>
</ul>
<p><strong>CFRunLoopModeRef常见的Mode</strong></p>
<ul>
<li>1、KCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App的默认Mode，通常主线程是在这个Mode下运行的</li>
<li>2、UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li>
</ul>
<p>获取当前Mode</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopMode</span> mode = <span class="built_in">CFRunLoopCopyCurrentMode</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br></pre></td></tr></table></figure>


<p><strong>CFRunLoopObserverRef</strong></p>
<p>RunLoop的几种状态</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">  kCFRunLoopEntry = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>), <span class="comment">//即将进入runloop</span></span><br><span class="line">  kCFRunLoopBeforeTimers = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>), <span class="comment">//即将处理timer</span></span><br><span class="line">  kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">//即将处理source</span></span><br><span class="line">  kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">//即将进入休眠</span></span><br><span class="line">  kCFRunLoopAfterWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>),  <span class="comment">//刚从休眠中唤醒</span></span><br><span class="line">  kCFRunLoopExit = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>),          <span class="comment">//即将退出Loop</span></span><br><span class="line">  kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以添加一个Observer监听RunLoop的所有状态，代码如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Observer</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault,kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">    <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopEntry&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeTimers&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeSources&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeWaiting&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopAfterWaiting&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopExit&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 添加Observer到RunLoop中</span></span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="built_in">CFRelease</span>(observer);</span><br></pre></td></tr></table></figure>

<p>我们运行上面代码，然后查看打印结果:</p>
<img src="/Blog/2020/06/29/RunLoop/RunLoop6.png" class="" title="RunLoop">

<p>在没有任何事件处理的情况下，最终RunLoop的活动状态为<code>kCFRunLoopBeforeWaiting</code>即将进入休眠。</p>
<p>既然我们可以监听到了<code>RunLoop</code>的<code>Mode</code>变化情况，那么我们就可以打印一下<code>KCFRunLoopDefaultMode</code>和<code>UITrackingRunLoopMode</code>的切换情况了。</p>
<p>我们在view上随便拉一个<code>UITextView</code>,然后滚动<code>UITextView</code><br>监听代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建observer</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">    <span class="keyword">case</span> kCFRunLoopEntry: &#123;</span><br><span class="line">      <span class="built_in">CFRunLoopMode</span> mode = <span class="built_in">CFRunLoopCopyCurrentMode</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopEntry - %@&quot;</span>, mode);</span><br><span class="line">      <span class="built_in">CFRelease</span>(mode);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> kCFRunLoopExit: &#123;</span><br><span class="line">      <span class="built_in">CFRunLoopMode</span> mode = <span class="built_in">CFRunLoopCopyCurrentMode</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopExit - %@&quot;</span>, mode);</span><br><span class="line">      <span class="built_in">CFRelease</span>(mode);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加observer到runloop中</span></span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="built_in">CFRelease</span>(observer);</span><br></pre></td></tr></table></figure>
<p>打印结果为:</p>
<img src="/Blog/2020/06/29/RunLoop/RunLoop5.png" class="" title="RunLoop">

<ul>
<li>1、在刚开始滚动<code>UITextView</code>的时候，先退出<code>kCFRunLoopDefaultMode</code>，所以默认应该就是<code>kCFRunLoopDefaultMode</code></li>
<li>2、在滚动中，进入<code>UITrackingRunLoopMode</code></li>
<li>3、在滚动结束，先退出<code>UITrackingRunLoopMode</code>，然后在进入<code>kCFRunLoopDefaultMode</code></li>
</ul>
<h3 id="RunLoop的运行逻辑"><a href="#RunLoop的运行逻辑" class="headerlink" title="RunLoop的运行逻辑:"></a>RunLoop的运行逻辑:</h3><img src="/Blog/2020/06/29/RunLoop/RunLoop7.png" class="" title="RunLoop">


<p>每次运行RunLoop，线程的RunLoop会自动处理之前未处理的消息，并通知相关的观察者。具体顺序</p>
<ul>
<li>1、通知观察者（observers）RunLoop即将启动</li>
<li>2、通知观察者（observers）任何即将要开始的定时器</li>
<li>3、通知观察者（observers）即将处理source0事件</li>
<li>4、处理source0</li>
<li>5、如果有source1，跳到第9步</li>
<li>6、通知观察者（observers）线程即将进入休眠</li>
<li>7、将线程置于休眠知道任一下面的事件发生<ul>
<li>1、source0事件触发</li>
<li>2、定时器启动</li>
<li>3、外部手动唤醒</li>
</ul>
</li>
<li>8、通知观察者（observers）线程即将唤醒</li>
<li>9、处理唤醒时收到的时间，之后跳回2<ul>
<li>1、如果用户定义的定时器启动，处理定时器事件</li>
<li>2、如果source0启动，传递相应的消息</li>
</ul>
</li>
<li>10、通知观察者RunLoop结束</li>
</ul>
<p><strong>RunLoop休眠原理</strong></p>
<img src="/Blog/2020/06/29/RunLoop/RunLoop8.png" class="" title="RunLoop">

<p>在RunLoop即将休眠的时候，通过<code>mach_msg()</code>方法来让软件和硬件交互</p>
<ul>
<li>1、即将休眠的时候，程序调用<code>mach_msg()</code>传递给CPU，告诉CPU停止运行</li>
<li>2、即将启动RunLoop的时候，程序调用<code>mach_msg()</code>传递给CPU，告诉CPU开始工作</li>
</ul>
<h3 id="RunLoop简单应用"><a href="#RunLoop简单应用" class="headerlink" title="RunLoop简单应用"></a>RunLoop简单应用</h3><h4 id="滚动视图上面NSTimer不失效"><a href="#滚动视图上面NSTimer不失效" class="headerlink" title="滚动视图上面NSTimer不失效"></a>滚动视图上面NSTimer不失效</h4><p>我们写一个简单的定时器,然后视图上面创建一个TextView,然后滚动TextView</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>,count++);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<img src="/Blog/2020/06/29/RunLoop/RunLoop9.png" class="" title="RunLoop">

<p>我们观察可以发现在打印的第二秒和第三秒之间其实相差了<code>14s</code>，因为一个线程只会有一个RunLoop，默认情况下是<code>kCFRunLoopDefaultMode</code>，在滚动<code>UITextView</code>的时候，RunLoop切换到了<code>UITrackingRunLoopMode</code>,这个时候定时器就会停止，在滚动<code>UITextView</code>结束的时候，RunLoop切换到了<code>kCFRunLoopDefaultMode</code>，定时器继续开始启动了。</p>
<p>解决这个问题的方法就是把这个<code>NSTimer</code>添加到两种RunLoop中</p>
<ul>
<li>1、<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">UITrackingRunLoopMode</span>];</span><br></pre></td></tr></table></figure></li>
<li>2、还有一个NSRunLoopCommonModes，我们用<code>NSRunLoopCommonModes</code>标记的时候，就可以实现上面效果<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>
NSRunLoopCommonModes并不是一个真的模式，它只是一个标记,timer能在_commonModes数组中存放的模式下工作</li>
</ul>
<h4 id="线程保活-常驻线程"><a href="#线程保活-常驻线程" class="headerlink" title="线程保活(常驻线程)"></a>线程保活(常驻线程)</h4><p>开始之前先介绍几个概念</p>
<ul>
<li>1、线程刚创建时，并没有RunLoop对象，RunLoop会在第一次获取她时创建<ul>
<li>1、获取线程：[NSRunLoop currentRunLoop]</li>
<li>2、获取线程：CFRunLoopGetCurrent()</li>
</ul>
</li>
<li>2、启动RunLoop的三种方法<ul>
<li>1、<code>- (void)run; </code>,<br>  这种方法runloop会一直运行下去，在此期间会处理来自输入源的数据，并且会在NSDefaultRunLoopMode模式下重复调用runMode:beforeDate:方法；</li>
<li>2、<code>- (void)runUntilDate:(NSDate *)limitDate；</code><br>  可以设置超时时间，在超时时间到达之前，runloop会一直运行，在此期间runloop会处理来自输入源的数据，并且也会在NSDefaultRunLoopMode模式下重复调用runMode:beforeDate:方法；</li>
<li>3、<code>- (void)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;</code><br>  runloop会运行一次，超时时间到达或者第一个input source被处理，则runloop就会退出</li>
</ul>
</li>
<li>3、退出RunLoop的方式<ul>
<li>1、启动方式的退出方法，如果runloop没有input sources或者附加的timer，runloop就会退出。</li>
<li>2、启动方式runUntilDate，可以通过设置超时时间来退出runloop。</li>
<li>3、启动方式runMode:beforeDate，通过这种方式启动，runloop会运行一次，当超时时间到达或者第一个输入源被处理，runloop就会退出。</li>
</ul>
</li>
</ul>
<p>如果我们想控制runloop的退出时机，而不是在处理完一个输入源事件之后就退出，那么就要重复调用runMode:beforeDate:，<br>具体可以参考苹果文档给出的方案，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSRunLoop</span> *myLoop  = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">myPort = (<span class="built_in">NSMachPort</span> *)[<span class="built_in">NSMachPort</span> port];</span><br><span class="line">[myLoop addPort:_port forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"><span class="built_in">BOOL</span> isLoopRunning = <span class="literal">YES</span>; <span class="comment">// global</span></span><br><span class="line"><span class="keyword">while</span> (isLoopRunning &amp;&amp; [myLoop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]]);</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关闭runloop的地方</span></span><br><span class="line">- (<span class="keyword">void</span>)quitLoop &#123;</span><br><span class="line">  isLoopRunning = <span class="literal">NO</span>;</span><br><span class="line">  <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>1、讲讲RunLoop项目中有用到吗？</p>
<ul>
<li>1、定时器切换的时候，为了保证定时器的准确性，需要添加runLoop</li>
<li>2、在聊天界面，我们需要持续的把聊天信息存到数据库中，这个时候需要开启一个保活线程，在这个线程中处理</li>
</ul>
<p>2、RunLoop内部实现逻辑？</p>
<ul>
<li>1、通知观察者（observers）RunLoop即将启动</li>
<li>2、通知观察者（observers）任何即将要开始的定时器</li>
<li>3、通知观察者（observers）即将处理source0事件</li>
<li>4、处理source0</li>
<li>5、如果有source1，跳到第9步</li>
<li>6、通知观察者（observers）线程即将进入休眠</li>
<li>7、将线程置于休眠知道任一下面的事件发生</li>
<li>1、source0事件触发</li>
<li>2、定时器启动</li>
<li>3、外部手动唤醒</li>
<li>8、通知观察者（observers）线程即将唤醒</li>
<li>9、处理唤醒时收到的时间，之后跳回2</li>
<li>1、如果用户定义的定时器启动，处理定时器事件</li>
<li>2、如果source0启动，传递相应的消息</li>
<li>10、通知观察者RunLoop结束</li>
</ul>
<p>3、RunLoop和线程的关系？</p>
<ul>
<li>1、每一条线程都有唯一的一个与之对应的RunLoop对象</li>
<li>2、RunLoop保存在一个全局的Dictionary里，线程作为Key，RunLoop作为Value</li>
<li>3、线程刚创建时，并没有RunLoop对象，RunLoop会在第一次获取她时创建</li>
<li>4、RunLoop会在线程结束的时候销毁</li>
<li>5、主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop</li>
</ul>
<p>4、RunLoop有几种状态</p>
<p>kCFRunLoopEntry = (1UL &lt;&lt; 0),   //   即将进入RunLoop<br>kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理Timer<br>kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理Source<br>kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠<br>kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),// 刚从休眠中唤醒<br>kCFRunLoopExit = (1UL &lt;&lt; 7),// 即将退出RunLoop</p>
<p>5、RunLoop的mode的作用<br>系统注册了5中mode</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">kCFRunLoopDefaultMode <span class="comment">//App的默认Mode，通常主线程是在这个Mode下运行</span></span><br><span class="line"><span class="built_in">UITrackingRunLoopMode</span> <span class="comment">//界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</span></span><br><span class="line"><span class="built_in">UIInitializationRunLoopMode</span> <span class="comment">// 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用</span></span><br><span class="line">GSEventReceiveRunLoopMode <span class="comment">// 接受系统事件的内部 Mode，通常用不到</span></span><br><span class="line">kCFRunLoopCommonModes <span class="comment">//这是一个占位用的Mode，不是一种真正的Mode</span></span><br></pre></td></tr></table></figure>
<p>但是我们只能使用两种mode</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">kCFRunLoopDefaultMode <span class="comment">//App的默认Mode，通常主线程是在这个Mode下运行</span></span><br><span class="line"><span class="built_in">UITrackingRunLoopMode</span> <span class="comment">//界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.jianshu.com/p/d260d18dd551">iOS 多线程：『RunLoop』详尽总结</a></p>
<p><a href="http://www.cocoachina.com/ios/20180515/23380.html">iOS RunLoop入门小结</a></p>
<p><a href="https://www.jianshu.com/p/f3079ea36775">iOS-Runloop常驻线程／性能优化</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>SourceTree commit数据后，想撤销刚刚的commit操作，并将修改的文件恢复到已暂存状态</title>
    <url>/Blog/2020/04/04/SourceTree-commit%E6%95%B0%E6%8D%AE%E5%90%8E%EF%BC%8C%E6%83%B3%E6%92%A4%E9%94%80%E5%88%9A%E5%88%9A%E7%9A%84commit%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%B9%B6%E5%B0%86%E4%BF%AE%E6%94%B9%E7%9A%84%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E5%88%B0%E5%B7%B2%E6%9A%82%E5%AD%98%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<p>在工作中有时会遇到这样的情况，修改完文件之后，因为各种原因，误操作导致文件本提交，但是还没有push到远端，希望撤回之前的修改，并且将改动保存到暂存区，方便再次修改或贮存操作。</p>
<p>问题截图如下:</p>
<img src="/Blog/2020/04/04/SourceTree-commit%E6%95%B0%E6%8D%AE%E5%90%8E%EF%BC%8C%E6%83%B3%E6%92%A4%E9%94%80%E5%88%9A%E5%88%9A%E7%9A%84commit%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%B9%B6%E5%B0%86%E4%BF%AE%E6%94%B9%E7%9A%84%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E5%88%B0%E5%B7%B2%E6%9A%82%E5%AD%98%E7%8A%B6%E6%80%81/1.png" class="" title="误操作commit的截图">

<p>使用<code>git log</code>查看一下日志，截图如下：</p>
<img src="/Blog/2020/04/04/SourceTree-commit%E6%95%B0%E6%8D%AE%E5%90%8E%EF%BC%8C%E6%83%B3%E6%92%A4%E9%94%80%E5%88%9A%E5%88%9A%E7%9A%84commit%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%B9%B6%E5%B0%86%E4%BF%AE%E6%94%B9%E7%9A%84%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E5%88%B0%E5%B7%B2%E6%9A%82%E5%AD%98%E7%8A%B6%E6%80%81/2.png" class="" title="查看git提交日志">



<p>解决方法是，使用命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --soft HEAD^</span><br></pre></td></tr></table></figure>

<p>使用上面的命令，可以将刚刚commit的数据撤销回来，改动的数据不会丢失。命令撤销commit的截图:</p>
<img src="/Blog/2020/04/04/SourceTree-commit%E6%95%B0%E6%8D%AE%E5%90%8E%EF%BC%8C%E6%83%B3%E6%92%A4%E9%94%80%E5%88%9A%E5%88%9A%E7%9A%84commit%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%B9%B6%E5%B0%86%E4%BF%AE%E6%94%B9%E7%9A%84%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E5%88%B0%E5%B7%B2%E6%9A%82%E5%AD%98%E7%8A%B6%E6%80%81/3.png" class="" title="命令撤销commit的截图">

<p>关掉SourceTree，重新打开，发现commit的状态已经没有了，数据已经恢复到commit之前的状态。</p>
<img src="/Blog/2020/04/04/SourceTree-commit%E6%95%B0%E6%8D%AE%E5%90%8E%EF%BC%8C%E6%83%B3%E6%92%A4%E9%94%80%E5%88%9A%E5%88%9A%E7%9A%84commit%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%B9%B6%E5%B0%86%E4%BF%AE%E6%94%B9%E7%9A%84%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E5%88%B0%E5%B7%B2%E6%9A%82%E5%AD%98%E7%8A%B6%E6%80%81/4.png" class="" title="SourceTree撤销commit之后的截图">

<p>上述命令在使用时是可以加参数的具体参数如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HEAD^    // 意思是撤销上一个commit提交,也可以写成 HEAD^1</span><br><span class="line">HEAD^~2  // 撤销之前的2次commit提交</span><br><span class="line">--soft   // 不删除工作空间改动代码，撤销commit，不撤销git add .</span><br><span class="line">--hard   // 删除工作空间改动代码，撤销commit，撤销git add .</span><br><span class="line">--mixed  // 不删除工作空间改动代码，撤销commit，并且撤销git add .操作。这个为默认参数，git reset --mixed HEAD^和 git reset HEAD^效果是一样的。</span><br></pre></td></tr></table></figure>

<p>如果commit注释写错了，只是想改一下注释，需要执行以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>

<p>此时会进入默认vim编辑器，修改注释完毕后保存就好了。</p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://blog.csdn.net/w958796636/article/details/53611133">git使用情景2：commit之后，想撤销commit</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>SourceTree 回滚项目(本地回滚和远程回滚)</title>
    <url>/Blog/2020/10/22/SourceTree-%E5%9B%9E%E6%BB%9A%E9%A1%B9%E7%9B%AE-%E6%9C%AC%E5%9C%B0%E5%9B%9E%E6%BB%9A%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%9B%9E%E6%BB%9A/</url>
    <content><![CDATA[<p>在使用SourceTree来管理Git项目的时候，有时需要回滚项目，具体的回滚操作包含本地回滚和远程回滚。<strong>建议回滚前先做好代码备份。</strong></p>
<h2 id="本地回滚"><a href="#本地回滚" class="headerlink" title="本地回滚"></a>本地回滚</h2><p>使用命令<code>git reset</code>进行本地回滚操作，本地回滚操作一步即可完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 回退到指定的提交版本，22f8aae 为某次提交的提交号。</span></span><br><span class="line">$ git reset --hard   22f8aae  </span><br><span class="line"></span><br><span class="line"><span class="comment">#（回退3次提交）</span></span><br><span class="line">$ git reset --hard HEAD~3 //（回退3次提交）</span><br></pre></td></tr></table></figure>
<p>–hard：本地的源码和本地未提交的源码都会回退到某个版本，包括commit内容，和git自己对代码的索引都会回退到某个版本，any local changes will be lost。<br>–soft：保留源码，只能回退到commit信息到某个版本，不涉及到index的回退，如果还需要提交，直接commit即可。比如我选择soft方式来进行回退，我的本地代码和本地新添加的尚未commit的代码都没有改变。<br>–mixed：会保留源码，只是将git commit和index信息回退到某个版本。</p>
<h2 id="远程回滚"><a href="#远程回滚" class="headerlink" title="远程回滚"></a>远程回滚</h2><p>远程回滚的操作流程是，先回滚本地操作，然后将本地的修改强行push到远程仓库。具体操作分为以下2步：</p>
<p>1.在需要回滚的提交记录上<code>右键</code>选择<code>将master重置到这次提交</code>，选择重置（强行合并）到需要回滚的历史节点。</p>
<img src="/Blog/2020/10/22/SourceTree-%E5%9B%9E%E6%BB%9A%E9%A1%B9%E7%9B%AE-%E6%9C%AC%E5%9C%B0%E5%9B%9E%E6%BB%9A%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%9B%9E%E6%BB%9A/1.png" class="" title="回滚本地操作截图">

<p>2.打开终端，cd到项目目录，执行<code>git push origin master -f</code>，即可。<br>origin：远程仓库名<br>master：分支名称<br>-f：force，意为强制、强行</p>
<p>3.如果出现<code> ! [remote rejected]   master -&gt; master (pre-receive hook declined)</code>错误，需要去gitlab网站去除master分支保护，才可以强制推送。<br>具体错误信息如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin master -f</span><br><span class="line">总共 0 （差异 0），复用 0 （差异 0）</span><br><span class="line">remote: GitLab: You are not allowed to force push code to a protected branch on this project.</span><br><span class="line">To https://test.com.cn/test.git</span><br><span class="line"> ! [remote rejected]   master -&gt; master (pre-receive hook declined)</span><br><span class="line">error: 推送一些引用到 <span class="string">&#x27;https://test.com.cn/test.git&#x27;</span> 失败</span><br></pre></td></tr></table></figure>
<p>需要去到gitlab的网站上去除master分支保护。</p>
<img src="/Blog/2020/10/22/SourceTree-%E5%9B%9E%E6%BB%9A%E9%A1%B9%E7%9B%AE-%E6%9C%AC%E5%9C%B0%E5%9B%9E%E6%BB%9A%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%9B%9E%E6%BB%9A/2.png" class="" title="去除master分支保护截图">

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/lovesummerforever/article/details/71526900">git 远程代码回滚master</a><br><a href="https://blog.csdn.net/u012373815/article/details/78142806">使用sourceTree回滚git代码到历史节点</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift可选项</title>
    <url>/Blog/2020/06/06/Swift%E5%8F%AF%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<img src="/Blog/2020/06/06/Swift%E5%8F%AF%E9%80%89%E9%A1%B9/result.png" class="" title="可选项思维导图">

<h2 id="可选项是什么？"><a href="#可选项是什么？" class="headerlink" title="可选项是什么？"></a>可选项是什么？</h2><blockquote>
<p>You use optionals in situations where a value may be absent. An optional represents two possibilities: Either there is a value, and you can unwrap the optional to access that value, or there isn’t a value at all.</p>
</blockquote>
<p>可选项，一般也叫可选类型，它代表2种可能，一种可能是有值，一种可能是没值。没值代表值缺失的情况，使用<code>nil</code>来表示，有值的时候，可以通过解包获取真正的值。也可以手动将值设置为<code>nil</code>。Swift中的可选项适用于对象类型、结构体类型、枚举类型和基础类型。而Objective-C中只有对象类型的值可以为<code>nil</code>。</p>
<h2 id="如何定义可选项？"><a href="#如何定义可选项？" class="headerlink" title="如何定义可选项？"></a>如何定义可选项？</h2><p>在类型名称后面加问号<code>？</code>来定义一个可选项。可选项的值默认为<code>nil</code>，非可选项没有默认值，需要初始化给定默认值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name: <span class="type">String?</span> = <span class="string">&quot;张三&quot;</span> <span class="comment">// 可选项</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">String</span>(describing: name))</span><br><span class="line">name = <span class="literal">nil</span> <span class="comment">// 可选项可以设置成nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name1: <span class="type">String</span> = <span class="string">&quot;李四&quot;</span> <span class="comment">// 非可选项</span></span><br><span class="line"><span class="built_in">print</span>(name1)</span><br><span class="line"><span class="comment">// 非可选项设置nil，会报错&quot;&#x27;nil&#x27; cannot be assigned to type &#x27;String&#x27;&quot;</span></span><br><span class="line"><span class="comment">// name1 = nil</span></span><br></pre></td></tr></table></figure>
<p>最终控制台打印结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Optional</span>(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">李四</span><br></pre></td></tr></table></figure>
<p>可选项默认值为<code>nil</code>，非可选项没有默认值，并且非可选项在使用前需要赋值。</p>
<div style="width:711px; margin:0px; padding:0px; align:left;">
<img src="/Blog/2020/06/06/Swift%E5%8F%AF%E9%80%89%E9%A1%B9/1.png" class="" title="可选项和非可选项默认值截图">
</div>

<h2 id="强制解包"><a href="#强制解包" class="headerlink" title="强制解包"></a>强制解包</h2><ul>
<li><p>可选项是对其他类型的一层包装，可以将它理解为一个盒子</p>
</li>
<li><p>如果为<code>nil</code>，那么它是一个空盒子</p>
</li>
<li><p>如果不为<code>nil</code>，那么盒子里装的是：被包装类型的数据<br>代码示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age: <span class="type">Int?</span> <span class="comment">// 默认就是nil</span></span><br><span class="line">age = <span class="number">10</span></span><br><span class="line">age = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>图形表示：</p>
<div style="width:620px; margin:0px; padding:0px; align:left;">
<img src="/Blog/2020/06/06/Swift%E5%8F%AF%E9%80%89%E9%A1%B9/2.png" class="" title="可选值有值和无值截图">
</div>
</li>
<li><p>如果需要从可选项中取出被包装的数据，需要使用感叹号<code>!</code>进行强制解包</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age: <span class="type">Int?</span> = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">String</span>(describing: age))</span><br><span class="line"><span class="keyword">let</span> ageValue: <span class="type">Int</span> = age!</span><br><span class="line"><span class="built_in">print</span>(ageValue)</span><br><span class="line"><span class="comment">//控制台打印数据</span></span><br><span class="line"><span class="comment">//Optional(10)</span></span><br><span class="line"><span class="comment">//10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果对值为<code>nil</code>的可选项进行强制解包，将会产生运行时错误</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age: <span class="type">Int?</span></span><br><span class="line"><span class="built_in">print</span>(age!)</span><br></pre></td></tr></table></figure>
<p>会产生错误：<code>Fatal error: Unexpectedly found nil while unwrapping an Optional value</code>。</p>
</li>
</ul>
<h2 id="判断可选项是否包含值"><a href="#判断可选项是否包含值" class="headerlink" title="判断可选项是否包含值"></a>判断可选项是否包含值</h2><p>可选值可以和<code>nil</code>直接进行比较，用于判断可选项是否包含值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="type">Int</span>(<span class="string">&quot;aa123&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> number != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;字符串转换成功:\(number!)&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;字符串转换失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制台打印：</span></span><br><span class="line"><span class="comment">//字符串转换失败</span></span><br></pre></td></tr></table></figure>

<h2 id="可选项绑定-Optional-Binding"><a href="#可选项绑定-Optional-Binding" class="headerlink" title="可选项绑定(Optional Binding)"></a>可选项绑定(Optional Binding)</h2><ul>
<li>可以使用<code>可选项绑定</code>来判断可选项是否包含值。</li>
<li>如果包含就自动解包，把值赋值给一个临时的常量(<code>let</code>)或者变量(<code>var</code>)，并返回<code>true</code>，否则返回<code>false</code>。</li>
</ul>
<p>示例1:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> number = <span class="type">Int</span>(<span class="string">&quot;123&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;字符串转换成功:\(number)&quot;</span>)</span><br><span class="line">    <span class="comment">// number是强制解包之后的Int值</span></span><br><span class="line">    <span class="comment">// number作用域仅限于这个大括号</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;字符串转换失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制台打印结果：</span></span><br><span class="line"><span class="comment">//字符串转换成功:123</span></span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> spring = <span class="number">1</span>, summer, autumn, winter</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> season = <span class="type">Season</span>(rawValue: <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> season &#123;</span><br><span class="line">    <span class="keyword">case</span> .spring:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;season is spring&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;season is other&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;no such season&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制台打印结果：</span></span><br><span class="line"><span class="comment">//no such season</span></span><br></pre></td></tr></table></figure>
<p>示例3：多条件组合判断</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般写法</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> first = <span class="type">Int</span>(<span class="string">&quot;4&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> second = <span class="type">Int</span>(<span class="string">&quot;42&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> first &lt; second &amp;&amp; second &lt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\(first) &lt; \(second) &lt; 100&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制台打印结果：</span></span><br><span class="line"><span class="comment">//4 &lt; 42 &lt; 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用组合条件判断的等价写法：</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> first = <span class="type">Int</span>(<span class="string">&quot;4&quot;</span>),</span><br><span class="line">   <span class="keyword">let</span> second = <span class="type">Int</span>(<span class="string">&quot;42&quot;</span>),</span><br><span class="line">   first &lt; second &amp;&amp; second &lt; <span class="number">100</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\(first) &lt; \(second) &lt; 100&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制台打印结果：</span></span><br><span class="line"><span class="comment">//4 &lt; 42 &lt; 100</span></span><br></pre></td></tr></table></figure>
<p>示例4：while循环中使用可选项绑定</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历数组，将遇到的正数都加起来，如果遇到负数或非数字，停止遍历</span></span><br><span class="line"><span class="keyword">var</span> strs = [<span class="string">&quot;10&quot;</span>, <span class="string">&quot;20&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;-20&quot;</span>, <span class="string">&quot;30&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> num = <span class="type">Int</span>(strs[index]), num &gt; <span class="number">0</span> &#123;</span><br><span class="line">    sum += num</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sum)</span><br><span class="line"><span class="comment">//控制台打印结果：</span></span><br><span class="line"><span class="comment">//30</span></span><br></pre></td></tr></table></figure>

<h2 id="空合并运算符-Nil-Coalescing-Operator"><a href="#空合并运算符-Nil-Coalescing-Operator" class="headerlink" title="空合并运算符 ?? (Nil-Coalescing Operator)"></a>空合并运算符 ?? (Nil-Coalescing Operator)</h2><p>定义如下：<br><code>public func ?? &lt;T&gt;(optional: T?, defaultValue: @autoclosure () throws -&gt; T) rethrows -&gt; T</code><br><code>public func ?? &lt;T&gt;(optional: T?, defaultValue: @autoclosure () throws -&gt; T?) rethrows -&gt; T?</code></p>
<ul>
<li><strong>a</strong> <code>??</code> <strong>b</strong></li>
<li><strong>a</strong> 是<code>可选项</code></li>
<li><strong>b</strong> 是<code>可选项</code> 或者 <code>不是可选项</code></li>
<li><strong>b</strong> 跟 <strong>a</strong>的存储类型必须相同</li>
<li>如果<strong>a</strong> 不为<code>nil</code>，就返回 <strong>a</strong></li>
<li>如果<strong>a</strong> 为<code>nil</code>，就返回 <strong>b</strong></li>
<li>如果<strong>b</strong> <code>不是可选项</code>，返回<strong>a</strong> 时会<code>自动解包</code></li>
<li>计算结果的类型与 <strong>b</strong>的类型相同</li>
</ul>
<p>示例代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例1</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="type">Int?</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int?</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a ?? b</span><br><span class="line"><span class="built_in">print</span>(<span class="type">String</span>(describing: <span class="built_in">c</span>)) <span class="comment">// c是Int? , Optional(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int?</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a ?? b</span><br><span class="line"><span class="built_in">print</span>(<span class="type">String</span>(describing: <span class="built_in">c</span>)) <span class="comment">// c是Int? , Optional(2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例3</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a ?? b</span><br><span class="line"><span class="built_in">print</span>(<span class="type">String</span>(describing: <span class="built_in">c</span>)) <span class="comment">// c是Int? , nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例4</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="type">Int?</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a ?? b</span><br><span class="line"><span class="built_in">print</span>(<span class="type">String</span>(describing: <span class="built_in">c</span>)) <span class="comment">// c是Int , 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例5</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a ?? b</span><br><span class="line"><span class="built_in">print</span>(<span class="type">String</span>(describing: <span class="built_in">c</span>)) <span class="comment">// c是Int , 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例6，与示例5等价，不使用??运算符的时候</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span>: <span class="type">Int</span></span><br><span class="line"><span class="comment">// 如果不使用??运算符</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> temp = a &#123;</span><br><span class="line">    <span class="built_in">c</span> = temp</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">c</span> = b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多个-一起使用"><a href="#多个-一起使用" class="headerlink" title="多个??一起使用"></a>多个<code>??</code>一起使用</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例1</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="type">Int?</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int?</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a ?? b ?? <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">String</span>(describing: <span class="built_in">c</span>)) <span class="comment">// c是Int，1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int?</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a ?? b ?? <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">String</span>(describing: <span class="built_in">c</span>)) <span class="comment">// c是Int，2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例3</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a ?? b ?? <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">String</span>(describing: <span class="built_in">c</span>)) <span class="comment">// c是Int，3</span></span><br></pre></td></tr></table></figure>
<h3 id="跟if-let配合使用"><a href="#跟if-let配合使用" class="headerlink" title="??跟if let配合使用"></a><code>??</code>跟<code>if let</code>配合使用</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例1</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int?</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="built_in">c</span> = a ?? b &#123; <span class="comment">// 类似于 if a != nil || b != nil</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">c</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制台打印结果：</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int?</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="built_in">c</span> = a, <span class="keyword">let</span> d = b &#123; <span class="comment">// 类似于 if a != nil &amp;&amp; b != nil</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">c</span>)</span><br><span class="line">    <span class="built_in">print</span>(d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="comment">//控制台打印结果:</span></span><br><span class="line"><span class="comment">//123</span></span><br></pre></td></tr></table></figure>

<h2 id="guard语句"><a href="#guard语句" class="headerlink" title="guard语句"></a>guard语句</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> 条件 <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">    退出当前作用域</span><br><span class="line">    <span class="comment">// return、break、continue、throw error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当<code>guard</code>语句的条件为<code>false</code>时，就会执行大括号里面的代码</li>
<li>当<code>guard</code>语句的条件为<code>true</code>时，就会跳过<code>guard</code>语句</li>
<li><code>guard</code>语句特别适合用来”提前退出”</li>
<li>当使用<code>guard</code>语句进行可选项绑定时，绑定的常量(<code>let</code>)、变量(<code>var</code>)也能在外层作用域中使用</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(<span class="number">_</span> info: [String : String])</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> username = info[<span class="string">&quot;username&quot;</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;请输入用户名&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> password = info[<span class="string">&quot;password&quot;</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;请输入密码&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if username ...</span></span><br><span class="line">    <span class="comment">// if password ...</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;用户名:\(username)&quot;</span>, <span class="string">&quot;密码:\(password)&quot;</span>, <span class="string">&quot;登录...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="隐式解包-Implicitly-Unwrapped-Optional"><a href="#隐式解包-Implicitly-Unwrapped-Optional" class="headerlink" title="隐式解包(Implicitly Unwrapped Optional)"></a>隐式解包(Implicitly Unwrapped Optional)</h2><ul>
<li>在某些情况下，可选项一旦被设定值后，就会一直拥有值</li>
<li>在这种情况下，可以去掉检查，也不必每次访问时都进行解包，因为它能确定每次访问的时候都是有值</li>
<li>可以在类型后面加个<code>!</code>定义一个隐式解包的可选项</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1: <span class="type">Int!</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> num2: <span class="type">Int</span> = num1</span><br><span class="line"><span class="keyword">if</span> num1 != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(num1 + <span class="number">6</span>) <span class="comment">// 16</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> num3 = num1 &#123;</span><br><span class="line">    <span class="built_in">print</span>(num3) <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num4: <span class="type">Int!</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> num5: <span class="type">Int</span> = num4 <span class="comment">// Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串插值中使用可选项"><a href="#字符串插值中使用可选项" class="headerlink" title="字符串插值中使用可选项"></a>字符串插值中使用可选项</h2><ul>
<li>可选项在字符串插值或者直接打印时，编译器会发出警告<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age: <span class="type">Int?</span> = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My age is \(age)&quot;</span>) <span class="comment">// 此处会出现警告</span></span><br></pre></td></tr></table></figure></li>
<li>至少有3种方法消除警告<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age: <span class="type">Int?</span> = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My age is \(age!)&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My age is \(String(describing: age))&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My age is \(age ?? 0)&quot;</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="多重可选项"><a href="#多重可选项" class="headerlink" title="多重可选项"></a>多重可选项</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1: <span class="type">Int?</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> num2: <span class="type">Int?</span>? = num1</span><br><span class="line"><span class="keyword">var</span> num3: <span class="type">Int?</span>? = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(num2 == num3) <span class="comment">// true, 值相同</span></span><br><span class="line"><span class="built_in">print</span>(num1 == num2) <span class="comment">// true, 值相同</span></span><br><span class="line"><span class="built_in">print</span>(num1 == num3) <span class="comment">// true, 值相同</span></span><br></pre></td></tr></table></figure>
<p>以上代码可以按照下图理解：</p>
<div style="width:761px; margin:0px; padding:0px; align:left;">
<img src="/Blog/2020/06/06/Swift%E5%8F%AF%E9%80%89%E9%A1%B9/3.png" class="" title="多重可选项有值截图">
</div>

<p>可以使用lldb指令<code>frame variable -R</code>或者<code>fr v -R</code>查看区别</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(lldb) fr v -<span class="type">R</span> num1</span><br><span class="line">(<span class="type">Swift</span>.<span class="type">Optional</span>&lt;<span class="type">Swift</span>.<span class="type">Int</span>&gt;) num1 = some &#123;</span><br><span class="line">  some = &#123;</span><br><span class="line">    _value = <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) fr v -<span class="type">R</span> num2</span><br><span class="line">(<span class="type">Swift</span>.<span class="type">Optional</span>&lt;<span class="type">Swift</span>.<span class="type">Optional</span>&lt;<span class="type">Swift</span>.<span class="type">Int</span>&gt;&gt;) num2 = some &#123;</span><br><span class="line">  some = some &#123;</span><br><span class="line">    some = &#123;</span><br><span class="line">      _value = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) fr v -<span class="type">R</span> num3</span><br><span class="line">(<span class="type">Swift</span>.<span class="type">Optional</span>&lt;<span class="type">Swift</span>.<span class="type">Optional</span>&lt;<span class="type">Swift</span>.<span class="type">Int</span>&gt;&gt;) num3 = some &#123;</span><br><span class="line">  some = some &#123;</span><br><span class="line">    some = &#123;</span><br><span class="line">      _value = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) </span><br></pre></td></tr></table></figure>

<p>空值示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> num2: <span class="type">Int?</span>? = num1</span><br><span class="line"><span class="keyword">var</span> num3: <span class="type">Int?</span>? = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(num2 == num3) <span class="comment">// false, 值不相同</span></span><br><span class="line"><span class="built_in">print</span>(num1 == num2) <span class="comment">// true, 值相同</span></span><br><span class="line"><span class="built_in">print</span>(num1 == num3) <span class="comment">// false, 值不相同</span></span><br></pre></td></tr></table></figure>
<p>以上代码可以按照下图理解：</p>
<div style="width:779px; margin:0px; padding:0px; align:left;">
<img src="/Blog/2020/06/06/Swift%E5%8F%AF%E9%80%89%E9%A1%B9/4.png" class="" title="多重可选项无值截图">
</div>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(lldb) fr v -<span class="type">R</span> num1</span><br><span class="line">(<span class="type">Swift</span>.<span class="type">Optional</span>&lt;<span class="type">Swift</span>.<span class="type">Int</span>&gt;) num1 = <span class="keyword">none</span> &#123;</span><br><span class="line">  some = &#123;</span><br><span class="line">    _value = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) fr v -<span class="type">R</span> num2</span><br><span class="line">(<span class="type">Swift</span>.<span class="type">Optional</span>&lt;<span class="type">Swift</span>.<span class="type">Optional</span>&lt;<span class="type">Swift</span>.<span class="type">Int</span>&gt;&gt;) num2 = some &#123;</span><br><span class="line">  some = <span class="keyword">none</span> &#123;</span><br><span class="line">    some = &#123;</span><br><span class="line">      _value = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) fr v -<span class="type">R</span> num3</span><br><span class="line">(<span class="type">Swift</span>.<span class="type">Optional</span>&lt;<span class="type">Swift</span>.<span class="type">Optional</span>&lt;<span class="type">Swift</span>.<span class="type">Int</span>&gt;&gt;) num3 = <span class="keyword">none</span> &#123;</span><br><span class="line">  some = some &#123;</span><br><span class="line">    some = &#123;</span><br><span class="line">      _value = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift字符串操作</title>
    <url>/Blog/2020/06/01/Swift%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h2><p>字符串字面量可以用于为常量和变量提供初始值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someString = <span class="string">&quot;Some string const value&quot;</span></span><br><span class="line"><span class="keyword">var</span> someString2 = <span class="string">&quot;Some string varible value&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="多行字符串字面量"><a href="#多行字符串字面量" class="headerlink" title="多行字符串字面量"></a>多行字符串字面量</h3><p>如果你需要一个字符串是跨越多行的，那就使用多行字符串字面量 — 由一对三个双引号包裹着的具有固定顺序的文本字符集：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> quotation = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">The White Rabbit put on his spectacles.  &quot;Where shall I begin,</span></span><br><span class="line"><span class="string">please your Majesty?&quot; he asked.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on</span></span><br><span class="line"><span class="string">till you come to the end; then stop.&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="初始化空字符串"><a href="#初始化空字符串" class="headerlink" title="初始化空字符串"></a>初始化空字符串</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyString = <span class="string">&quot;&quot;</span>  <span class="comment">// 空字符串字面量</span></span><br><span class="line"><span class="keyword">var</span> emptyString2 = <span class="type">String</span>() <span class="comment">// 字符串初始化方法</span></span><br><span class="line"><span class="comment">// 两个字符串均为空并等价。</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串判空"><a href="#字符串判空" class="headerlink" title="字符串判空"></a>字符串判空</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> emptyString.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Nothing to see here&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串可变性"><a href="#字符串可变性" class="headerlink" title="字符串可变性"></a>字符串可变性</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variableString = <span class="string">&quot;Horse&quot;</span></span><br><span class="line">variableString += <span class="string">&quot; and carriage&quot;</span></span><br><span class="line"><span class="comment">// variableString 现在为 &quot;Horse and carriage&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> constantString = <span class="string">&quot;Highlander&quot;</span></span><br><span class="line">constantString += <span class="string">&quot; and another Highlander&quot;</span></span><br><span class="line"><span class="comment">// 这报告一个编译错误(compile-time error) - 常量字符串不可以被修改</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历字符串中的字符"><a href="#遍历字符串中的字符" class="headerlink" title="遍历字符串中的字符"></a>遍历字符串中的字符</h2><p>方法1：通过<code>for in</code>遍历字符串中全部的字符</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> <span class="string">&quot;ABCDE&quot;</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(character)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法2：使用 indices 属性会创建一个包含全部索引的范围（Range），用来在一个字符串中访问单个字符。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">&quot;Helo, World!&quot;</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> greeting.<span class="built_in">indices</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;\(greeting[index]) &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 控制台输出：H e l o ,   W o r l d ! </span></span><br></pre></td></tr></table></figure>


<h2 id="通过字符数组初始化字符串"><a href="#通过字符数组初始化字符串" class="headerlink" title="通过字符数组初始化字符串"></a>通过字符数组初始化字符串</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> catCharacters: [<span class="type">Character</span>] = [<span class="string">&quot;C&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;r&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> catString = <span class="type">String</span>(catCharacters)</span><br><span class="line"><span class="built_in">print</span>(catString)</span><br></pre></td></tr></table></figure>

<h2 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h2><p>字符串可以通过加法运算符” + “相加在一起，创建一个新的字符串</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string1 = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">let</span> string2 = <span class="string">&quot; there&quot;</span></span><br><span class="line"><span class="keyword">var</span> welcom = string1 + string2</span><br><span class="line"><span class="built_in">print</span>(welcom)</span><br></pre></td></tr></table></figure>

<h2 id="字符串末尾追加字符"><a href="#字符串末尾追加字符" class="headerlink" title="字符串末尾追加字符"></a>字符串末尾追加字符</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> exclamationMark: <span class="type">Character</span> = <span class="string">&quot;!&quot;</span></span><br><span class="line">welcom.append(exclamationMark)</span><br></pre></td></tr></table></figure>

<h2 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> multiplier = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;\(multiplier) * 2.5 is \(Double(multiplier) * 2.5)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>

<p>如果要在使用扩展字符串分隔符的字符串中使用字符串插值，需要在反斜杠后面添加与开头和结尾数量相同的扩展字符串分隔符。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(#<span class="string">&quot;6 * 7 is \#(6 * 7)&quot;</span>#)</span><br></pre></td></tr></table></figure>

<p>如果是字符串可选项，在直接使用字符串插值的时候会报警告，避免警告有三种方式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1: <span class="type">String?</span> = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;str1 = \(str1!)&quot;</span>) <span class="comment">// 强制解包</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;str1 = \(String(describing: str1))&quot;</span>) <span class="comment">// 使用字符串方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;str1 = \(str1 ?? &quot;</span>空值<span class="string">&quot;)&quot;</span>) <span class="comment">// 使用空合并运算符</span></span><br><span class="line"><span class="comment">// 控制台打印如下信息：</span></span><br><span class="line"><span class="comment">//str1 = 123</span></span><br><span class="line"><span class="comment">//str1 = Optional(&quot;123&quot;)</span></span><br><span class="line"><span class="comment">//str1 = 123</span></span><br></pre></td></tr></table></figure>

<h2 id="计算字符数量"><a href="#计算字符数量" class="headerlink" title="计算字符数量"></a>计算字符数量</h2><p>想要获得一个字符串中<code>Character</code>值的数量，可以使用<code>count</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unusualStr = <span class="string">&quot;1234\t&quot;</span></span><br><span class="line"><span class="built_in">print</span>(unusualStr.<span class="built_in">count</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h2 id="通过索引访问字符串的值"><a href="#通过索引访问字符串的值" class="headerlink" title="通过索引访问字符串的值"></a>通过索引访问字符串的值</h2><p>通过<code>startIndex</code>访问第一个字符，通过<code>before lastIndex</code>访问最后一个字符，<code>lastIndex</code>无法直接访问。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">&quot;Helo, World!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(greeting[greeting.startIndex])</span><br><span class="line"><span class="built_in">print</span>(greeting[greeting.index(before: greeting.endIndex)])</span><br><span class="line"><span class="built_in">print</span>(greeting[greeting.index(after: greeting.startIndex)])</span><br><span class="line"><span class="built_in">print</span>(greeting[greeting.index(greeting.startIndex, offsetBy: <span class="number">3</span>)])</span><br></pre></td></tr></table></figure>

<h2 id="字符串插入操作"><a href="#字符串插入操作" class="headerlink" title="字符串插入操作"></a>字符串插入操作</h2><p>调用<code>insert(_:at:)</code>方法可以在一个字符串的指定索引插入一个字符，调用<code>insert(contentsOf:at:)</code>方法可以在一个字符串的指定索引插入一个字符串。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> welcome = <span class="string">&quot;hello&quot;</span></span><br><span class="line">welcome.insert(<span class="string">&quot;!&quot;</span>, at: welcome.endIndex)</span><br><span class="line"><span class="built_in">print</span>(welcome) <span class="comment">// 打印 hello!</span></span><br><span class="line"></span><br><span class="line">welcome.insert(contentsOf: <span class="string">&quot; there&quot;</span>, at: welcome.index(before: welcome.endIndex))</span><br><span class="line"><span class="built_in">print</span>(welcome) <span class="comment">// 打印 hello there!</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串移除操作"><a href="#字符串移除操作" class="headerlink" title="字符串移除操作"></a>字符串移除操作</h2><p>调用<code>remove(at:)</code>方法可以在一个字符串指定索引删除一个字符，调用<code>removeSubrange(_:)</code>方法可以在一个字符串的指定索引删除一个子字符串。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> welcome = <span class="string">&quot;hello there!&quot;</span></span><br><span class="line">welcome.remove(at: welcome.index(before: welcome.endIndex))</span><br><span class="line"><span class="built_in">print</span>(welcome) <span class="comment">// 打印 hello there</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> range = welcome.index(welcome.endIndex, offsetBy: -<span class="number">6</span>)..&lt;welcome.endIndex</span><br><span class="line">welcome.removeSubrange(range)</span><br><span class="line"><span class="built_in">print</span>(welcome) <span class="comment">// 打印 hello</span></span><br></pre></td></tr></table></figure>

<h2 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h2><p>当你从字符串中获取一个子字符串 —— 例如，使用下标或者 <code>prefix(_:)</code>之类的方法 —— 就可以得到一个 Substring 的实例，而非另外一个 <code>String。Swift</code> 里的 <code>Substring</code> 绝大部分函数都跟 <code>String</code> 一样，意味着你可以使用同样的方式去操作 Substring 和 <code>String</code>。然而，跟 <code>String</code> 不同的是，你只有在短时间内需要操作字符串时，才会使用 <code>Substring</code>。当你需要长时间保存结果时，就把 <code>Substring</code> 转化为 <code>String</code> 的实例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="keyword">let</span> index = greeting.firstIndex(of: <span class="string">&quot;,&quot;</span>) ?? greeting.endIndex</span><br><span class="line"><span class="keyword">let</span> beginning = greeting[..&lt;index]</span><br><span class="line"><span class="comment">// beginning 的值为 &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把结果转化为 String 以便长期存储。</span></span><br><span class="line"><span class="keyword">let</span> newString = <span class="type">String</span>(beginning)</span><br></pre></td></tr></table></figure>

<h2 id="字符串相等"><a href="#字符串相等" class="headerlink" title="字符串相等"></a>字符串相等</h2><p>Swift提供了三种方式来比较文本值：字符串字符相等、前缀相等和后缀相等。</p>
<h3 id="字符串-字符相等"><a href="#字符串-字符相等" class="headerlink" title="字符串/字符相等"></a>字符串/字符相等</h3><p>字符串/字符可以用等于操作符(<code>==</code>)和不等于操作符(<code>!=</code>)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> quotation1 = <span class="type">String</span>(<span class="string">&quot;this is a test string&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> quotation2 = <span class="type">String</span>(<span class="string">&quot;this is a test string&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> ptr1 = <span class="built_in">withUnsafePointer</span>(to: &amp;quotation1) &#123; $<span class="number">0</span> &#125;</span><br><span class="line"><span class="keyword">var</span> ptr2 = <span class="built_in">withUnsafePointer</span>(to: &amp;quotation2) &#123; $<span class="number">0</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;quotation1地址:&quot;</span>, ptr1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;quotation2地址:&quot;</span>, ptr2)</span><br><span class="line"><span class="keyword">if</span> quotation1 == quotation2 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;quotation1 == quotation2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 控制台打印消息</span></span><br><span class="line"><span class="comment">// quotation1地址: 0x0000000102b1e090</span></span><br><span class="line"><span class="comment">// quotation2地址: 0x0000000102b1e0a0</span></span><br><span class="line"><span class="comment">// quotation1 == quotation2</span></span><br></pre></td></tr></table></figure>


<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://swiftgg.gitbook.io/swift/swift-jiao-cheng/03_strings_and_characters">字符串和字符</a><br><a href="https://www.jianshu.com/p/4303f1fa8352">Swift-06.指针(UnsafePointer)</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Transporter卡住无法上传</title>
    <url>/Blog/2020/12/03/Transporter%E5%8D%A1%E4%BD%8F%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<p>最近遇到Transporter上传ipa文件到AppStore Connect的时候一直卡在<strong>正在验证APP - 正在通过App Store进行认证</strong>状态。</p>
<img src="/Blog/2020/12/03/Transporter%E5%8D%A1%E4%BD%8F%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0/%E6%AD%A3%E5%9C%A8%E9%AA%8C%E8%AF%81APP.jpg" class="" title="正在验证App截图">

<p>解决办法：<br>1.删除Transporter的缓存目录，具体的目录路径在：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/Users/kris/Library/Caches/com.apple.amp.itmstransporter</span><br></pre></td></tr></table></figure>

<p>2.使用命令行进入Transporter目录，执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /Applications/Transporter.app/Contents/itms/bin</span><br><span class="line">$ ./iTMSTransporter</span><br></pre></td></tr></table></figure>

<p>3.当命令行出现以下内容，重新再打开Transporter交付App就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2020-12-03 12:55:39 CST] &lt;main&gt; DEBUG: Saving configuration to <span class="built_in">local</span> path: /Users/kris/Library/Caches/com.apple.amp.itmstransporter/Defaults.properties</span><br><span class="line">usage: iTMSTransporter [-<span class="built_in">help</span> &lt;arg&gt; | -info | -m &lt;arg&gt; | -version]   [-o &lt;arg&gt;] [-v</span><br><span class="line">       &lt;arg&gt;]  [-WONoPause &lt;arg&gt;] [-Xmx4096m]</span><br><span class="line">iTMSTransporter : iTunes Store Transporter 2.1.0</span><br><span class="line"> -<span class="built_in">help</span> &lt;arg&gt;        Show this <span class="built_in">help</span>.  If a mode value is specified, show <span class="built_in">help</span> specific</span><br><span class="line">                    to that mode.</span><br><span class="line"> -info              The -info option should be used by itself and returns the</span><br><span class="line">                    copyright notice and acknowledgements.</span><br><span class="line"> -m &lt;arg&gt;           The -m option specifies the tool<span class="string">&#x27;s mode.  The valid values are:</span></span><br><span class="line"><span class="string">                    verify, upload, provider, diagnostic, lookupMetadata,</span></span><br><span class="line"><span class="string">                    createArtist, lookupArtist, status, statusAll,</span></span><br><span class="line"><span class="string">                    createMetadataTicket, queryTickets, generateSchema, transferTest,</span></span><br><span class="line"><span class="string">                    downloadMetadataGuides, listReports, requestReport</span></span><br><span class="line"><span class="string"> -o &lt;arg&gt;           The -o option specifies the directory and filename you want to use</span></span><br><span class="line"><span class="string">                    to log output information.  By default, Transporter logs output</span></span><br><span class="line"><span class="string">                    information to standard out. If you specify a filename,</span></span><br><span class="line"><span class="string">                    Transporter logs the output to the specified file, as well as to</span></span><br><span class="line"><span class="string">                    standard out.</span></span><br><span class="line"><span class="string"> -v &lt;arg&gt;           The -v option specifies the level of logging.  The five values</span></span><br><span class="line"><span class="string">                    are: off, detailed, informational, critical, eXtreme.</span></span><br><span class="line"><span class="string"> -version           The -version option should be used by itself and returns the</span></span><br><span class="line"><span class="string">                    version of the tool.</span></span><br><span class="line"><span class="string"> -WONoPause &lt;arg&gt;   The -WONoPause option is only valid on Windows and its value can</span></span><br><span class="line"><span class="string">                    be &#x27;</span><span class="literal">true</span><span class="string">&#x27; or &#x27;</span><span class="literal">false</span><span class="string">&#x27;.  If an error occurs during script execution,</span></span><br><span class="line"><span class="string">                    the process idles because the message &#x27;</span>Press any key...<span class="string">&#x27; is</span></span><br><span class="line"><span class="string">                    displayed on the console and the system awaits a keypress. To</span></span><br><span class="line"><span class="string">                    avoid this behavior, set this property to true</span></span><br><span class="line"><span class="string"> -Xmx4096m          Specifies that you want to change the Java Virtual Machine&#x27;</span>s (JVM)</span><br><span class="line">                    allocated memory by increasing the JVM heap size.  By default,</span><br><span class="line">                    Transporter uses a 2048MB heap size. You can use the -Xmx4096m</span><br><span class="line">                    option to specify a 4-gigabyte (GB) heap size. Apple recommends,</span><br><span class="line">                    <span class="keyword">if</span> needed, increasing the heap size to 4096MB by specifying the</span><br><span class="line">                    -Xmx4096m (or -Xmx4g) option and adjusting as needed.</span><br><span class="line">[2020-12-03 12:55:39 CST] &lt;main&gt; DBG-X: Returning 0</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>VPS使用心得</title>
    <url>/Blog/2019/11/17/VPS%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="什么是VPS"><a href="#什么是VPS" class="headerlink" title="什么是VPS?"></a>什么是VPS?</h2><p>Virtual Private Server简称VPS。是在一台真实服务器上使用虚拟机技术虚拟成多个小主机，用VZ或VM在一台服务器上虚拟出多个类似独立服务器的部分，每个部分都可以做单独的操作系统，管理方法同服务器一样。通俗讲就是物理机上开出的虚拟机。</p>
<h2 id="什么是虚拟主机？"><a href="#什么是虚拟主机？" class="headerlink" title="什么是虚拟主机？"></a>什么是虚拟主机？</h2><p>Virtual hosts （Vhost）虚拟主机是通过物理服务器，VPS或者云服务器中划分出来的一个小空间，不管是独立服务器还是VPS或者云服务器都可以做为虚拟主机的母体。但一般不选择VPS作为虚拟主机的服务器。</p>
<h2 id="VPS和虚拟主机有什么区别？"><a href="#VPS和虚拟主机有什么区别？" class="headerlink" title="VPS和虚拟主机有什么区别？"></a>VPS和虚拟主机有什么区别？</h2><p>1.使用方式不同。VPS一般通过网站的控制台或者SSH远程登录操作，而虚拟主机只能通过FTP上传的方式或网站控制台来操作。因为使用方式的不同，用户只能在特定的虚拟空间里面操作，使用方式比较简单，但是也相对局限。<br>2.适用人群不同。VPS一般适用于网站的站长，搭建博客、网站、或CMS等。而VPS则适用于相对专业的人员，VPS可以自己安装操作系统、自己配置环境，操作起来比较灵活，也比较复杂。</p>
<h2 id="VPS虚拟化的分类"><a href="#VPS虚拟化的分类" class="headerlink" title="VPS虚拟化的分类"></a>VPS虚拟化的分类</h2><p>目前市场上的虚拟化技术主要分为4类:</p>
<h3 id="1-XEN"><a href="#1-XEN" class="headerlink" title="1.XEN"></a>1.XEN</h3><p>XEN的典型代表是早期的AWS和老牌VPS服务商Linode,不过这两家都迁移到了KVM。目前主流服务商已经全面放弃XEN。</p>
<h3 id="2-KVM"><a href="#2-KVM" class="headerlink" title="2.KVM"></a>2.KVM</h3><p>目前的主流全虚拟化技术,全面替代了XEN。XEN算是Linux的一个应用,而KVM是Linux的一个模块。</p>
<h3 id="3-Hyper-V"><a href="#3-Hyper-V" class="headerlink" title="3.Hyper-V"></a>3.Hyper-V</h3><p>微软自家虚拟技术,Windows专享。</p>
<h3 id="4-OpenVZ"><a href="#4-OpenVZ" class="headerlink" title="4.OpenVZ"></a>4.OpenVZ</h3><p>OpenVZ本质上并不是虚拟化,而是容器。相对于XEN和KVM而言它的性能损失是最小的(几乎可以忽略不计),并且内存/CPU/硬盘伸缩不用重启(XEN和KVM是需要重启后才能正确配置的)。<br>而OpenVZ最大的缺点在于虚拟隔离化非常低,并且硬件层面权限较低甚至不能拥有自己的独立Linux内核。<br>同时OpenVZ最大的问题并不在于技术层面,而在于绝大部分服务商使用OpenVZ的目的是内存可以超售。超售是什么概念呢?简单说一台32G内存的物理机可以开出64台内存1G的VPS。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>除了上面说到的以外还有一些非主流的虚拟技术,比如VMWare这种商业解决方案。</p>
<h2 id="VPS可以做哪些事情？"><a href="#VPS可以做哪些事情？" class="headerlink" title="VPS可以做哪些事情？"></a>VPS可以做哪些事情？</h2><p>1.搭建Shadowsocks服务器，科学上网。<br>2.建立自己的博客站点，绑定免费的域名，使用免费的Cloudfare进行CDN加速，实现自己的博客站点。<br>3.建立下载服务器。<br>4.搭建自己的服务器，比如FTP服务器，Git服务器等等，自己托管自己的私有库代码。<br>5.注册美版Apple ID，下载美区的App。<br>6.搭建Google镜像代理网站，方便资料查选和Bug修复。</p>
<h2 id="如何选购VPS？"><a href="#如何选购VPS？" class="headerlink" title="如何选购VPS？"></a>如何选购VPS？</h2><p>1.支付方式，尽量支持支付宝或微信，国外很多VPS已经支持支付宝支付了，但是更多的是只支持信用卡或者Paypal，由于很多是信用卡直接续费的，所以尽量不要选择信用卡支付，或者设定好闹钟，提醒自己解绑。<br>2.是否支持退款，购买国外的VPS，要注意商家是否支持退款，很多商家都是支持的。因为如果分到的VPS的IP已经被国家防火墙收录，这个VPS基本就失去意义了，这时候如果有退款保障可以申请退款，重新购买。<br>3.是否支持换IP，由于国家防火墙会不断的收录新的IP，如果IP不幸被墙，若支持换IP，那就太好了。<br>4.是否支持月付，一般的VPS商家都是支持月付的。如果你无法肯定VPS的稳定性，可以先用月付，购买一个短期的服务。<br>5.购买之前请先搜一下优惠码，很多网站都有优惠码，很容易就找到。</p>
<h2 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h2><ol>
<li>我使用过Vultr的VPS，网上查询Vultr的VPS是按小时收费的，只要你的机器存在一小时，就按1小时扣费，所以如果你不用的话，请立即删掉你的机器。并且Vultr需要充值，充值后才能使用，这个有点坑。我只记得我充了5美元，半个月就没了。可能操作失误，但是这个扣费确实很快，使用下来，费用高昂。</li>
<li>搬瓦工19.9美元一年的VPS刚停一个多月，因为无法续费了，搬瓦工发邮件给我，说19.9美元一年的VPS的架构是OpenVZ的，现在已经被淘汰了，多给我半个月的时间让我备份数据，然而我只想续费。等再去搬瓦工官网去看的时候，只剩49.9美元一年的VPS了，可见搬瓦工的价格也上涨了。</li>
<li>综合筛选发现，全球看下来，美国的服务器会相对便宜一些，香港的、台湾的、 欧洲的、韩国的、日本的都不便宜。</li>
</ol>
<h2 id="推荐服务器"><a href="#推荐服务器" class="headerlink" title="推荐服务器"></a>推荐服务器</h2><h3 id="Virmach-–-廉价入门"><a href="#Virmach-–-廉价入门" class="headerlink" title="Virmach – 廉价入门"></a><a href="https://www.gubo.org/best-vps-for-newbies/">Virmach – 廉价入门</a></h3><h3 id="低价VPS"><a href="#低价VPS" class="headerlink" title="低价VPS"></a><a href="https://www.vpscang.com/low-end-vps/">低价VPS</a></h3><h3 id="50KVM-–-靠谱国人商家"><a href="#50KVM-–-靠谱国人商家" class="headerlink" title="50KVM – 靠谱国人商家"></a><a href="https://www.vpscang.com/?=50kvm">50KVM – 靠谱国人商家</a></h3><h3 id="搬瓦工"><a href="#搬瓦工" class="headerlink" title="搬瓦工"></a><a href="https://www.vpscang.com/?=bandwagonhost">搬瓦工</a></h3><h2 id="经济实惠的个人VPS"><a href="#经济实惠的个人VPS" class="headerlink" title="经济实惠的个人VPS"></a>经济实惠的个人VPS</h2><p>下面列出的VPS非常便宜，而且性能稳定，但是，最好只将他们作为研究学习使用，而不要拿来建设网站。</p>
<table>
<thead>
<tr>
<th align="center">VPS品牌</th>
<th align="center">价格/年</th>
<th align="center">CPU</th>
<th align="center">内存</th>
<th align="center">硬盘</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://www.racknerd.com/">RackNerd</a></td>
<td align="center">$22.99</td>
<td align="center">1核</td>
<td align="center">512M</td>
<td align="center">30G</td>
</tr>
<tr>
<td align="center"><a href="https://my.frantech.ca/">BuyVM</a></td>
<td align="center">$20.00</td>
<td align="center">1核</td>
<td align="center">512M</td>
<td align="center">10G</td>
</tr>
<tr>
<td align="center"><a href="https://hostodo.com/portal/">Hostodo</a></td>
<td align="center">$19.99</td>
<td align="center">1核</td>
<td align="center">512M</td>
<td align="center">8G</td>
</tr>
<tr>
<td align="center"><a href="https://www.hostflyte.com/">HostFlyte</a></td>
<td align="center">$12</td>
<td align="center">1核</td>
<td align="center">512M</td>
<td align="center">10G</td>
</tr>
<tr>
<td align="center"><a href="https://virmach.com/">VirMach</a></td>
<td align="center">$12</td>
<td align="center">共享</td>
<td align="center">384M</td>
<td align="center">10G</td>
</tr>
</tbody></table>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h3><p><a href="https://vps.zzidc.com/VPSjianjie/2176.html">3分钟看懂vps、虚拟空间、服务器之间的区别</a><br><a href="https://yq.aliyun.com/articles/226730?spm=a2c4e.11153940.0.0.56349a16YI8ZKd">阿里云服务器与VPS和虚拟主机有什么区别？</a><br><a href="https://moonagic.com/how-to-buy-vps/">如何选购VPS</a><br><a href="https://www.gubo.org/best-vps-for-newbies/">适合新手入门的VPS机器</a><br><a href="https://www.vultrer.com/427.html">vultr收费方式是怎么样的？vultr是怎么计费的？vultr扣费模式解析</a><br><a href="https://pa.ci/20.html">VPS选购指南及其他</a><br><a href="https://www.xooof.com/">xooof风云博客</a><br><a href="https://www.10besty.com/best-vps-hosting-services/">VPS评测</a></p>
]]></content>
      <categories>
        <category>VPS</category>
      </categories>
      <tags>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title>VPS搭建SSR+BBR</title>
    <url>/Blog/2019/11/19/VPS%E6%90%AD%E5%BB%BASSR-BBR/</url>
    <content><![CDATA[<h2 id="VPS相关环境信息"><a href="#VPS相关环境信息" class="headerlink" title="VPS相关环境信息"></a>VPS相关环境信息</h2><p>Linux Centos 7.1503.01 X86 64 Minimal Gen2 V1</p>
<h2 id="安装ShadowsocksR的命令"><a href="#安装ShadowsocksR的命令" class="headerlink" title="安装ShadowsocksR的命令"></a>安装ShadowsocksR的命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash </span></span><br><span class="line"><span class="comment"># ./ssrmu.sh</span></span><br></pre></td></tr></table></figure>


<h2 id="安装BBR加速的命令-方法1"><a href="#安装BBR加速的命令-方法1" class="headerlink" title="安装BBR加速的命令(方法1)"></a>安装BBR加速的命令(方法1)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum -y install wget</span></span><br><span class="line"><span class="comment"># wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</span></span><br><span class="line"><span class="comment"># chmod +x bbr.sh</span></span><br><span class="line"><span class="comment"># ./bbr.sh</span></span><br></pre></td></tr></table></figure>
<h2 id="安装BBR加速的命令-方法2"><a href="#安装BBR加速的命令-方法2" class="headerlink" title="安装BBR加速的命令(方法2)"></a>安装BBR加速的命令(方法2)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wget -N --no-check-certificate &quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># chmod +x tcp.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ./tcp.sh</span></span><br></pre></td></tr></table></figure>
<p>操作方法：先安装内核，重启vps让内核生效，再启动对应的加速即可。数字1的BBR/BBR魔改内核对应数字4、5、6的BBR加速、BBR魔改加速和暴力BBR魔改版加速。数字2的BBRplus内核对应数字7的BBRplus加速。数字3的锐速加速内核对应数字8的锐速加速。</p>
<blockquote>
<p>以安装暴力BBR魔改版加速为例，我们先安装对应的内核，输入数字1</p>
</blockquote>
<blockquote>
<p>内核安装完成后，输入y进行重启，重启才能让内核生效</p>
</blockquote>
<blockquote>
<p>重启完成后，输入5启动使用BBR魔改版加速</p>
</blockquote>
<h2 id="检测BBR是否已经安装好了"><a href="#检测BBR是否已经安装好了" class="headerlink" title="检测BBR是否已经安装好了"></a>检测BBR是否已经安装好了</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 在终端输入如下命令，如果返回的输出有bbr，则说明已经安装完成</span></span><br><span class="line"><span class="comment"># sysctl net.ipv4.tcp_available_congestion_control</span></span><br><span class="line">net.ipv4.tcp_available_congestion_control = reno cubic bbr</span><br><span class="line"></span><br><span class="line"><span class="comment">## 在终端输入如下命令，如果返回的输出有bbr，则说明已经安装完成</span></span><br><span class="line"><span class="comment"># lsmod | grep bbr</span></span><br><span class="line">tcp_bbr                20480  7 </span><br></pre></td></tr></table></figure>

<p>首次安装完成如果无法连接成功，请尝试检测服务器防火墙是否没有新增规则，导致端口在外网无法访问。检测方法请使用<a href="http://tool.chinaz.com/port">站长工具&gt;端口扫描</a>。<br>如果查询出在外网无法访问当前的服务器端口，请在服务器的防火墙中添加规则，开启特殊端口访问。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看防火墙规则</span></span><br><span class="line"><span class="comment"># firewall-cmd --list-all</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 查询端口是否开放</span></span><br><span class="line"><span class="comment"># firewall-cmd --query-port=80/tcp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 开放80端口</span></span><br><span class="line"><span class="comment"># firewall-cmd --permanent --add-port=80/tcp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 移除端口</span></span><br><span class="line"><span class="comment"># firewall-cmd --permanent --remove-port=80/tcp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 重启防火墙(修改配置后要重启防火墙)</span></span><br><span class="line"><span class="comment"># firewall-cmd --reload</span></span><br></pre></td></tr></table></figure>

<h2 id="IP和端口是否畅通测试"><a href="#IP和端口是否畅通测试" class="headerlink" title="IP和端口是否畅通测试"></a>IP和端口是否畅通测试</h2><p>此工具可以检测全球范围内，到你的服务器的ping值大概是多少:<a href="http://ping.chinaz.com/">站长工具&gt;ping检测</a><br>通过站长工具检测国内到服务器的IP和端口是否畅通:<a href="http://tool.chinaz.com/port">站长工具&gt;端口扫描</a><br>通过此网站可以检测在国外，你的服务器IP和端口是否畅通:<a href="https://www.yougetsignal.com/tools/open-ports/">国外站长工具&gt;端口扫描</a></p>
<p>也可以使用命令检测远程服务器端口是否开启:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nc -v host port</span></span><br></pre></td></tr></table></figure>
<p>端口未打开返回状态为非0</p>
<h2 id="ShadowsocksR客户端下载地址"><a href="#ShadowsocksR客户端下载地址" class="headerlink" title="ShadowsocksR客户端下载地址"></a>ShadowsocksR客户端下载地址</h2><p><a href="https://github.com/shadowsocksr-backup/shadowsocks-rss">https://github.com/shadowsocksr-backup/shadowsocks-rss</a></p>
<h2 id="顺便附上Shadowsocks客户端的下载地址"><a href="#顺便附上Shadowsocks客户端的下载地址" class="headerlink" title="顺便附上Shadowsocks客户端的下载地址"></a>顺便附上Shadowsocks客户端的下载地址</h2><p>注意 ShadowsocksR 和 Shadowsocks 的客户端是不一样的，无法互相连通。<br><a href="https://lvii.gitbooks.io/outman/content/ss.mac.html">https://lvii.gitbooks.io/outman/content/ss.mac.html</a></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://www.heiqw.com/post-66.html">SSR科学上网搭建脚本+virmach主机购买地址分享</a><br><a href="https://www.5xiaobo.com/?id=693">国外VPS搭建SSR多用户教程【中文一键安装版】</a><br><a href="https://www.cnblogs.com/73tong/p/8309597.html">CentOS6开启BBR加速</a><br><a href="https://www.cnblogs.com/onmyway20xx/p/3626433.html">linux 检测远程端口是否打开</a><br><a href="http://ping.chinaz.com/">站长工具&gt;ping检测</a><br><a href="http://tool.chinaz.com/port">站长工具&gt;端口扫描</a><br><a href="https://www.yougetsignal.com/tools/open-ports/">国外站长工具&gt;端口扫描</a><br><a href="https://lvii.gitbooks.io/outman/content/">科学上网漫游指南(shadowsocks服务端和客户端搭建指南)</a><br><a href="https://github.com/shadowsocksr-backup/shadowsocks-rss">shadowsocksr-backup/shadowsocks-rss</a><br><a href="https://www.cnblogs.com/xxoome/p/7115614.html">Centos7.3防火墙配置</a><br><a href="https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B">自建ss服务器教程</a><br><a href="http://ping.pe/">全球ping</a><br><a href="https://www.ipip.net/ip.html">在线tracert,查询IP所在地</a><br><a href="https://my.freenom.com/clientarea.php?action=domains">免费域名</a><br><a href="https://coderschool.cn/2197.html">免费域名解析</a><br><a href="https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAv2ray%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B">自建V2Ray教程</a><br><a href="https://github.com/yanue/V2rayU">V2Ray客户端下载地址</a></p>
]]></content>
      <categories>
        <category>VPS</category>
      </categories>
      <tags>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title>VPS搭建v2ray服务器</title>
    <url>/Blog/2021/06/30/VPS%E6%90%AD%E5%BB%BAv2ray%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="自建v2Ray教程，总共分为5步"><a href="#自建v2Ray教程，总共分为5步" class="headerlink" title="自建v2Ray教程，总共分为5步"></a>自建v2Ray教程，总共分为5步</h2><p>第一步：购买VPS服务器<br>第二步：购买免费域名并绑定VPS服务器<br>第三步：一键部署v2ray脚本<br>第四步：一键加速VPS服务器（五合一的TCP网络加速脚本）<br>第五步：修改服务器时区</p>
<h2 id="购买VPS服务器"><a href="#购买VPS服务器" class="headerlink" title="购买VPS服务器"></a>购买VPS服务器</h2><p>本篇采用的VPS是一家加拿大VPS服务提供商。这家提供商共有3个机房位置，拉斯维加斯、纽约、卢森堡。这次使用的服务器位于拉斯维加斯，延时在200ms左右。购买地址：<a href="https://my.frantech.ca/cart.php">https://my.frantech.ca/cart.php</a></p>
<img src="/Blog/2021/06/30/VPS%E6%90%AD%E5%BB%BAv2ray%E6%9C%8D%E5%8A%A1%E5%99%A8/vps.png" class="" title="vps官网截图">

<h2 id="购买免费域名并绑定VPS服务器"><a href="#购买免费域名并绑定VPS服务器" class="headerlink" title="购买免费域名并绑定VPS服务器"></a>购买免费域名并绑定VPS服务器</h2><p><a href="http://www.freenom.com/zh/index.html">freenom</a> 提供了tk、ml、ga、cf、gq 这几类后缀的免费域名。tk域名，意为 Talker（说话的人）。.tk域名是南太平洋岛国托克劳的顶级域名, .ml 是非洲国家马里的后缀, .ga 域名为加蓬国家顶级域名后缀, .cf 是中非共和国的后缀, .gq域名是赤道几内亚国家地区顶级域名。</p>
<h3 id="申请freenom免费域名"><a href="#申请freenom免费域名" class="headerlink" title="申请freenom免费域名"></a>申请freenom免费域名</h3><p>访问 freenom <a href="http://www.freenom.com/zh/index.html">官方网站</a>然后直接在搜索框里面输入你想申请的域名类型，比如：freedo.ga，不是所有上面介绍的几个类型的域名后缀都是免费的，系统会自动检查域名是否免费，比如：</p>
<div style="width:707px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2021/06/30/VPS%E6%90%AD%E5%BB%BAv2ray%E6%9C%8D%E5%8A%A1%E5%99%A8/freenom1.png" class="" title="申请freedom免费域名的截图"> </div>

<p>上面显示申请 freedo.ga 这个域名是免费的，那么你就可以直接选择完成进入下一步。进入下一步后，在域名选项的最右侧有个 period 选项，你可以在它的列表里选择你想申请免费的时间，比如，我想免费申请一年，那么我选择 12 months free 这个选项：</p>
<div style="width:605px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2021/06/30/VPS%E6%90%AD%E5%BB%BAv2ray%E6%9C%8D%E5%8A%A1%E5%99%A8/freenom2.png" class="" title="申请freedom免费域名的截图"> </div>

<p>你也可以在这一步直接设置域名解析，把你的域名直接指向你的 ip，也可以跳过，在后面进行解析。 如：</p>
<div style="width:918x; margin:0px; padding:0px; align:left;"> <img src="/Blog/2021/06/30/VPS%E6%90%AD%E5%BB%BAv2ray%E6%9C%8D%E5%8A%A1%E5%99%A8/freenom3.png" class="" title="域名购买过程中解析域名的截图"> </div>

<h3 id="freenom域名解析"><a href="#freenom域名解析" class="headerlink" title="freenom域名解析"></a>freenom域名解析</h3><p>首先登录自己的账号，然后选择<code>Services-&gt;My Domains</code>,如下截图：</p>
<div style="width:458px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2021/06/30/VPS%E6%90%AD%E5%BB%BAv2ray%E6%9C%8D%E5%8A%A1%E5%99%A8/freenom6.png" class="" title="我的域名的截图"> </div>

<p>选择最右侧的<code>Manage Domains</code>(域名管理选项)，点击该选项，就可以进入域名管理界面：</p>
<div style="width:947px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2021/06/30/VPS%E6%90%AD%E5%BB%BAv2ray%E6%9C%8D%E5%8A%A1%E5%99%A8/freenom7.png" class="" title="域名管理的截图"> </div>

<div style="width:617px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2021/06/30/VPS%E6%90%AD%E5%BB%BAv2ray%E6%9C%8D%E5%8A%A1%E5%99%A8/freenom8.png" class="" title="域名管理的截图"> </div>

<p>在<code>Management Tools</code>选项下选择<code>namesservers</code>，系统默认使用的是freenom自己默认的dns服务器。你可以设定其他的dns服务器。这里我使用默认的dns服务器，先不做修改。然后点击右侧的<code>Manage Freenom DNS</code>选项，给自己的域名绑定ip 比如：</p>
<div style="width:899px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2021/06/30/VPS%E6%90%AD%E5%BB%BAv2ray%E6%9C%8D%E5%8A%A1%E5%99%A8/freenom9.png" class="" title="域名管理的截图"> </div>

<p>在 target 选项输入你域名要绑定的 ip ，在 Name 选项输入 www 或其它子域名，type 你可以根据需要进行选择。当保存成功后，你就可以直接输入域名访问你的站点了。 由于 freenom 的 dns 解析对国内可能会比较不友好，你可以修改域名默认的 dns 解析服务，把 dns解析服务修改为国内的 dns 服务，比如 CloudXNS 或者 DNSPod 。</p>
<h2 id="一键部署v2ray脚本"><a href="#一键部署v2ray脚本" class="headerlink" title="一键部署v2ray脚本"></a>一键部署v2ray脚本</h2><p>当封锁特别厉害的时候，常规的v2ray配置可能已经无法满足需求，这个时候我们可以搭建VLESS+TCP+TLS/VLESS+TCP+XTLS/VLESS+WS+TLS/VMess+TCP+TLS/VMess+WS+TLS，搭建脚本需要购买域名。(<a href="https://my.freenom.com/">免费域名</a>)<br>（VLESS+TCP+TLS/VLESS+TCP+XTLS/VLESS+WS+TLS/VMess+TCP+TLS/VMess+WS+TLS/Trojan/Trojan-Go WS）+伪装站点、七合一共存脚本，支持多内核安装，支持系统Debian 8+ / Ubuntu 16.04+ / Centos7</p>
<p>脚本安装命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate <span class="string">&quot;https://raw.githubusercontent.com/mack-a/v2ray-agent/master/install.sh&quot;</span> &amp;&amp; chmod 700 install.sh &amp;&amp; ./install.sh</span><br></pre></td></tr></table></figure>

<p>脚本执行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">==============================================================</span><br><span class="line">作者：mack-a</span><br><span class="line">当前版本：v2.5.12</span><br><span class="line">Github：https://github.com/mack-a/v2ray-agent</span><br><span class="line">描述：八合一共存脚本</span><br><span class="line">==============================================================</span><br><span class="line">1.安装</span><br><span class="line">2.任意组合安装</span><br><span class="line">-------------------------工具管理-----------------------------</span><br><span class="line">3.账号管理</span><br><span class="line">4.更换伪装站</span><br><span class="line">5.更新证书</span><br><span class="line">6.更换CDN节点</span><br><span class="line">7.IPv6分流</span><br><span class="line">8.WARP分流</span><br><span class="line">9.流媒体工具</span><br><span class="line">10.添加新端口</span><br><span class="line">-------------------------版本管理-----------------------------</span><br><span class="line">11.core管理</span><br><span class="line">12.更新脚本</span><br><span class="line">13.安装BBR、DD脚本</span><br><span class="line">-------------------------脚本管理-----------------------------</span><br><span class="line">14.查看日志</span><br><span class="line">15.卸载脚本</span><br><span class="line">==============================================================</span><br><span class="line">请选择:1</span><br><span class="line"></span><br><span class="line">功能 1/1 : 选择核心安装</span><br><span class="line"></span><br><span class="line">==============================================================</span><br><span class="line">1.Xray-core</span><br><span class="line">2.v2ray-core</span><br><span class="line">==============================================================</span><br><span class="line">请选择：2</span><br><span class="line">安装工具</span><br><span class="line"></span><br><span class="line">进度  2/17 : 安装工具</span><br><span class="line"> ---&gt; 检查、安装更新【新机器会很慢，如长时间无反应，请手动停止后重新执行】</span><br><span class="line"> ---&gt; 安装socat</span><br><span class="line"> ---&gt; 安装crontabs</span><br><span class="line"> ---&gt; 安装jq</span><br><span class="line"> ---&gt; 安装binutils</span><br><span class="line"> ---&gt; 安装qrencode</span><br><span class="line"> ---&gt; 安装lsb-release</span><br><span class="line"> ---&gt; 安装nginx</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /usr/lib/systemd/system/nginx.service.</span><br><span class="line"> ---&gt; 安装semanage</span><br><span class="line"> ---&gt; 安装acme.sh</span><br><span class="line"></span><br><span class="line">进度  3/17 : 初始化Nginx申请证书配置</span><br><span class="line"></span><br><span class="line">请输入要配置的域名 例：www.v2ray-agent.com ---&gt;</span><br><span class="line">域名:www.xxxx.tk</span><br><span class="line"></span><br><span class="line"> ---&gt; 配置Nginx</span><br><span class="line"></span><br><span class="line">检查IP是否设置为当前VPS</span><br><span class="line"> ---&gt; 检查ipv4中</span><br><span class="line"></span><br><span class="line">当前域名的IP为 [209.xx.xx.xx]，是否正确[y/n]？y</span><br><span class="line"></span><br><span class="line"> ---&gt; IP确认完成</span><br><span class="line"></span><br><span class="line">检查Nginx是否正常访问</span><br><span class="line"></span><br><span class="line"> ---&gt; Nginx配置成功</span><br><span class="line"></span><br><span class="line">进度  4/17 : 申请TLS证书</span><br><span class="line"></span><br><span class="line"> ---&gt; 安装TLS证书</span><br><span class="line"> ---&gt; TLS生成成功</span><br><span class="line"></span><br><span class="line">进度  5/17 : 配置Nginx</span><br><span class="line"></span><br><span class="line">进度  6/17 : 生成随机路径</span><br><span class="line">请输入自定义路径[例: alone]，不需要斜杠，[回车]随机路径</span><br><span class="line">路径:</span><br><span class="line">path：bqri</span><br><span class="line"></span><br><span class="line">----------------------------</span><br><span class="line"></span><br><span class="line">进度  7/17 : 安装V2Ray</span><br><span class="line"> ---&gt; v2ray-core版本:v4.41.0</span><br><span class="line"></span><br><span class="line">进度  8/17 : 配置V2Ray开机自启</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/v2ray.service to /etc/systemd/system/v2ray.service.</span><br><span class="line"> ---&gt; 配置V2Ray开机自启成功</span><br><span class="line"></span><br><span class="line">进度 11/17 : 添加DNS智能解析</span><br><span class="line"></span><br><span class="line">如对Cloudflare自选ip不了解，请选择[n]</span><br><span class="line"></span><br><span class="line"> 移动:104.16.123.96</span><br><span class="line"> 联通:hostmonit.com</span><br><span class="line"> 电信:www.digitalocean.com</span><br><span class="line">----------------------------</span><br><span class="line">是否使用？[y/n]:n</span><br><span class="line"></span><br><span class="line">进度 12/17 : 初始化V2Ray配置</span><br><span class="line"></span><br><span class="line">是否自定义UUID ？[y/n]:n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进度 14/17 : 添加定时维护证书</span><br><span class="line"></span><br><span class="line"> ---&gt; 添加定时维护证书成功</span><br><span class="line"></span><br><span class="line">进度 15/17 : 添加伪装站点</span><br><span class="line"> ---&gt; 添加伪装站点成功</span><br><span class="line"> ---&gt; V2Ray关闭成功</span><br><span class="line"> ---&gt; V2Ray启动成功</span><br><span class="line"></span><br><span class="line">进度 16/17 : 验证服务启动状态</span><br><span class="line"> ---&gt; 服务启动成功</span><br><span class="line"></span><br><span class="line">进度 17/17 : 账号</span><br></pre></td></tr></table></figure>



<h2 id="一键加速VPS服务器（五合一的TCP网络加速脚本）"><a href="#一键加速VPS服务器（五合一的TCP网络加速脚本）" class="headerlink" title="一键加速VPS服务器（五合一的TCP网络加速脚本）"></a>一键加速VPS服务器（五合一的TCP网络加速脚本）</h2><p>五合一的TCP网络加速脚本，包括了BBR原版、BBR魔改版、暴力BBR魔改版、BBR plus（首选）、Lotsever(锐速)安装脚本。可用于KVMXen架构，不兼容OpenVZ（OVZ）。支持Centos 6+ / Debian 7+ / Ubuntu 14+，BBR魔改版不支持Debian 8。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate <span class="string">&quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot;</span></span><br><span class="line"></span><br><span class="line">chmod +x tcp.sh</span><br><span class="line"></span><br><span class="line">./tcp.sh</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果提示 wget: command not found 的错误，这是你的系统精简的太干净了，wget都没有安装，所以需要安装wget。<br/>CentOS系统安装wget命令： yum install -y wget <br/>Debian/Ubuntu系统安装wget命令：apt-get install -y wget</p>
</blockquote>
<p>安装完成后，脚本管理命令为：<code>./tcp.sh</code></p>
<div style="width:511px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2021/06/30/VPS%E6%90%AD%E5%BB%BAv2ray%E6%9C%8D%E5%8A%A1%E5%99%A8/bbr%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%85.jpeg" class="" title="bbr脚本安装的截图"> </div>


<p>操作方法：先安装内核，重启vps让内核生效，再启动对应的加速即可。数字1的BBR/BBR魔改内核对应数字4、5、6的BBR加速、BBR魔改加速和暴力BBR魔改版加速。数字2的BBRplus内核对应数字7的BBRplus加速。数字3的锐速加速内核对应数字8的锐速加速。</p>
<p>以安装暴力BBR魔改版加速为例，我们先安装对应的内核，输入数字1，内核安装完成后，输入y进行重启，重启才能让内核生效：</p>
<div style="width:611px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2021/06/30/VPS%E6%90%AD%E5%BB%BAv2ray%E6%9C%8D%E5%8A%A1%E5%99%A8/bbr%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%851.jpeg" class="" title="bbr脚本安装的截图"> </div>

<p>重启完成后，输入数字6来启动暴力BBR魔改版加速</p>
<div style="width:474px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2021/06/30/VPS%E6%90%AD%E5%BB%BAv2ray%E6%9C%8D%E5%8A%A1%E5%99%A8/bbr%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%852.jpeg" class="" title="bbr脚本安装的截图"> </div>

<p>输入./tcp.sh查看最终是否启动成功。</p>
<div style="width:544px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2021/06/30/VPS%E6%90%AD%E5%BB%BAv2ray%E6%9C%8D%E5%8A%A1%E5%99%A8/bbr%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%853.jpeg" class="" title="bbr脚本安装的截图"> </div>

<div style="width:486px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2021/06/30/VPS%E6%90%AD%E5%BB%BAv2ray%E6%9C%8D%E5%8A%A1%E5%99%A8/bbr%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%854.jpeg" class="" title="bbr脚本安装的截图"> </div>
<br/>
如果想换一个加速，输入数字9进行卸载加速，然后进行同样的操作，安装内核再安装对应内核的加速即可。<br/>
<b>注意：如果在安装内核环节出现这样一张图，注意选择NO</b>
<div style="width:736px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2021/06/30/VPS%E6%90%AD%E5%BB%BAv2ray%E6%9C%8D%E5%8A%A1%E5%99%A8/bbr%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%855.jpeg" class="" title="bbr脚本安装的截图"> </div>
<br/>

<h2 id="修改服务器时区"><a href="#修改服务器时区" class="headerlink" title="修改服务器时区"></a>修改服务器时区</h2><p>a.一般国外的VPS的镜像都是默认的国外时区，使用起来不是很方便。可以把它修改成北京时间，就会方便很多。 修改中国时区代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\cp -f /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure>

<p>b.利用NTP同步时间协议 <br/><br>CentOS系统先安装NTP：<code>yum install ntp ntpdate -y</code></p>
<blockquote>
<p>如果是Ubuntu/Debian系统执行下面2条命令来安装NTP <br/></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install ntp ntpdate -y</span><br></pre></td></tr></table></figure>

<p>安装NTP后，按照顺序依次执行以下3条命令，分别是停止NTP服务、同步NTP时间、启动NTP服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service ntpd stop</span><br><span class="line"></span><br><span class="line">ntpdate us.pool.ntp.org</span><br><span class="line"></span><br><span class="line">service ntpd start</span><br></pre></td></tr></table></figure>
<p>执行完成后，VPS上就是相对精确的时间设置了。很多依赖于系统时间的应用程序也就能正常工作了。注意：当vps重启后输入date来检查下时间，如果时间不是最新的，再执行以上3条命令即可。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://my.frantech.ca/cart.php">VPS官网</a><br><a href="https://my.freenom.com/clientarea.php?action=domains">免费域名</a><br><a href="https://coderschool.cn/2197.html">免费域名解析</a><br><a href="https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAv2ray%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B">自建V2Ray教程</a><br><a href="https://github.com/yanue/V2rayU">V2Ray客户端下载地址</a></p>
]]></content>
      <categories>
        <category>VPS</category>
      </categories>
      <tags>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue CLI安装报错</title>
    <url>/Blog/2020/03/15/Vue-CLI%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>执行<code>npm install -g @vue/cli</code>安装报错，错误信息如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hu-YupingdeMacBook-Pro:~ kris$ npm install -g @vue&#x2F;cli</span><br><span class="line">npm WARN deprecated request@2.88.2: request has been deprecated, see https:&#x2F;&#x2F;github.com&#x2F;request&#x2F;request&#x2F;issues&#x2F;3142</span><br><span class="line">npm ERR! code Z_BUF_ERROR</span><br><span class="line">npm ERR! errno -5</span><br><span class="line">npm ERR! zlib: unexpected end of file</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br><span class="line">npm ERR!     &#x2F;Users&#x2F;kris&#x2F;.npm&#x2F;_logs&#x2F;2020-03-14T22_56_23_922Z-debug.log</span><br></pre></td></tr></table></figure>

<p>解决办法，切换网络，清除npm缓存，执行命令:<code>npm cache clean --force</code></p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://blog.csdn.net/zhuzhuzhihao/article/details/79753243">npm install 的时候 出现 unexpected end of file的问题</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue启动报错Error: Cannot find module &#39;webpack/bin/config-yargs&#39;</title>
    <url>/Blog/2020/03/18/Vue%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99Error-Cannot-find-module-webpack-bin-config-yargs/</url>
    <content><![CDATA[<p>今天执行<code>npm run dev</code>时出现报错，提示<code>Error: Cannot find module &#39;webpack/bin/config-yargs&#39;</code>，查资料发现问题出在，<code>webpack</code>、<code>webpack-cli</code>、<code>webpack-dev-server</code>的版本不匹配。</p>
<p>打开项目根目录下的<code>package.json</code> 文件，发现我的项目里面的配置信息为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;webpack&quot;</span>: <span class="string">&quot;^4.42.0&quot;</span>,</span><br><span class="line"><span class="string">&quot;webpack-cli&quot;</span>: <span class="string">&quot;^3.3.11&quot;</span>,</span><br><span class="line"><span class="string">&quot;webpack-dev-server&quot;</span>: <span class="string">&quot;^2.11.5&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后我修改了<code>package.json</code>文件，修改<code>webpack-dev-sever</code>的版本为<code>3.1.4</code>，然后在项目根目录执行<code>npm install</code>命令。此命令执行完毕后再执行<code>npm run dev</code>发现可以正常运行。</p>
<p>最终<code>package.json</code>文件的配置如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;babel-core&quot;: &quot;^6.26.0&quot;,</span><br><span class="line">    &quot;babel-loader&quot;: &quot;^7.1.2&quot;,</span><br><span class="line">    &quot;babel-polyfill&quot;: &quot;^6.26.0&quot;,</span><br><span class="line">    &quot;babel-preset-env&quot;: &quot;^1.6.0&quot;,</span><br><span class="line">    &quot;babel-preset-stage-3&quot;: &quot;^6.24.1&quot;,</span><br><span class="line">    &quot;babel-preset-vue&quot;: &quot;^2.0.2&quot;,</span><br><span class="line">    &quot;cross-env&quot;: &quot;^5.0.5&quot;,</span><br><span class="line">    &quot;css-loader&quot;: &quot;^3.4.2&quot;,</span><br><span class="line">    &quot;file-loader&quot;: &quot;^1.1.4&quot;,</span><br><span class="line">    &quot;vue-loader&quot;: &quot;^13.0.5&quot;,</span><br><span class="line">    &quot;vue-template-compiler&quot;: &quot;^2.4.4&quot;,</span><br><span class="line">    &quot;webpack&quot;: &quot;^4.42.0&quot;,</span><br><span class="line">    &quot;webpack-cli&quot;: &quot;^3.3.11&quot;,</span><br><span class="line">    &quot;webpack-dev-server&quot;: &quot;^3.1.4&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://blog.csdn.net/u013894429/article/details/94393342">已解决 - 问题Cannot find module ‘webpack/bin/config-yargs’</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue打包报错Error: webpack.optimize.UglifyJsPlugin has been removed, please use config.optimization.minimize instead.</title>
    <url>/Blog/2020/03/19/Vue%E6%89%93%E5%8C%85%E6%8A%A5%E9%94%99Error-webpack-optimize-UglifyJsPlugin-has-been-removed-please-use-config-optimization-minimize-instead/</url>
    <content><![CDATA[<p>使用命令<code>npm run build</code>进行生产构建时，报错<code>Error: webpack.optimize.UglifyJsPlugin has been removed, please use config.optimization.minimize instead.</code>，详细的错误信息如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">^CHu-YupingdeMacBook-Pro:demo2 kris$ npm run build</span><br><span class="line"></span><br><span class="line">&gt; demo2@1.0.0 build /Users/kris/Documents/VueDemo/chapter4/demo2</span><br><span class="line">&gt; cross-env NODE_ENV=production webpack --progress --hide-modules</span><br><span class="line"></span><br><span class="line">/Users/kris/Documents/VueDemo/chapter4/demo2/node_modules/webpack-cli/bin/cli.js:93</span><br><span class="line">				throw err;</span><br><span class="line">				^</span><br><span class="line"></span><br><span class="line">Error: webpack.optimize.UglifyJsPlugin has been removed, please use config.optimization.minimize instead.</span><br><span class="line">    at Object.get [as UglifyJsPlugin] (/Users/kris/Documents/VueDemo/chapter4/demo2/node_modules/webpack/lib/webpack.js:189:10)</span><br><span class="line">    at Object.&lt;anonymous&gt; (/Users/kris/Documents/VueDemo/chapter4/demo2/webpack.config.js:68:26)</span><br><span class="line">    at Module._compile (/Users/kris/Documents/VueDemo/chapter4/demo2/node_modules/v8-compile-cache/v8-compile-cache.js:192:30)</span><br><span class="line">    at Object.Module._extensions..js (internal/modules/cjs/loader.js:712:10)</span><br><span class="line">    at Module.load (internal/modules/cjs/loader.js:600:32)</span><br><span class="line">    at tryModuleLoad (internal/modules/cjs/loader.js:539:12)</span><br><span class="line">    at Function.Module._load (internal/modules/cjs/loader.js:531:3)</span><br><span class="line">    at Module.require (internal/modules/cjs/loader.js:637:17)</span><br><span class="line">    at require (/Users/kris/Documents/VueDemo/chapter4/demo2/node_modules/v8-compile-cache/v8-compile-cache.js:161:20)</span><br><span class="line">    at WEBPACK_OPTIONS (/Users/kris/Documents/VueDemo/chapter4/demo2/node_modules/webpack-cli/bin/utils/convert-argv.js:114:13)</span><br><span class="line">    at requireConfig (/Users/kris/Documents/VueDemo/chapter4/demo2/node_modules/webpack-cli/bin/utils/convert-argv.js:116:6)</span><br><span class="line">    at /Users/kris/Documents/VueDemo/chapter4/demo2/node_modules/webpack-cli/bin/utils/convert-argv.js:123:17</span><br><span class="line">    at Array.forEach (&lt;anonymous&gt;)</span><br><span class="line">    at module.exports (/Users/kris/Documents/VueDemo/chapter4/demo2/node_modules/webpack-cli/bin/utils/convert-argv.js:121:15)</span><br><span class="line">    at yargs.parse (/Users/kris/Documents/VueDemo/chapter4/demo2/node_modules/webpack-cli/bin/cli.js:71:45)</span><br><span class="line">    at Object.parse (/Users/kris/Documents/VueDemo/chapter4/demo2/node_modules/yargs/yargs.js:567:18)</span><br><span class="line">    at /Users/kris/Documents/VueDemo/chapter4/demo2/node_modules/webpack-cli/bin/cli.js:49:8</span><br><span class="line">    at Object.&lt;anonymous&gt; (/Users/kris/Documents/VueDemo/chapter4/demo2/node_modules/webpack-cli/bin/cli.js:366:3)</span><br><span class="line">    at Module._compile (internal/modules/cjs/loader.js:701:30)</span><br><span class="line">    at Object.Module._extensions..js (internal/modules/cjs/loader.js:712:10)</span><br><span class="line">    at Module.load (internal/modules/cjs/loader.js:600:32)</span><br><span class="line">    at tryModuleLoad (internal/modules/cjs/loader.js:539:12)</span><br><span class="line">    at Function.Module._load (internal/modules/cjs/loader.js:531:3)</span><br><span class="line">    at Module.require (internal/modules/cjs/loader.js:637:17)</span><br><span class="line">    at require (internal/modules/cjs/helpers.js:22:18)</span><br><span class="line">    at Object.&lt;anonymous&gt; (/Users/kris/Documents/VueDemo/chapter4/demo2/node_modules/webpack/bin/webpack.js:156:2)</span><br><span class="line">    at Module._compile (internal/modules/cjs/loader.js:701:30)</span><br><span class="line">    at Object.Module._extensions..js (internal/modules/cjs/loader.js:712:10)</span><br><span class="line">    at Module.load (internal/modules/cjs/loader.js:600:32)</span><br><span class="line">    at tryModuleLoad (internal/modules/cjs/loader.js:539:12)</span><br><span class="line">npm ERR! code ELIFECYCLE</span><br><span class="line">npm ERR! errno 1</span><br><span class="line">npm ERR! demo2@1.0.0 build: `cross-env NODE_ENV=production webpack --progress --hide-modules`</span><br><span class="line">npm ERR! Exit status 1</span><br><span class="line">npm ERR! </span><br><span class="line">npm ERR! Failed at the demo2@1.0.0 build script.</span><br><span class="line">npm ERR! This is probably not a problem with npm. There is likely additional logging output above.</span><br><span class="line"></span><br><span class="line">npm ERR! A complete <span class="built_in">log</span> of this run can be found <span class="keyword">in</span>:</span><br><span class="line">npm ERR!     /Users/kris/.npm/_logs/2020-03-19T04_56_08_555Z-debug.log</span><br></pre></td></tr></table></figure>

<p>查资料发现webpack4已经不支持在plugins里面操作<code>UglifyJsPlugin</code>，需要将<code>UglifyJsPlugin</code>放到<code>optimization</code>里面进行配置。打开<code>webpack.config.js</code>文件，发现老的配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var path = require(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line">var webpack = require(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">    publicPath: <span class="string">&#x27;/dist/&#x27;</span>,</span><br><span class="line">    filename: <span class="string">&#x27;build.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">test</span>: /\.css$/,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&#x27;vue-style-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">      &#125;,      &#123;</span><br><span class="line">        <span class="built_in">test</span>: /\.vue$/,</span><br><span class="line">        loader: <span class="string">&#x27;vue-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          loaders: &#123;</span><br><span class="line">          &#125;</span><br><span class="line">          // other vue-loader options go here</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">test</span>: /\.js$/,</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        exclude: /node_modules/</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">test</span>: /\.(png|jpg|gif|svg)$/,</span><br><span class="line">        loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">&#x27;[name].[ext]?[hash]&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="built_in">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [<span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">    noInfo: <span class="literal">true</span>,</span><br><span class="line">    overlay: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  performance: &#123;</span><br><span class="line">    hints: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">&#x27;#eval-source-map&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  module.exports.devtool = <span class="string">&#x27;#source-map&#x27;</span></span><br><span class="line">  // http://vue-loader.vuejs.org/en/workflow/production.html</span><br><span class="line">  module.exports.plugins = (module.exports.plugins || []).concat([</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">&#x27;process.env&#x27;</span>: &#123;</span><br><span class="line">        NODE_ENV: <span class="string">&#x27;&quot;production&quot;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    new webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">      sourceMap: <span class="literal">true</span>,</span><br><span class="line">      compress: &#123;</span><br><span class="line">        warnings: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    new webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">      minimize: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改完的<code>webpack.config.js</code>文件内容如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var path = require(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line">var webpack = require(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="built_in">let</span> UglifyJsPlugin = require(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">    publicPath: <span class="string">&#x27;/dist/&#x27;</span>,</span><br><span class="line">    filename: <span class="string">&#x27;build.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">test</span>: /\.css$/,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&#x27;vue-style-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">      &#125;,      &#123;</span><br><span class="line">        <span class="built_in">test</span>: /\.vue$/,</span><br><span class="line">        loader: <span class="string">&#x27;vue-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          loaders: &#123;</span><br><span class="line">          &#125;</span><br><span class="line">          // other vue-loader options go here</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">test</span>: /\.js$/,</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        exclude: /node_modules/</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">test</span>: /\.(png|jpg|gif|svg)$/,</span><br><span class="line">        loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">&#x27;[name].[ext]?[hash]&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="built_in">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [<span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">    noInfo: <span class="literal">true</span>,</span><br><span class="line">    overlay: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  performance: &#123;</span><br><span class="line">    hints: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      new UglifyJsPlugin(&#123;</span><br><span class="line">        uglifyOptions: &#123;</span><br><span class="line">          compress: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">&#x27;#eval-source-map&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  module.exports.devtool = <span class="string">&#x27;#source-map&#x27;</span></span><br><span class="line">  // http://vue-loader.vuejs.org/en/workflow/production.html</span><br><span class="line">  module.exports.plugins = (module.exports.plugins || []).concat([</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">&#x27;process.env&#x27;</span>: &#123;</span><br><span class="line">        NODE_ENV: <span class="string">&#x27;&quot;production&quot;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    new webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">      minimize: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改动之处有2处，第一处，把<code>UglifyJsPlugin</code>放到上面的exports的<code>optimization</code>中；第二处，在文件开头之处导入<code>UglifyJsPlugin</code>。</p>
<p>改完之后执行<code>npm run dev</code>，效果如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hu-YupingdeMacBook-Pro:demo2 kris$ npm run dev</span><br><span class="line"></span><br><span class="line">&gt; demo2@1.0.0 dev /Users/kris/Documents/VueDemo/chapter4/demo2</span><br><span class="line">&gt; cross-env NODE_ENV=development webpack-dev-server --open --hot</span><br></pre></td></tr></table></figure>

<p>改完之后执行<code>npm run build</code>，效果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">^CHu-YupingdeMacBook-Pro:demo2 kris$ npm run build</span><br><span class="line"></span><br><span class="line">&gt; demo2@1.0.0 build /Users/kris/Documents/VueDemo/chapter4/demo2</span><br><span class="line">&gt; cross-env NODE_ENV=production webpack --progress --hide-modules</span><br><span class="line"></span><br><span class="line">Hash: e1e94d754213e6db3b2c</span><br><span class="line">Version: webpack 4.42.0</span><br><span class="line">Time: 1996ms</span><br><span class="line">Built at: 2020-03-19 13:51:57</span><br><span class="line">   Asset     Size  Chunks             Chunk Names</span><br><span class="line">build.js  213 KiB       0  [emitted]  main</span><br><span class="line">Entrypoint main = build.js</span><br><span class="line"></span><br><span class="line">WARNING <span class="keyword">in</span> configuration</span><br><span class="line">The <span class="string">&#x27;mode&#x27;</span> option has not been <span class="built_in">set</span>, webpack will fallback to <span class="string">&#x27;production&#x27;</span> <span class="keyword">for</span> this value. Set <span class="string">&#x27;mode&#x27;</span> option to <span class="string">&#x27;development&#x27;</span> or <span class="string">&#x27;production&#x27;</span> to <span class="built_in">enable</span> defaults <span class="keyword">for</span> each environment.</span><br><span class="line">You can also <span class="built_in">set</span> it to <span class="string">&#x27;none&#x27;</span> to <span class="built_in">disable</span> any default behavior. Learn more: https://webpack.js.org/configuration/mode/</span><br></pre></td></tr></table></figure>



<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.jianshu.com/p/ceaf950a027b">webpack踩坑之路</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 12越狱</title>
    <url>/Blog/2021/01/03/iOS-12%E8%B6%8A%E7%8B%B1/</url>
    <content><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul>
<li>1.一台iPhone6 Plus设备，系统版本：iOS 12.4.8。</li>
<li>2.一台MAC电脑，并且已经安装Xcode或者iTools。</li>
</ul>
<h1 id="越狱步骤"><a href="#越狱步骤" class="headerlink" title="越狱步骤"></a>越狱步骤</h1><p>第一步，下载uncOver最新版本ipa文件，前往<a href="https://unc0ver.dev/">官网下载</a>。uncOver是一个越狱工具，首先在手机上安装这个App，然后打开App，进行越狱。</p>
<img src="/Blog/2021/01/03/iOS-12%E8%B6%8A%E7%8B%B1/1.png" class="" title="uncOver官网截图">

<p>第二步，下载App重签名工具，前往<a href="https://dantheman827.github.io/ios-app-signer/">Github下载</a>。</p>
<img src="/Blog/2021/01/03/iOS-12%E8%B6%8A%E7%8B%B1/2.jpeg" class="" title="AppSigner下载截图">

<p>第三步，根据uncOver官网提示，对第一步下载的ipa文件进行重签名，目的是重签名过后可以直接安装到我们自己的手机里。</p>
<img src="/Blog/2021/01/03/iOS-12%E8%B6%8A%E7%8B%B1/4.jpg" class="" title="官网破解步骤截图">
<img src="/Blog/2021/01/03/iOS-12%E8%B6%8A%E7%8B%B1/3.jpg" class="" title="重签名截图">
<img src="/Blog/2021/01/03/iOS-12%E8%B6%8A%E7%8B%B1/5.jpg" class="" title="重签名完成后的ipa截图">

<p>第四步，将重签名过后的ipa文件安装到手机上，官网建议通过Xcode安装，我使用电脑上的iTools Pro安装，最终安装完成截图如下。</p>
<img src="/Blog/2021/01/03/iOS-12%E8%B6%8A%E7%8B%B1/6.png" class="" title="安装uncOver截图">

<p>第五步，打开uncOver App，点击<code>Jailbreak</code>按钮，开始越狱。在越狱过程中，可能会提示越狱失败，请重新打开App再次尝试越狱。如果一直重启手机无法继续越狱，请尝试在飞行模式下点击<code>Jailbreak</code>按钮。如果中途弹框提示购买手机壳，请不要理会，越狱程序会一直在操作，不会因为你不购买手机壳就停止越狱哦。如果一直越狱失败，请多多尝试几次。</p>
<img src="/Blog/2021/01/03/iOS-12%E8%B6%8A%E7%8B%B1/11.png" class="" title="开启uncOver的截图">
<img src="/Blog/2021/01/03/iOS-12%E8%B6%8A%E7%8B%B1/12.png" class="" title="uncOver破解中的截图">

<p>第六步，越狱完成，会弹出重启手机的Alert。在越狱过程中也可能会多次重启手机。最终破解完成后，手机桌面会出现<code>Cydia</code>App。再次打开uncOver App，原本显示<code>Jailbreak</code>的按钮现在显示<code>Re-Jailbreak</code>。</p>
<img src="/Blog/2021/01/03/iOS-12%E8%B6%8A%E7%8B%B1/13.png" class="" title="越狱完成后弹框提示重启手机的截图">
<img src="/Blog/2021/01/03/iOS-12%E8%B6%8A%E7%8B%B1/7.png" class="" title="越狱完成重启手机后的截图">
<img src="/Blog/2021/01/03/iOS-12%E8%B6%8A%E7%8B%B1/8.png" class="" title="Cydia的截图">
<img src="/Blog/2021/01/03/iOS-12%E8%B6%8A%E7%8B%B1/9.png" class="" title="UncOver显示“Re-Jailbreak”的截图">


<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://unc0ver.dev/">unc0ver官网</a><br><a href="https://dantheman827.github.io/ios-app-signer/">iOS App Signer官网</a><br><a href="https://mrmad.com.tw/unc0ver-ios12">越獄教學</a><br><a href="https://jingyan.baidu.com/article/a948d651b8edaa4b2ccd2e78.html">unc0ver闪退解决方法</a></p>
]]></content>
      <categories>
        <category>iOS越狱</category>
      </categories>
      <tags>
        <tag>iOS越狱</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS使用SVG和PDF图片</title>
    <url>/Blog/2019/11/07/iOS%E4%BD%BF%E7%94%A8SVG%E5%92%8CPDF%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h2 id="什么是SVG"><a href="#什么是SVG" class="headerlink" title="什么是SVG?"></a>什么是SVG?</h2><p>SVG是一种用XML定义的语言，用来描述二维矢量及矢量/栅格图形。</p>
<h2 id="SVG有哪些优势？"><a href="#SVG有哪些优势？" class="headerlink" title="SVG有哪些优势？"></a>SVG有哪些优势？</h2><p>参与定义 SVG 的组织有：太阳微系统、Adobe、苹果公司、IBM 以及柯达。<br>与其他图像格式相比，使用 SVG 的优势在于：<br>●SVG 可被非常多的工具读取和修改（比如记事本）<br>●SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。<br>●SVG 是可伸缩的<br>●SVG 图像可在任何的分辨率下被高质量地打印<br>●SVG 可在图像质量不下降的情况下被放大<br>●SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）<br>●SVG 可以与 JavaScript 技术一起运行<br>●SVG 是开放的标准<br>●SVG 文件是纯粹的 XML<br>●SVG 的主要竞争者是 Flash。</p>
<h2 id="SVG在iOS中有哪些劣势？"><a href="#SVG在iOS中有哪些劣势？" class="headerlink" title="SVG在iOS中有哪些劣势？"></a>SVG在iOS中有哪些劣势？</h2><p>●Xcode 6以后支持矢量图,原生支持pdf格式<br>●原生不支持SVG格式(因为svg本质是xml),如果要加载SVG格式,使用WebView或第三方框架<br>●原生中如果使用SVG格式的图片，不能放在Assets.xcassets中，要像本地文件或者网络文件一样给个地址，存放起来有点麻烦<br>●集成起来麻烦<br>●只支持放大缩小，颜色修改需要另外的分类来支持<br>●不支持带滤镜的SVG<br>●UIButton使用SVG时，需要设置Button的Type为Custom，否则改变颜色的时候，没有效果。</p>
<h2 id="iOS使用第三方框架加载svg格式"><a href="#iOS使用第三方框架加载svg格式" class="headerlink" title="iOS使用第三方框架加载svg格式"></a>iOS使用第三方框架加载svg格式</h2><p>iOS中使用 SVGKit(Objective-C库)和 Macaw(Swift库)。</p>
<h2 id="iOS中使用PDF格式的图片"><a href="#iOS中使用PDF格式的图片" class="headerlink" title="iOS中使用PDF格式的图片"></a>iOS中使用PDF格式的图片</h2><p>在Asset.xcassets中添加一张图片，选择Attributes inspector，scales设置成SingleScale，原来3个占位图的位置会变成1个占位图的位置。在这个占位图中拖入一个pdf格式的图片。iOS系统会根据PDF格式的图片自动生成@1x、@2x和@3x图，对应适配不同的屏幕。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a><a href="https://files-cdn.cnblogs.com/files/wobuyayi/SVG%E5%92%8CPDF%E9%A2%84%E6%BC%94.zip">Demo</a></h2><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h3><p><a href="https://baike.baidu.com/item/SVG%E6%A0%BC%E5%BC%8F/3463453?fr=aladdin">百度百科SVG格式</a><br><a href="https://www.jianshu.com/p/e4fe82ca6fd0">Xcode项目中使用矢量图(pdf,svg)</a><br><a href="http://blog.startry.com/2016/06/15/vector-apply-to-iOS-Project/">矢量图在iOS中的应用细节</a><br><a href="https://www.jianshu.com/p/aca8f6976acf">iOS开发APP瘦身之PDF图片资源加载框架</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS创建Framwork工程步骤</title>
    <url>/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h2 id="1-新建远程Git仓库，将空的仓库克隆至本地。"><a href="#1-新建远程Git仓库，将空的仓库克隆至本地。" class="headerlink" title="1.新建远程Git仓库，将空的仓库克隆至本地。"></a>1.新建远程Git仓库，将空的仓库克隆至本地。</h2><p>在gitlab上新建一个空的仓库。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/1.png" class="" title="新建远程Git截图">

<h2 id="2-创建SDK项目，创建项目时选Framework。"><a href="#2-创建SDK项目，创建项目时选Framework。" class="headerlink" title="2.创建SDK项目，创建项目时选Framework。"></a>2.创建SDK项目，创建项目时选Framework。</h2><p>创建项目时选Framework。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/2.png" class="" title="创建SDK项目截图1">

<p>将项目的目录新建到Git的文件夹中。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/3.png" class="" title="创建SDK项目截图2">

<h2 id="3-创建SDK项目的Example工程。Exmaple工程的根目录需要在SDK的根目录中。"><a href="#3-创建SDK项目的Example工程。Exmaple工程的根目录需要在SDK的根目录中。" class="headerlink" title="3.创建SDK项目的Example工程。Exmaple工程的根目录需要在SDK的根目录中。"></a>3.创建SDK项目的Example工程。Exmaple工程的根目录需要在SDK的根目录中。</h2><p>创建Example工程。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/4.png" class="" title="创建Example项目截图1">

<p>填写Example工程名。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/5.png" class="" title="创建Example项目截图2">

<p>选择工程的目录。将工程根目录创建到SDK工程根目录下。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/6.png" class="" title="创建Example项目截图3">

<p>最终的项目目录结构如图。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/7.png" class="" title="创建Example项目截图4">

<h2 id="4-在SDK工程目录中创建Podfile文件。"><a href="#4-在SDK工程目录中创建Podfile文件。" class="headerlink" title="4.在SDK工程目录中创建Podfile文件。"></a>4.在SDK工程目录中创建Podfile文件。</h2><p>执行<code>pod init</code>命令，在工程目录中创建Podfile文件。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/8.png" class="" title="创建Podfile截图">

<h2 id="5-编辑podfile文件，指定workspace，添加example和sdk工程的target，target中需要指定-xcodeproj文件的路径；workspace可以提前建好然后指定，如果指定的workspace文件不错在，cocoapods会自动创建，所以只需要在podfile文件中写入想要的workspace的名字；编辑完成后保存。"><a href="#5-编辑podfile文件，指定workspace，添加example和sdk工程的target，target中需要指定-xcodeproj文件的路径；workspace可以提前建好然后指定，如果指定的workspace文件不错在，cocoapods会自动创建，所以只需要在podfile文件中写入想要的workspace的名字；编辑完成后保存。" class="headerlink" title="5.编辑podfile文件，指定workspace，添加example和sdk工程的target，target中需要指定.xcodeproj文件的路径；workspace可以提前建好然后指定，如果指定的workspace文件不错在，cocoapods会自动创建，所以只需要在podfile文件中写入想要的workspace的名字；编辑完成后保存。"></a>5.编辑podfile文件，指定workspace，添加example和sdk工程的target，target中需要指定.xcodeproj文件的路径；workspace可以提前建好然后指定，如果指定的workspace文件不错在，cocoapods会自动创建，所以只需要在podfile文件中写入想要的workspace的名字；编辑完成后保存。</h2><p>编辑Podfile文件，将example和sdk工程的target添加到Podfile中。注意example工程的target路径。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/9.png" class="" title="编辑Podfile截图">

<h2 id="6-执行命令Pod-install，cocoapods自动创建workspace文件，workspace文件打开前要把workspace关联的工程关闭。"><a href="#6-执行命令Pod-install，cocoapods自动创建workspace文件，workspace文件打开前要把workspace关联的工程关闭。" class="headerlink" title="6.执行命令Pod install，cocoapods自动创建workspace文件，workspace文件打开前要把workspace关联的工程关闭。"></a>6.执行命令Pod install，cocoapods自动创建workspace文件，workspace文件打开前要把workspace关联的工程关闭。</h2><p>执行Pod install命令，让Pod自动生成workspace文件。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/10.png" class="" title="pod install截图1">

<p>选择workspance文件，打开工程。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/11.png" class="" title="pod install截图2">

<p>打开工程后，目录结构如下图。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/12.png" class="" title="pod install截图3">

<h2 id="7-将文件放入工程，建议先将文件复制到framework工程的文件夹中，可以方便文件夹结构调整并重命名，最后将文件添加到工程，保证target选择正确。"><a href="#7-将文件放入工程，建议先将文件复制到framework工程的文件夹中，可以方便文件夹结构调整并重命名，最后将文件添加到工程，保证target选择正确。" class="headerlink" title="7.将文件放入工程，建议先将文件复制到framework工程的文件夹中，可以方便文件夹结构调整并重命名，最后将文件添加到工程，保证target选择正确。"></a>7.将文件放入工程，建议先将文件复制到framework工程的文件夹中，可以方便文件夹结构调整并重命名，最后将文件添加到工程，保证target选择正确。</h2><p>将SDK工程目录下的源代码目录Sources和资源文件目录Resources添加到SDK工程中。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/13.png" class="" title="SDK工程添加源文件目录和资源文件目录截图">

<h2 id="8-编辑podfile文件，添加依赖项，放在target外部意思是两个target都需要引入这些库，但是不管放在内部还是外部，Pod文件夹中引入的第三方库是他们的总和。"><a href="#8-编辑podfile文件，添加依赖项，放在target外部意思是两个target都需要引入这些库，但是不管放在内部还是外部，Pod文件夹中引入的第三方库是他们的总和。" class="headerlink" title="8.编辑podfile文件，添加依赖项，放在target外部意思是两个target都需要引入这些库，但是不管放在内部还是外部，Pod文件夹中引入的第三方库是他们的总和。"></a>8.编辑podfile文件，添加依赖项，放在target外部意思是两个target都需要引入这些库，但是不管放在内部还是外部，Pod文件夹中引入的第三方库是他们的总和。</h2><p>编辑Podfile文件，将依赖项放到target外部。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/14.png" class="" title="编辑Podfile文件，添加依赖截图">

<h2 id="9-工程根目录中创建podspec文件，创建license文件，编辑podspec基本项目（descritpion-license-source-homepage-source-files-resources）。"><a href="#9-工程根目录中创建podspec文件，创建license文件，编辑podspec基本项目（descritpion-license-source-homepage-source-files-resources）。" class="headerlink" title="9.工程根目录中创建podspec文件，创建license文件，编辑podspec基本项目（descritpion, license, source, homepage, source_files., resources）。"></a>9.工程根目录中创建podspec文件，创建license文件，编辑podspec基本项目（descritpion, license, source, homepage, source_files., resources）。</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod spec create <span class="string">&quot;组件名&quot;</span></span><br></pre></td></tr></table></figure>

<p>命令行创建podspec文件。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/15.png" class="" title="新建podspec文件截图">

<p>将podspec文件添加到工程中。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/16.png" class="" title="将podspec文件添加到工程中截图">

<p>编辑podspec文件。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/17.png" class="" title="编辑podspec文件截图">

<h2 id="10-执行pod-install。"><a href="#10-执行pod-install。" class="headerlink" title="10.执行pod install。"></a>10.执行pod install。</h2><h2 id="11-将framework工程的Products文件夹中的framework文件放入Framewors-Link配置中。"><a href="#11-将framework工程的Products文件夹中的framework文件放入Framewors-Link配置中。" class="headerlink" title="11.将framework工程的Products文件夹中的framework文件放入Framewors Link配置中。"></a>11.将framework工程的Products文件夹中的framework文件放入Framewors Link配置中。</h2><p>将项目中生成的Framework库文件添加到Exmaple工程中。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/18.png" class="" title="将framweork库添加到Example项目截图">

<h2 id="12-使用example或者framework工程的scheme来调试，解决由于文件冲突或者头文件引用方式导致的编译不通过的问题。"><a href="#12-使用example或者framework工程的scheme来调试，解决由于文件冲突或者头文件引用方式导致的编译不通过的问题。" class="headerlink" title="12.使用example或者framework工程的scheme来调试，解决由于文件冲突或者头文件引用方式导致的编译不通过的问题。"></a>12.使用example或者framework工程的scheme来调试，解决由于文件冲突或者头文件引用方式导致的编译不通过的问题。</h2><p>选择PHUpdateSDK的Target，编译测试SDK是否可以正常编译通过。选择PHUpdateSDKExample的Target运行测试代码，查看SDK功能是否正常工作。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/19.png" class="" title="编译Example项目截图">

<h2 id="13-将SDK中的头文件都添加到对应的SDK头文件中。"><a href="#13-将SDK中的头文件都添加到对应的SDK头文件中。" class="headerlink" title="13.将SDK中的头文件都添加到对应的SDK头文件中。"></a>13.将SDK中的头文件都添加到对应的SDK头文件中。</h2><p>将SDK中需要暴露出来的.h文件都添加到PHUpdateSDK.h中。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/20.png" class="" title="添加头文件到SDK头文件截图">

<h2 id="14-将SDK中的头文件移动到外面"><a href="#14-将SDK中的头文件移动到外面" class="headerlink" title="14.将SDK中的头文件移动到外面"></a>14.将SDK中的头文件移动到外面</h2><p>将SDK中的头文件从项目中移动到Public Group中。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/21.png" class="" title="移动头文件到Public截图">

<h2 id="15-在Example工程中引入SDK中的类"><a href="#15-在Example工程中引入SDK中的类" class="headerlink" title="15.在Example工程中引入SDK中的类"></a>15.在Example工程中引入SDK中的类</h2><p>在Example工程中导入SDK中的类，测试SDK中的类是否可以正常工作。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/22.png" class="" title="在Example中引入SDK头文件截图">

<h2 id="16-在Example中测试SDK代码功能"><a href="#16-在Example中测试SDK代码功能" class="headerlink" title="16.在Example中测试SDK代码功能"></a>16.在Example中测试SDK代码功能</h2><p>在Example工程中测试SDK代码是否正常工作</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/23.png" class="" title="在Example工程中运行测试代码.png">

<h2 id="17-创建一个空工程或者利用已有工程作为pod管理，以本地路径的方式pod引入sdk，执行pod-install，打开该工程，可以更好的编辑podspec文件，并且在编辑好后可以立即使用pod-install命令查看修改结果；全部完成后，可以将pod方式改为使用git地址的方式，查看真实使用效果。"><a href="#17-创建一个空工程或者利用已有工程作为pod管理，以本地路径的方式pod引入sdk，执行pod-install，打开该工程，可以更好的编辑podspec文件，并且在编辑好后可以立即使用pod-install命令查看修改结果；全部完成后，可以将pod方式改为使用git地址的方式，查看真实使用效果。" class="headerlink" title="17.创建一个空工程或者利用已有工程作为pod管理，以本地路径的方式pod引入sdk，执行pod install，打开该工程，可以更好的编辑podspec文件，并且在编辑好后可以立即使用pod install命令查看修改结果；全部完成后，可以将pod方式改为使用git地址的方式，查看真实使用效果。"></a>17.创建一个空工程或者利用已有工程作为pod管理，以本地路径的方式pod引入sdk，执行pod install，打开该工程，可以更好的编辑podspec文件，并且在编辑好后可以立即使用pod install命令查看修改结果；全部完成后，可以将pod方式改为使用git地址的方式，查看真实使用效果。</h2><p>新建本地测试工程，在本地测试工程的Podfile文件中导入SDK工程。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/24.png" class="" title="本地工程打开截图">

<p>查看本地工程Podfile如何配置。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/25.png" class="" title="本地工程Podfile配置截图">

<h2 id="18-经过最后的修改，最终目录如下。"><a href="#18-经过最后的修改，最终目录如下。" class="headerlink" title="18.经过最后的修改，最终目录如下。"></a>18.经过最后的修改，最终目录如下。</h2><p>由于之前的SDK目录比较深，导致<code>pod update</code>的时候无法更新。所以将之前的SDK中的文件全部拷贝到git仓库的根目录下。还有LICENSE文件最好放一个，因为有可能因为这个导致最终的项目更新失败。最终目录结构如下图。</p>
<img src="/Blog/2020/02/19/iOS%E5%88%9B%E5%BB%BAFramwork%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4/26.png" class="" title="最终目录结构截图">]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS安装包瘦身</title>
    <url>/Blog/2020/08/01/iOS%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB/</url>
    <content><![CDATA[<img src="/Blog/2020/08/01/iOS%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB/iOS%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB.png" class="" title="iOS安装包瘦身思维导图">

<h2 id="iPA解压排查"><a href="#iPA解压排查" class="headerlink" title="iPA解压排查"></a>iPA解压排查</h2><p>iOS安装包瘦身时，最直接的办法就是，解压打包完的iPA，查找大文件，优化对应的大文件。</p>
<img src="/Blog/2020/08/01/iOS%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB/ipa.png" class="" title="iPA解压后内部截图">

<ul>
<li><p>_CodeSignature：文件hash列表。里面有一个属性列表文件CodeResources，包含.app中所有文件的列表，里面是一个字典，key是文件名，value通常是Base64格式的散列值。它的作用是用来判断应用程序是否完好无损，防止资源文件修改损坏。</p>
</li>
<li><p>Assets.car：由.xcassets统一打包生成。包含所有.xcassets下的资源文件.xcassets可以存放图片资源，组织清晰，便于管理，Xcode也会对一些资源做优化处理。如果直接放在Xcode工程目录下，打包后这些资源会在包的根目录下面展示。Assets.car可以通过Asset Catalog Tinkerer软件打开，并导出相关资源。</p>
</li>
<li><p>embedded.mobileprovision：描述文件</p>
</li>
<li><p>Info.plist：工程信息配置文件</p>
</li>
<li><p>YXTDemo：与工程同名的可执行文件。可以通过file命令查看类型。</p>
</li>
</ul>
<h2 id="图片资源优化"><a href="#图片资源优化" class="headerlink" title="图片资源优化"></a>图片资源优化</h2><h3 id="删除未使用的图片资源"><a href="#删除未使用的图片资源" class="headerlink" title="删除未使用的图片资源"></a>删除未使用的图片资源</h3><p>可以使用工具LSUnusedResources工具查找未使用的图片资源，工具下载地址：<a href="https://github.com/tinymind/LSUnusedResources%E3%80%82">https://github.com/tinymind/LSUnusedResources。</a></p>
<img src="/Blog/2020/08/01/iOS%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB/lsunusedresources.png" class="" title="查找未使用的图片的截图1">
<img src="/Blog/2020/08/01/iOS%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB/lsunusedresources2.png" class="" title="查找未使用的图片的截图2">

<h3 id="压缩图标和图片"><a href="#压缩图标和图片" class="headerlink" title="压缩图标和图片"></a>压缩图标和图片</h3><p>对于一些较大的图标和图片可以使用工具ImageOptim压缩一下。</p>
<img src="/Blog/2020/08/01/iOS%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB/imageoptim1.png" class="" title="图片压缩工具截图">
<img src="/Blog/2020/08/01/iOS%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB/imageoptim2.png" class="" title="图片压缩工具截图">
<img src="/Blog/2020/08/01/iOS%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB/imageoptim3.png" class="" title="图片压缩工具截图">
<img src="/Blog/2020/08/01/iOS%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB/imageoptim4.png" class="" title="图片压缩工具截图">

<h3 id="特殊大图放工程目录下"><a href="#特殊大图放工程目录下" class="headerlink" title="特殊大图放工程目录下"></a>特殊大图放工程目录下</h3><p>大图(例如游戏界面背景图)若放在.xcassets文件夹中，工程打包后大图的尺寸会变大，因此建议特定大图不要放在.xcassets中，放在工程目录下即可。</p>
<h2 id="删除冗余代码"><a href="#删除冗余代码" class="headerlink" title="删除冗余代码"></a>删除冗余代码</h2><h3 id="删除未使用的类文件"><a href="#删除未使用的类文件" class="headerlink" title="删除未使用的类文件"></a>删除未使用的类文件</h3><p>使用CATClearProjectTool工具查找未使用的类，删除即可。</p>
<img src="/Blog/2020/08/01/iOS%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB/catclearprojecttool1.png" class="" title="查找未使用的类">
<img src="/Blog/2020/08/01/iOS%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB/catclearprojecttool2.png" class="" title="查找未使用的类">

<h3 id="使用LinkMap分析类文件和静态库的大小"><a href="#使用LinkMap分析类文件和静态库的大小" class="headerlink" title="使用LinkMap分析类文件和静态库的大小"></a>使用LinkMap分析类文件和静态库的大小</h3><p>使用LinkMap工具可以分析具体类文件和静态库大小，工具下载地址：<a href="https://github.com/huanxsd/LinkMap%E3%80%82">https://github.com/huanxsd/LinkMap。</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS定时器</title>
    <url>/Blog/2020/09/23/iOS%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="NSTimer如何使用"><a href="#NSTimer如何使用" class="headerlink" title="NSTimer如何使用"></a>NSTimer如何使用</h2><blockquote>
<p>方法1: Creates a timer and schedules it on the current run loop in the default mode.</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti </span><br><span class="line">                                     target:(<span class="keyword">id</span>)aTarget </span><br><span class="line">                                   selector:(SEL)aSelector </span><br><span class="line">                                   userInfo:(<span class="keyword">id</span>)userInfo </span><br><span class="line">                                    repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>方法2: Initializes a timer object with the specified object and selector.</p>
</blockquote>
<blockquote>
<p>You must add the new timer to a run loop, using <strong>addTimer:forMode:</strong>. Then, after ti seconds have elapsed, the timer fires, sending the message aSelector to target. (If the timer is configured to repeat, there is no need to subsequently re-add the timer to the run loop.)</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti </span><br><span class="line">                            target:(<span class="keyword">id</span>)aTarget </span><br><span class="line">                          selector:(SEL)aSelector </span><br><span class="line">                          userInfo:(<span class="keyword">id</span>)userInfo </span><br><span class="line">                           repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line"></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:<span class="keyword">self</span>.timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br></pre></td></tr></table></figure>

<p>这两个方法是等价的，区别是第一个方法默认创建了一个NSTimer并自动添加到了当前线程的Runloop中去，第二个需要我们手动添加。如果当前线程是主线程的话，某些UI事件，比如UIScrollView的拖拽操作，会将Runloop切换成UITrackingRunLoopMode,这时候，默认的NSDefaultRunLoopMode模式中注册的事件是不会被执行的。所以为了设置一个不会被UI干扰的Timer，我们需要手动将timer的当前RunloopMode设置为NSRunLoopCommonModes，这个模式等效于NSDefaultRunLoopMode和UITrackingRunLoopMode的结合。</p>
<p>由于NSTimer会强引用Target，RunLoop会强引用NSTimer，若ViewController再强引用NSTimer，NSTimer找不到合适的时机释放的时候，很容易造成内存泄漏，这个问题如何解决？</p>
<h2 id="如何解决NSTimer找不到释放时机的问题？"><a href="#如何解决NSTimer找不到释放时机的问题？" class="headerlink" title="如何解决NSTimer找不到释放时机的问题？"></a>如何解决NSTimer找不到释放时机的问题？</h2><h2 id="方案1，使用官方API带Block的方式来创建NSTimer"><a href="#方案1，使用官方API带Block的方式来创建NSTimer" class="headerlink" title="方案1，使用官方API带Block的方式来创建NSTimer"></a>方案1，使用官方API带Block的方式来创建NSTimer</h2><p>具体的创建方法如下，但是仅支持iOS 10以上的系统。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="built_in">BOOL</span>)repeats block:(<span class="keyword">void</span> (^)(<span class="built_in">NSTimer</span> *timer))block API_AVAILABLE(macosx(<span class="number">10.12</span>), ios(<span class="number">10.0</span>), watchos(<span class="number">3.0</span>), tvos(<span class="number">10.0</span>));</span><br></pre></td></tr></table></figure>

<p>在ViewController中的使用方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;第%ld次执行&quot;</span>, (<span class="keyword">long</span>)weakSelf.count);</span><br><span class="line">    weakSelf.count ++;</span><br><span class="line">&#125;];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:<span class="keyword">self</span>.timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>

<h2 id="方案2，使用Block的方式来创建NSTimer"><a href="#方案2，使用Block的方式来创建NSTimer" class="headerlink" title="方案2，使用Block的方式来创建NSTimer"></a>方案2，使用Block的方式来创建NSTimer</h2><p>具体实现方式是，需要创建一个NSTimer的分类，让外部传入一个Block，NSTimer每次到时间就执行传入进来的Block。新建一个分类：<br>NSTimer+BlockSupport.h </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSTimer</span> (<span class="title">BlockSupport</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)cd_timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval</span><br><span class="line">                                       repeats:(<span class="built_in">BOOL</span>)repeats</span><br><span class="line">                                         block:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>

<p>NSTimer+BlockSupport.m</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;NSTimer+BlockSupport.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSTimer</span> (<span class="title">BlockSupport</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)cd_timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval</span><br><span class="line">                              repeats:(<span class="built_in">BOOL</span>)repeats</span><br><span class="line">                                block:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> scheduledTimerWithTimeInterval:interval</span><br><span class="line">                                         target:<span class="keyword">self</span></span><br><span class="line">                                       selector:<span class="keyword">@selector</span>(cd_blockInvoke:)</span><br><span class="line">                                       userInfo:[block <span class="keyword">copy</span>]</span><br><span class="line">                                        repeats:repeats];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)cd_blockInvoke:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = timer.userInfo;</span><br><span class="line">    <span class="keyword">if</span>(block) &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在ViewController中使用方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> cd_timerWithTimeInterval:<span class="number">1.0</span> repeats:<span class="literal">YES</span> block:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;第%ld次执行&quot;</span>, (<span class="keyword">long</span>)weakSelf.count);</span><br><span class="line">    weakSelf.count ++;</span><br><span class="line">&#125;];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:<span class="keyword">self</span>.timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>

<h2 id="方案3，自定义NSTimer的Target"><a href="#方案3，自定义NSTimer的Target" class="headerlink" title="方案3，自定义NSTimer的Target"></a>方案3，自定义NSTimer的Target</h2><p>封装自定义NSTimer的Target和NSTimer的工具类，让NSTimer在合适的时机释放。<br>CDTimerTarget.h</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CDTimerTarget</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>) <span class="keyword">id</span> target;</span><br><span class="line"><span class="comment">// 目标方法</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) SEL selector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>

<p>CDTimerTarget.m</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;CDTimerTarget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CDTimerTarget</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fire:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="comment">// target为弱引用,所以当target对象销毁时,target 为nil</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.target) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Warc-performSelector-leaks&quot;</span></span></span><br><span class="line">        [<span class="keyword">self</span>.target performSelector:<span class="keyword">self</span>.selector withObject:timer.userInfo];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        [timer invalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>CDTimer.h</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CDTimer</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)scheduleTimerWithTimerInterval:(<span class="built_in">NSTimeInterval</span>)interval</span><br><span class="line">                                     target:(<span class="keyword">id</span>)aTarget</span><br><span class="line">                                   selector:(SEL)aSelector</span><br><span class="line">                                   userInfo:(<span class="keyword">id</span>)userInfo</span><br><span class="line">                                    repeats:(<span class="built_in">BOOL</span>)repeats;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>

<p>CDTimer.m</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;CDTimer.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;CDTimerTarget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CDTimer</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)scheduleTimerWithTimerInterval:(<span class="built_in">NSTimeInterval</span>)interval</span><br><span class="line">                                     target:(<span class="keyword">id</span>)aTarget</span><br><span class="line">                                   selector:(SEL)aSelector</span><br><span class="line">                                   userInfo:(<span class="keyword">id</span>)userInfo</span><br><span class="line">                                    repeats:(<span class="built_in">BOOL</span>)repeats &#123;</span><br><span class="line">    </span><br><span class="line">    CDTimerTarget *timerTarget = [[CDTimerTarget alloc]init];</span><br><span class="line">    timerTarget.target = aTarget;</span><br><span class="line">    timerTarget.selector = aSelector;</span><br><span class="line">    <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:interval</span><br><span class="line">                                                      target:timerTarget</span><br><span class="line">                                                    selector:<span class="keyword">@selector</span>(fire:)</span><br><span class="line">                                                    userInfo:userInfo</span><br><span class="line">                                                     repeats:repeats];</span><br><span class="line">    <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在ViewController中的用法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.timer = [CDTimer scheduleTimerWithTimerInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(repeatAction) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>

<h2 id="方案4，自定义NSProxy子类，作为NSTimer的Target"><a href="#方案4，自定义NSProxy子类，作为NSTimer的Target" class="headerlink" title="方案4，自定义NSProxy子类，作为NSTimer的Target"></a>方案4，自定义NSProxy子类，作为NSTimer的Target</h2><img src="/Blog/2020/09/23/iOS%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3/1.png" class="" title="NSProxy原理图">

<p>TargetProxy.h</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TargetProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>

<p>TargetProxy.m</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;TargetProxy.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TargetProxy</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//target, 这里必须要用weak, 因为某个对象会强引TimeProxy对象, TimeProxy对象不能再强引target, 否则会形成循环引用</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>)<span class="keyword">id</span> target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TargetProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target &#123;</span><br><span class="line">    TargetProxy *proxy = [[<span class="keyword">self</span> <span class="keyword">class</span>] alloc];</span><br><span class="line">    proxy.target = target;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取target类中的sel方法的方法签名</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    <span class="comment">//判断target是否实现了该方法</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.target respondsToSelector:invocation.selector]) &#123;</span><br><span class="line">        <span class="comment">//让target调用该方法</span></span><br><span class="line">        [invocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//找不到该方法</span></span><br><span class="line">        [invocation doesNotRecognizeSelector:invocation.selector];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在ViewController中的使用方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:[TargetProxy proxyWithTarget:<span class="keyword">self</span>] selector:<span class="keyword">@selector</span>(repeatAction) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>


<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.apple.com/documentation/foundation/nstimer">NSTimer</a></p>
<p><a href="https://www.jianshu.com/p/73cd476ec3f0">NSProxy解决NSTimer和CADisplayLink的循环引用</a></p>
<p>《Effective Objective-C 2.0 编写高质量iOS与OS X代码的52个有效方法》</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>npm install报错node-pre-gyp install --fallback-to-build</title>
    <url>/Blog/2020/03/22/npm-install%E6%8A%A5%E9%94%99node-pre-gyp-install-fallback-to-build/</url>
    <content><![CDATA[<p><code>npm install</code>安装报错，报错信息如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hu-YupingdeMacBook-Pro:server kris$ npm install</span><br><span class="line">npm WARN deprecated mkdirp@0.5.1: Legacy versions of mkdirp are no longer supported. Please update to mkdirp 1.x. (Note that the API surface has changed to use Promises <span class="keyword">in</span> 1.x.)</span><br><span class="line">npm WARN deprecated bcrypt@1.0.3: bcrypt &lt; v2.0.0 is susceptible to bcrypt wrap-around bug. Upgrade to bcrypt &gt;= v2.0.0 <span class="keyword">for</span> improved support <span class="keyword">for</span> newer bcrypt hashes</span><br><span class="line">npm WARN deprecated request@2.88.2: request has been deprecated, see https://github.com/request/request/issues/3142</span><br><span class="line"></span><br><span class="line">&gt; bcrypt@1.0.3 install /Users/kris/Documents/VueDemo/chapter5/server/node_modules/bcrypt</span><br><span class="line">&gt; node-pre-gyp install --fallback-to-build</span><br><span class="line"></span><br><span class="line">node-pre-gyp ERR! Tried to download(404): https://github.com/kelektiv/node.bcrypt.js/releases/download/v1.0.3/bcrypt_lib-v1.0.3-node-v64-darwin-x64.tar.gz </span><br><span class="line">node-pre-gyp ERR! Pre-built binaries not found <span class="keyword">for</span> bcrypt@1.0.3 and node@10.15.3 (node-v64 ABI) (falling back to <span class="built_in">source</span> compile with node-gyp) </span><br><span class="line">node-pre-gyp ERR! Tried to download(undefined): https://github.com/kelektiv/node.bcrypt.js/releases/download/v1.0.3/bcrypt_lib-v1.0.3-node-v64-darwin-x64.tar.gz </span><br><span class="line">node-pre-gyp ERR! Pre-built binaries not found <span class="keyword">for</span> bcrypt@1.0.3 and node@10.15.3 (node-v64 ABI) (falling back to <span class="built_in">source</span> compile with node-gyp) </span><br><span class="line">  CXX(target) Release/obj.target/bcrypt_lib/src/blowfish.o</span><br><span class="line">  CXX(target) Release/obj.target/bcrypt_lib/src/blowfish.o</span><br><span class="line">sed: ./Release/.deps/Release/obj.target/bcrypt_lib/src/blowfish.o.d.raw: No such file or directory</span><br><span class="line">  CXX(target) Release/obj.target/bcrypt_lib/src/bcrypt.o</span><br><span class="line">rm: ./Release/.deps/Release/obj.target/bcrypt_lib/src/blowfish.o.d.raw: No such file or directory</span><br><span class="line">make: *** [Release/obj.target/bcrypt_lib/src/blowfish.o] Error 1</span><br><span class="line">gyp ERR! build error </span><br><span class="line">gyp ERR! stack Error: `make` failed with <span class="built_in">exit</span> code: 2</span><br><span class="line">gyp ERR! stack     at ChildProcess.onExit (/usr/<span class="built_in">local</span>/lib/node_modules/npm/node_modules/node-gyp/lib/build.js:262:23)</span><br><span class="line">gyp ERR! stack     at ChildProcess.emit (events.js:189:13)</span><br><span class="line">gyp ERR! stack     at Process.ChildProcess._handle.onexit (internal/child_process.js:248:12)</span><br><span class="line">gyp ERR! System Darwin 18.6.0</span><br><span class="line">gyp ERR! <span class="built_in">command</span> <span class="string">&quot;/usr/local/bin/node&quot;</span> <span class="string">&quot;/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js&quot;</span> <span class="string">&quot;build&quot;</span> <span class="string">&quot;--fallback-to-build&quot;</span> <span class="string">&quot;--module=/Users/kris/Documents/VueDemo/chapter5/server/node_modules/bcrypt/lib/binding/bcrypt_lib.node&quot;</span> <span class="string">&quot;--module_name=bcrypt_lib&quot;</span> <span class="string">&quot;--module_path=/Users/kris/Documents/VueDemo/chapter5/server/node_modules/bcrypt/lib/binding&quot;</span></span><br><span class="line">gyp ERR! cwd /Users/kris/Documents/VueDemo/chapter5/server/node_modules/bcrypt</span><br><span class="line">gyp ERR! node -v v10.15.3</span><br><span class="line">gyp ERR! node-gyp -v v3.8.0</span><br><span class="line">gyp ERR! not ok </span><br><span class="line">node-pre-gyp ERR! build error </span><br><span class="line">node-pre-gyp ERR! stack Error: Failed to execute <span class="string">&#x27;/usr/local/bin/node /usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js build --fallback-to-build --module=/Users/kris/Documents/VueDemo/chapter5/server/node_modules/bcrypt/lib/binding/bcrypt_lib.node --module_name=bcrypt_lib --module_path=/Users/kris/Documents/VueDemo/chapter5/server/node_modules/bcrypt/lib/binding&#x27;</span> (1)</span><br><span class="line">node-pre-gyp ERR! stack     at ChildProcess.&lt;anonymous&gt; (/Users/kris/Documents/VueDemo/chapter5/server/node_modules/node-pre-gyp/lib/util/compile.js:83:29)</span><br><span class="line">node-pre-gyp ERR! stack     at ChildProcess.emit (events.js:189:13)</span><br><span class="line">node-pre-gyp ERR! stack     at maybeClose (internal/child_process.js:970:16)</span><br><span class="line">node-pre-gyp ERR! stack     at Process.ChildProcess._handle.onexit (internal/child_process.js:259:5)</span><br><span class="line">node-pre-gyp ERR! System Darwin 18.6.0</span><br><span class="line">node-pre-gyp ERR! <span class="built_in">command</span> <span class="string">&quot;/usr/local/bin/node&quot;</span> <span class="string">&quot;/Users/kris/Documents/VueDemo/chapter5/server/node_modules/.bin/node-pre-gyp&quot;</span> <span class="string">&quot;install&quot;</span> <span class="string">&quot;--fallback-to-build&quot;</span></span><br><span class="line">node-pre-gyp ERR! cwd /Users/kris/Documents/VueDemo/chapter5/server/node_modules/bcrypt</span><br><span class="line">node-pre-gyp ERR! node -v v10.15.3</span><br><span class="line">node-pre-gyp ERR! node-pre-gyp -v v0.6.36</span><br><span class="line">node-pre-gyp ERR! not ok </span><br><span class="line">Failed to execute <span class="string">&#x27;/usr/local/bin/node /usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js build --fallback-to-build --module=/Users/kris/Documents/VueDemo/chapter5/server/node_modules/bcrypt/lib/binding/bcrypt_lib.node --module_name=bcrypt_lib --module_path=/Users/kris/Documents/VueDemo/chapter5/server/node_modules/bcrypt/lib/binding&#x27;</span> (1)</span><br><span class="line">shell-init: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory</span><br><span class="line">/bin/sh: ./Release/.deps/Release/obj.target/bcrypt_lib/src/bcrypt.o.d: No such file or directory</span><br><span class="line">make: *** [Release/obj.target/bcrypt_lib/src/bcrypt.o] Error 1</span><br><span class="line">gyp ERR! build error </span><br><span class="line">gyp ERR! stack Error: `make` failed with <span class="built_in">exit</span> code: 2</span><br><span class="line">gyp ERR! stack     at ChildProcess.onExit (/usr/<span class="built_in">local</span>/lib/node_modules/npm/node_modules/node-gyp/lib/build.js:262:23)</span><br><span class="line">gyp ERR! stack     at ChildProcess.emit (events.js:189:13)</span><br><span class="line">gyp ERR! stack     at Process.ChildProcess._handle.onexit (internal/child_process.js:248:12)</span><br><span class="line">gyp ERR! System Darwin 18.6.0</span><br><span class="line">gyp ERR! <span class="built_in">command</span> <span class="string">&quot;/usr/local/bin/node&quot;</span> <span class="string">&quot;/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js&quot;</span> <span class="string">&quot;build&quot;</span> <span class="string">&quot;--fallback-to-build&quot;</span> <span class="string">&quot;--module=/Users/kris/Documents/VueDemo/chapter5/server/node_modules/bcrypt/lib/binding/bcrypt_lib.node&quot;</span> <span class="string">&quot;--module_name=bcrypt_lib&quot;</span> <span class="string">&quot;--module_path=/Users/kris/Documents/VueDemo/chapter5/server/node_modules/bcrypt/lib/binding&quot;</span></span><br><span class="line">gyp ERR! cwd /Users/kris/Documents/VueDemo/chapter5/server/node_modules/bcrypt</span><br><span class="line">gyp ERR! node -v v10.15.3</span><br><span class="line">gyp ERR! node-gyp -v v3.8.0</span><br><span class="line">gyp ERR! not ok </span><br><span class="line">npm WARN support-center-server@1.0.0 No repository field.</span><br><span class="line"></span><br><span class="line">npm ERR! code ELIFECYCLE</span><br><span class="line">npm ERR! errno 1</span><br><span class="line">npm ERR! bcrypt@1.0.3 install: `node-pre-gyp install --fallback-to-build`</span><br><span class="line">npm ERR! Exit status 1</span><br><span class="line">npm ERR! </span><br><span class="line">npm ERR! Failed at the bcrypt@1.0.3 install script.</span><br><span class="line">npm ERR! This is probably not a problem with npm. There is likely additional logging output above.</span><br><span class="line"></span><br><span class="line">npm ERR! A complete <span class="built_in">log</span> of this run can be found <span class="keyword">in</span>:</span><br><span class="line">npm ERR!     /Users/kris/.npm/_logs/2020-03-22T09_25_45_510Z-debug.log</span><br></pre></td></tr></table></figure>

<p>打开项目的<code>package.json</code>，删除<code>bcrypt</code>的依赖项。</p>
<p>删除前的<code>package.json</code>的依赖项如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;babel-cli&quot;</span>: <span class="string">&quot;^6.24.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-preset-es2015&quot;</span>: <span class="string">&quot;^6.24.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-preset-stage-0&quot;</span>: <span class="string">&quot;^6.24.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;bcrypt&quot;</span>: <span class="string">&quot;^1.0.2&quot;</span>,  &lt;-----------------------删除这行</span><br><span class="line">    <span class="string">&quot;body-parser&quot;</span>: <span class="string">&quot;^1.17.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cookie-parser&quot;</span>: <span class="string">&quot;^1.4.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cors&quot;</span>: <span class="string">&quot;^2.8.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;express&quot;</span>: <span class="string">&quot;^4.15.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;express-session&quot;</span>: <span class="string">&quot;^1.15.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;nedb&quot;</span>: <span class="string">&quot;^1.8.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;nodemon&quot;</span>: <span class="string">&quot;^1.11.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;passport&quot;</span>: <span class="string">&quot;^0.3.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;passport-local&quot;</span>: <span class="string">&quot;^1.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;uuid&quot;</span>: <span class="string">&quot;^3.0.1&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>删除后的<code>package.json</code>的依赖项如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;babel-cli&quot;</span>: <span class="string">&quot;^6.24.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-preset-es2015&quot;</span>: <span class="string">&quot;^6.24.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-preset-stage-0&quot;</span>: <span class="string">&quot;^6.24.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;body-parser&quot;</span>: <span class="string">&quot;^1.17.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cookie-parser&quot;</span>: <span class="string">&quot;^1.4.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cors&quot;</span>: <span class="string">&quot;^2.8.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;express&quot;</span>: <span class="string">&quot;^4.15.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;express-session&quot;</span>: <span class="string">&quot;^1.15.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;nedb&quot;</span>: <span class="string">&quot;^1.8.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;nodemon&quot;</span>: <span class="string">&quot;^1.11.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;passport&quot;</span>: <span class="string">&quot;^0.3.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;passport-local&quot;</span>: <span class="string">&quot;^1.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;uuid&quot;</span>: <span class="string">&quot;^3.0.1&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后执行命令<code>npm i bcrypt </code>，执行完命令，<code>package.json</code>的依赖项如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;babel-cli&quot;</span>: <span class="string">&quot;^6.24.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-preset-es2015&quot;</span>: <span class="string">&quot;^6.24.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-preset-stage-0&quot;</span>: <span class="string">&quot;^6.24.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;bcrypt&quot;</span>: <span class="string">&quot;^4.0.1&quot;</span>, &lt;--------------------- 执行命令后，新增了一行</span><br><span class="line">    <span class="string">&quot;body-parser&quot;</span>: <span class="string">&quot;^1.17.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cookie-parser&quot;</span>: <span class="string">&quot;^1.4.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cors&quot;</span>: <span class="string">&quot;^2.8.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;express&quot;</span>: <span class="string">&quot;^4.15.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;express-session&quot;</span>: <span class="string">&quot;^1.15.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;nedb&quot;</span>: <span class="string">&quot;^1.8.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;nodemon&quot;</span>: <span class="string">&quot;^1.11.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;passport&quot;</span>: <span class="string">&quot;^0.3.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;passport-local&quot;</span>: <span class="string">&quot;^1.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;uuid&quot;</span>: <span class="string">&quot;^3.0.1&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://github.com/kelektiv/node.bcrypt.js/issues/572">node-pre-gyp ERR! Tried to download(404): https://github.com/kelektiv/node.bcrypt.js/releases/download/v1.0.3/bcrypt_lib-v1.0.3-node-v59-linux-x64.tar.gz</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>security相关命令</title>
    <url>/Blog/2021/03/30/security%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="security相关命令"><a href="#security相关命令" class="headerlink" title="security相关命令"></a>security相关命令</h1><h2 id="证书导入命令"><a href="#证书导入命令" class="headerlink" title="证书导入命令"></a>证书导入命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ security import /Users/kris/Desktop/<span class="built_in">test</span>/distribution.p12 -k ~/Library/Keychains/login.keychain -P 证书安装密码 -T /usr/bin/codesign -T /usr/bin/security</span><br><span class="line"></span><br><span class="line">$ security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k 电脑密码 ~/Library/Keychains/login.keychain</span><br></pre></td></tr></table></figure>
<p>使用上述两条命令导入证书后，可以避免打包的时候弹出系统的鉴权弹框，在一些完全命令行自动化的场景下，这些鉴权的输入框无法展示，所以建议使用以上两条命令来导入证书。</p>
<h2 id="删除证书命令"><a href="#删除证书命令" class="headerlink" title="删除证书命令"></a>删除证书命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ security delete-identity -c <span class="string">&quot;iPhone Distribution: XXXXX Management Co., Ltd.&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="解锁钥匙串"><a href="#解锁钥匙串" class="headerlink" title="解锁钥匙串"></a>解锁钥匙串</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ security unlock-keychain -p 电脑密码 ~/Library/Keychains/login.keychain</span><br></pre></td></tr></table></figure>

<h2 id="查看默认钥匙串"><a href="#查看默认钥匙串" class="headerlink" title="查看默认钥匙串"></a>查看默认钥匙串</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ security default-keychain</span><br></pre></td></tr></table></figure>

<h2 id="列出机器上所有的钥匙串"><a href="#列出机器上所有的钥匙串" class="headerlink" title="列出机器上所有的钥匙串"></a>列出机器上所有的钥匙串</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ security list-keychains</span><br></pre></td></tr></table></figure>

<h2 id="查看security命令手册"><a href="#查看security命令手册" class="headerlink" title="查看security命令手册"></a>查看security命令手册</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ man security</span><br></pre></td></tr></table></figure>
<h2 id="查看security-delete-identity命令用法"><a href="#查看security-delete-identity命令用法" class="headerlink" title="查看security delete-identity命令用法"></a>查看security delete-identity命令用法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ security delete-identity <span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h2 id="附上man命令的快捷操作"><a href="#附上man命令的快捷操作" class="headerlink" title="附上man命令的快捷操作"></a>附上man命令的快捷操作</h2><table>
<thead>
<tr>
<th align="center">按键</th>
<th align="center">实现功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">空格键</td>
<td align="center">向下翻一页</td>
</tr>
<tr>
<td align="center">Pg Dn</td>
<td align="center">向下翻一页</td>
</tr>
<tr>
<td align="center">Pg Up</td>
<td align="center">向上翻一页</td>
</tr>
<tr>
<td align="center">Home</td>
<td align="center">去到第一页</td>
</tr>
<tr>
<td align="center">End</td>
<td align="center">去到最后一页</td>
</tr>
<tr>
<td align="center">/string</td>
<td align="center">向下搜索string这个字符串</td>
</tr>
<tr>
<td align="center">?string</td>
<td align="center">向上搜索string这个字符串</td>
</tr>
<tr>
<td align="center">q</td>
<td align="center">结束这次的手册页</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>自动化</category>
      </categories>
      <tags>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh命令无法连接主机</title>
    <url>/Blog/2020/03/20/ssh%E5%91%BD%E4%BB%A4%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E4%B8%BB%E6%9C%BA/</url>
    <content><![CDATA[<p>使用ssh命令远程连接主机出现问题，问题描述如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hu-YupingdeMacBook-Pro:~ kris$ ssh root@192.3.249.179</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that a host key has just been changed.</span><br><span class="line">The fingerprint <span class="keyword">for</span> the ECDSA key sent by the remote host is</span><br><span class="line">SHA256:dVUw64aj0m2JBl62oUMeoJzpZMjCqtL24CQMjTDVvsc.</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key <span class="keyword">in</span> /Users/kris/.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending ECDSA key <span class="keyword">in</span> /Users/kris/.ssh/known_hosts:13</span><br><span class="line">ECDSA host key <span class="keyword">for</span> 192.3.249.179 has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br></pre></td></tr></table></figure>

<p>解决办法:</p>
<p>1.编辑配置文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim ~/.ssh/known_hosts</span><br></pre></td></tr></table></figure>

<p>2.删除对应的host key。</p>
<img src="/Blog/2020/03/20/ssh%E5%91%BD%E4%BB%A4%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E4%B8%BB%E6%9C%BA/1.png" class="" title="删除sshKey截图">

<p>3.再次使用ssh命令连接远程主机，发现可以正常连接。</p>
<img src="/Blog/2020/03/20/ssh%E5%91%BD%E4%BB%A4%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E4%B8%BB%E6%9C%BA/2.png" class="" title="远程连接主机命令截图">



<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://blog.csdn.net/wd2014610/article/details/79945424">Mac和Linux远程连接服务器异常修复（WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!）</a></p>
]]></content>
      <categories>
        <category>VPS</category>
      </categories>
      <tags>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title>一个NSObject对象占用多少内存</title>
    <url>/Blog/2019/06/19/%E4%B8%80%E4%B8%AANSObject%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h2 id="一个NSObject对象占用多少内存"><a href="#一个NSObject对象占用多少内存" class="headerlink" title="一个NSObject对象占用多少内存"></a>一个NSObject对象占用多少内存</h2><p>我们平时所编写的Objective-C代码，底层实现都是C/C++代码，</p>
<img src="/Blog/2019/06/19/%E4%B8%80%E4%B8%AANSObject%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98/Object-C%E4%BB%A3%E7%A0%81%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.png" class="" title="Objective-C代码底层实现">

<p>所以OC的面向对象都是基于C/C++的数据结构实现的</p>
<p><code>思考:OC对象主要是基于C/C++的什么数据结构实现的呢？？？</code></p>
<p>想要了解OC对象主要是基于C/C++的什么数据结构实现的，我们首先要做的就是将Objective-C代码转化为C/C++代码，这样我们才能清楚的看清是怎么实现的</p>
<p>然后我们打开终端，在命令行找到cd到文件目录，然后中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -rewrite-objc main.m </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>命令可以将main.m编译成C++的代码，改成不同的文件名，就会生成不同的c++代码<br>这是就生成了main.cpp这个c++文件，打开文件代码<br>查看该main.cpp最底下的main函数， </p>
<p>但是不同平台支持的代码肯定是不一样的，像平台有<code>Windows</code>、<code>mac</code>、<code>iOS</code>，架构有<code>模拟器(i386)、32bit(armv7)、64bit（arm64）</code>，我们使用<code>iOS</code>，他的架构现在基本上都是<code>64bit（arm64）</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc OC源文件  -o  输出的CPP文件</span><br><span class="line">如果需要链接其他框架，使用-framework参数。比如-framework UIKit</span><br></pre></td></tr></table></figure>
<p>在终端输入命令以后，我们会生成一个<code>main.cpp</code>文件，打开<code>main.cpp</code>文件文件，我们把<code>main.cpp</code>文件拉到最下面，我们会看到这样一段代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">&#x2F;* @autoreleasepool *&#x2F; &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码就是我们OC代码中的<code>main</code>函数的实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">	@autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时我们在<code>main</code>函数写入这一段代码，然后我们点击进入，查看代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSObject *obj &#x3D; [[NSObject alloc] init];</span><br></pre></td></tr></table></figure>
<p>点击<code>NSObject</code>进入内部，可以看到NSObject底层实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct NSObject &#123;</span><br><span class="line">	Class isa;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们用<code>NSObject_IMPL</code>查找在c++文件中具体的实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>我们再一次执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc main.m</span><br></pre></td></tr></table></figure>
<p>生成的C++代码为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">	&#x2F;* @autoreleasepool *&#x2F; &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">	NSObject *obj &#x3D; ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两个方法可以打印内存大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获得NSObject实例对象的成员变量所占用的大小  </span><br><span class="line">NSLog(@&quot;%zd&quot;, class_getInstanceSize([NSObject class]));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获得obj指针所指向内存的大小  </span><br><span class="line">NSLog(@&quot;%zd&quot;, malloc_size((__bridge const void *)obj));</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<img src="/Blog/2019/06/19/%E4%B8%80%E4%B8%AANSObject%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98/NSObject%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98.png" class="" title="NSObject对象内存">

<h2 id="一个OC对象在内存中是怎么样布局的呢"><a href="#一个OC对象在内存中是怎么样布局的呢" class="headerlink" title="一个OC对象在内存中是怎么样布局的呢"></a>一个OC对象在内存中是怎么样布局的呢</h2><p>我们在C++文件中找到NSObject的实现<br>OC代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct NSObject &#123;</span><br><span class="line">	Class isa;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>c++代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们知道一个指针是<code>8个字节</code>，但是NSObject对象打印<code>16个字节</code>,他们是怎么样布局的呢</p>
<img src="/Blog/2019/06/19/%E4%B8%80%E4%B8%AANSObject%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98/NSObject%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80.png" class="" title="NSObject对象内存地址">

<p>我们可以根据内存地址实时查看内存分配情况<code>Debug -&gt; Debug Workfllow -&gt; View Memory （Shift + Command + M）</code></p>
<p>菜单选项如何查看内存：</p>
<img src="/Blog/2019/06/19/%E4%B8%80%E4%B8%AANSObject%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98/%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE.png" class="" title="查看内存数据">

<p>输入内存地址：</p>
<img src="/Blog/2019/06/19/%E4%B8%80%E4%B8%AANSObject%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98/%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE1.png" class="" title="查看内存数据1">

<p>通过Xcode查看内存数据:</p>
<img src="/Blog/2019/06/19/%E4%B8%80%E4%B8%AANSObject%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98/%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE2.png" class="" title="查看内存数据2">

<p>通过LLDB命令查看内存数据:</p>
<img src="/Blog/2019/06/19/%E4%B8%80%E4%B8%AANSObject%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98/%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE3.png" class="" title="查看内存数据3">


<p>我们也可以直接使用 <code>LLDB命令</code>来查看内存地址<br><strong>常用LLDB命令</strong></p>
<ul>
<li><p>print、p：打印</p>
</li>
<li><p>po：打印对象</p>
</li>
<li><p>读取内存</p>
<ul>
<li>memory read/数量格式字节数  内存地址</li>
<li>x/数量格式字节数  内存地址（格式：x是16进制，f是浮点，d是10进制；字节大小<br>：b：byte 1字节，h：half word 2字节，w：word 4字节，g：giant word 8字节）</li>
</ul>
</li>
<li><p>修改内存中的值（memory  write  内存地址  数值   memory  write  0x0000010  10）</p>
</li>
</ul>
<p><strong>问题1</strong>：假设我创建一个<code>Animal</code>类，里面有<code>age</code>,<code>weight</code>两个属性，那么他的内存是多大呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Animal *animal &#x3D; [[Animal alloc] init];</span><br><span class="line">animal.age &#x3D; 10;</span><br><span class="line">animal.weight &#x3D; 20;</span><br></pre></td></tr></table></figure>

<p>我们先执行命令，查看一下c++源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Animal_IMPL &#123;</span><br><span class="line">	struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">	int _age;</span><br><span class="line">	int _weight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们在知道结果之前大概猜猜内存是多大呢？16，24，32…</p>
<p>猜16字节的猜对了，我们先看看结果</p>
<img src="/Blog/2019/06/19/%E4%B8%80%E4%B8%AANSObject%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98/Animal%E5%86%85%E5%AD%98%E6%89%93%E5%8D%B0.png" class="" title="Animal内存打印">

<p>我们用<code>LLDB命令</code>打印一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) po animal</span><br><span class="line">&lt;Animal: 0x1005c23c0&gt;</span><br><span class="line"></span><br><span class="line">(lldb) memory read 0x1005c23c0</span><br><span class="line">0x1005c23c0: 81 13 00 00 01 80 1d 00 0a 00 00 00 14 00 00 00  ................</span><br><span class="line">0x1005c23d0: a0 24 5c 00 01 00 00 00 e0 26 5c 00 01 00 00 00  .$\......&amp;\.....</span><br><span class="line">(lldb) </span><br></pre></td></tr></table></figure>

<p> 为什么会是<code>0a 00 00 00</code>和<code>14 00 00 00</code>呢，而不是<code>00 00 00 0a</code>和<code>00 00 00 14</code>,这个就要考虑<a href="https://baike.baidu.com/item/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F/6750542?fromtitle=%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF&fromid=15925891&fr=aladdin">大端小端</a>，具体概念自己可以去查。</p>
<p>但是为什么会是16个字节呢，因为int类型占用4个字节，两个int类型8个字节，一个<code>isa</code>8个字节，因为刚刚占满16个字节，对象就没有在开辟新的空间了</p>
<p>如果在多一个<code>feetCount</code>会占用几个字节呢</p>
<img src="/Blog/2019/06/19/%E4%B8%80%E4%B8%AANSObject%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98/Cat%E5%86%85%E5%AD%98%E6%89%93%E5%8D%B0.png" class="" title="Cat内存打印">

<p><code>占用32个字节，大家是不是很惊讶，没有猜到</code></p>
<p>其实这又要提到一个新的知识点了<code>内存对齐</code>,我们知道OC对象就是C++结构体，<code>而结构体的大小必须是最大成员大小的倍数</code>，当在多了一个<code>feetCount</code>以后，内存不够用了，然后就需要扩展了。</p>
<p><strong>如果是这样呢，占用内存是多少</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) int age;</span><br><span class="line">@property (nonatomic, assign) int weight;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Cat : Animal</span><br><span class="line">@property (nonatomic, assign) int feetCount;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Cat</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>Cat</code>继承自<code>Animal</code></p>
<img src="/Blog/2019/06/19/%E4%B8%80%E4%B8%AANSObject%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98/Cat%E5%86%85%E5%AD%98%E6%89%93%E5%8D%B0.png" class="" title="Cat内存打印">

<p>我们生成C++代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Cat_IMPL &#123;</span><br><span class="line">	struct Animal_IMPL Animal_IVARS;</span><br><span class="line">	int _feetCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Animal_IMPL &#123;</span><br><span class="line">	struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">	int _weight;</span><br><span class="line">	int _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>整理一下就是这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Cat_IMPL &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">	int _weight;</span><br><span class="line">	int _age;</span><br><span class="line">	int _feetCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/DavidWanderer/iOS_Examples">参考demo</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用vue-cli创建项目</title>
    <url>/Blog/2020/03/21/%E4%BD%BF%E7%94%A8vue-cli%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>1.执行命令创建项目。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue init webpack-simple demo4</span><br></pre></td></tr></table></figure>

<p>2.回答vue-cli的问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">? Project name demo4</span><br><span class="line">? Project description A Vue.js project</span><br><span class="line">? Author Hu, Yuping &lt;huyp@yxt.com&gt;</span><br><span class="line">? License MIT</span><br><span class="line">? Use sass? No</span><br></pre></td></tr></table></figure>

<p>3.vue-cli会创建文件夹，并打印提示命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue-cli · Generated <span class="string">&quot;demo4&quot;</span>.</span><br><span class="line"></span><br><span class="line">   To get started:</span><br><span class="line">   </span><br><span class="line">     <span class="built_in">cd</span> demo4</span><br><span class="line">     npm install</span><br><span class="line">     npm run dev</span><br></pre></td></tr></table></figure>

<p>其中第一条命令的可以提供不同的模版。命令全称如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue init &lt;template-name&gt; &lt;project-name&gt;</span><br></pre></td></tr></table></figure>

<p>具体解释如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">init：表示我要用vue-cli来初始化项目</span><br><span class="line"></span><br><span class="line">&lt;template-name&gt;：表示模板名称，vue-cli官方为我们提供了5种模板，</span><br><span class="line"></span><br><span class="line">webpack-一个全面的webpack+vue-loader的模板，功能包括热加载，linting,检测和CSS扩展。</span><br><span class="line"></span><br><span class="line">webpack-simple-一个简单webpack+vue-loader的模板，不包含其他功能，让你快速的搭建vue的开发环境。</span><br><span class="line"></span><br><span class="line">browserify-一个全面的Browserify+vueify 的模板，功能包括热加载，linting,单元检测。</span><br><span class="line"></span><br><span class="line">browserify-simple-一个简单Browserify+vueify的模板，不包含其他功能，让你快速的搭建vue的开发环境。</span><br><span class="line"></span><br><span class="line">simple-一个最简单的单页应用模板。</span><br><span class="line"></span><br><span class="line">&lt;project-name&gt;：标识项目名称，这个你可以根据自己的项目来起名字。</span><br></pre></td></tr></table></figure>

<p>创建完项目，执行<code>npm run dev</code>，控制台会打印消息，可以预览当前的自动生成的页面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hu-YupingdeMacBook-Pro:demo4 kris$ npm run dev</span><br><span class="line"></span><br><span class="line">&gt; demo4@1.0.0 dev /Users/kris/Documents/VueDemo/chapter4/demo4</span><br><span class="line">&gt; cross-env NODE_ENV=development webpack-dev-server --open --hot</span><br><span class="line"></span><br><span class="line">Project is running at http://localhost:8081/</span><br><span class="line">webpack output is served from /dist/</span><br><span class="line">404s will fallback to /index.html</span><br><span class="line">&#123; parser: <span class="string">&quot;babylon&quot;</span> &#125; is deprecated; we now treat it as &#123; parser: <span class="string">&quot;babel&quot;</span> &#125;.</span><br></pre></td></tr></table></figure>

<p>浏览器中的预览页面如下:</p>
<img src="/Blog/2020/03/21/%E4%BD%BF%E7%94%A8vue-cli%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/1.png" class="" title="demo项目运行的截图">]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>分类的原理</title>
    <url>/Blog/2019/06/27/%E5%88%86%E7%B1%BB%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="分类的原理"><a href="#分类的原理" class="headerlink" title="分类的原理"></a>分类的原理</h2><p>对于分类的作用恐怕大家都是知道的吧，今天就让我们一起研究一下分类的实现原理。</p>
<p>首先创建一个<code>person</code>类，然后在创建<code>person</code>类的两个分类<code>Person+eat</code>&amp;<code>Person+Run</code>。<br>研究原理我们的思路就是:</p>
<ul>
<li>1、生成c++文件，查看c++文件中的实现</li>
<li>2、如果c++文件中实现介绍的不太具体就去查看<a href="https://opensource.apple.com/source/objc4/">源码</a>实现</li>
</ul>
<p>我们使用<code>xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc Person+eat.m</code>来生成c++代码</p>
<p>我们可以找到分类都包含了哪些东西</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> *<span class="title">cls</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">instance_methods</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">class_methods</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">prop_list_t</span> *<span class="title">properties</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们发现里面并没有对方法属性协议等等的具体实现过程，那么我们在去<a href="https://opensource.apple.com/source/objc4/">源码</a>中查看一下相关实现过程。</p>
<p>源码解读顺序</p>
<ul>
<li>1、objc-os.mm（runtime初始化的代码）<ul>
<li>_objc_init</li>
<li>map_images</li>
<li>map_images_nolock</li>
</ul>
</li>
<li>2、objc-runtime-new.mm<ul>
<li>_read_images</li>
<li>remethodizeClass</li>
<li>attachCategories</li>
<li>attachLists</li>
<li>realloc、memmove、 memcpy</li>
</ul>
</li>
</ul>
<p>我们按照源码查找一路找到<code>attachCategories</code>方法，我们发现这个方法就是对分类的实现。里面第一句解释<code>Attach method lists and properties and protocols from categories to a class.</code>将方法列表、属性和协议从类别附加到类中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">attachCategories(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方法数组，这是一个二维数组</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	[</span></span><br><span class="line"><span class="comment">	[method_t,method_t],</span></span><br><span class="line"><span class="comment">	[method_t,method_t]</span></span><br><span class="line"><span class="comment">	]</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">method_list_t</span> **mlists = (<span class="keyword">method_list_t</span> **)</span><br><span class="line">	<span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">	<span class="comment">//属性数组，这是一个二维数组</span></span><br><span class="line">	<span class="keyword">property_list_t</span> **proplists = (<span class="keyword">property_list_t</span> **)</span><br><span class="line">	<span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</span><br><span class="line">	<span class="comment">//协议数组，这是一个二维数组</span></span><br><span class="line">	<span class="keyword">protocol_list_t</span> **protolists = (<span class="keyword">protocol_list_t</span> **)</span><br><span class="line">	<span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> propcount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> protocount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = cats-&gt;count;</span><br><span class="line">	<span class="keyword">bool</span> fromBundle = NO;</span><br><span class="line">	<span class="keyword">while</span> (i--) &#123;</span><br><span class="line">	<span class="comment">//取出某个分类</span></span><br><span class="line">	<span class="keyword">auto</span>&amp; entry = cats-&gt;<span class="built_in">list</span>[i];</span><br><span class="line">	<span class="comment">//取出分类里面的方法列表</span></span><br><span class="line">	<span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">	<span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">		mlists[mcount++] = mlist;</span><br><span class="line">		fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">property_list_t</span> *proplist = </span><br><span class="line">	entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">	<span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">		proplists[propcount++] = proplist;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;protocols;</span><br><span class="line">	<span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">		protolists[protocount++] = protolist;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//得到对象里面的数据</span></span><br><span class="line">	<span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">	prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">	<span class="comment">//将所有分类的对象方法，附加到类对象的方法列表中</span></span><br><span class="line">	rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">	<span class="built_in">free</span>(mlists);</span><br><span class="line">	<span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) flushCaches(cls);</span><br><span class="line">	<span class="comment">//将所有分类的属性，附加到类对象的属性列表中</span></span><br><span class="line">	rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">	<span class="built_in">free</span>(proplists);</span><br><span class="line">	<span class="comment">//将所有分类的协议，附加到类对象的协议列表中</span></span><br><span class="line">	rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">	<span class="built_in">free</span>(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现<code>rw-&gt;methods.attachLists(mlists, mcount);</code>方法是实现将所有分类的对象方法，附加到类对象的方法列表中，其他两个属性和协议都是调用这个方法，我们分析一个就可以了。</p>
<p>点击进入<code>attachLists</code>方法，里面有一段实现代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">	<span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">	<span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">	<span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">	setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">	<span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">	<span class="comment">//array()-&gt;list 原来的方法列表</span></span><br><span class="line">	memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">	<span class="comment">//addedList 所有分类的方法列表</span></span><br><span class="line">	<span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1、扩容，把类中的方法数组和分类中的方法数组计算出来</li>
<li>2、<code>memmove</code>把类中方法放到数组的最后一位</li>
<li>3、<code>memcpy</code>把分类中的方法放到数组的前面。</li>
</ul>
<img src="/Blog/2019/06/27/%E5%88%86%E7%B1%BB%E7%9A%84%E5%8E%9F%E7%90%86/%E5%88%86%E7%B1%BB.png" class="" title="分类">
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>升级Big Sur后，hexo无法使用</title>
    <url>/Blog/2021/01/03/%E5%8D%87%E7%BA%A7Big-Sur%E5%90%8E%EF%BC%8Chexo%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="问题产生"><a href="#问题产生" class="headerlink" title="问题产生"></a>问题产生</h1><p>元旦放假期间升级了一下macOS系统，升级到最新的<code>macOS Big Sur 版本11.1</code>之后发现在终端敲<code>hexo clean</code>报错，具体的错误信息如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">poet@poetdeMacBook-Pro ~ % hexo clean</span><br><span class="line">zsh: <span class="built_in">command</span> not found: hexo</span><br></pre></td></tr></table></figure>
<p>网上搜索一下，发现大家也有类似问题，但是具体的情况和我还不太一样。我的电脑上安装了nvm，升级之后发现我电脑上node默认升级到了<code>v11.15.0</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">poet@poetdeMacBook-Pro ~ % node -v</span><br><span class="line">v11.15.0</span><br></pre></td></tr></table></figure>
<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>而每一个node版本都会维护一套自己的<code>bin</code>目录，我发现我自己的电脑上安装了3个不同的node版本，只有<code>v8.11.1</code>这个版本的<code>bin</code>目录下才有<code>hexo</code>的可执行文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">poet@poetdeMacBook-Pro ~ % <span class="built_in">cd</span> /Users/poet/.nvm/versions/node/</span><br><span class="line">poet@poetdeMacBook-Pro node % ls</span><br><span class="line">v11.15.0	v7.10.0		v8.11.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在v8.11.1目录下面的bin目录查看到 hexo</span></span><br><span class="line">poet@poetdeMacBook-Pro node % <span class="built_in">cd</span> v8.11.1</span><br><span class="line">poet@poetdeMacBook-Pro v8.11.1 % ls</span><br><span class="line">CHANGELOG.md	README.md	etc		lib</span><br><span class="line">LICENSE		bin		include		share</span><br><span class="line">poet@poetdeMacBook-Pro v8.11.1 % <span class="built_in">cd</span> bin</span><br><span class="line">poet@poetdeMacBook-Pro bin % ls</span><br><span class="line">express	hexo	n	node	npm	npx	nrm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在v7.10.0目录下面的bin目录下没有查看到hexo相关的文件</span></span><br><span class="line">poet@poetdeMacBook-Pro node % <span class="built_in">cd</span> v7.10.0</span><br><span class="line">poet@poetdeMacBook-Pro v7.10.0 % ls</span><br><span class="line">CHANGELOG.md	README.md	etc		lib</span><br><span class="line">LICENSE		bin		include		share</span><br><span class="line">poet@poetdeMacBook-Pro v7.10.0 % <span class="built_in">cd</span> bin</span><br><span class="line">poet@poetdeMacBook-Pro bin % ls</span><br><span class="line">node	npm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在v11.15.0目录下面的bin目录下没有查看到hexo相关的文件</span></span><br><span class="line">poet@poetdeMacBook-Pro node % <span class="built_in">cd</span> v11.15.0</span><br><span class="line">poet@poetdeMacBook-Pro v11.15.0 % ls</span><br><span class="line">bin	include	lib	share</span><br><span class="line">poet@poetdeMacBook-Pro v11.15.0 % <span class="built_in">cd</span> bin</span><br><span class="line">poet@poetdeMacBook-Pro bin % ls</span><br><span class="line">node	npm	npx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>最终我的解决办法是，将<code>v8.11.1/bin/hexo</code>文件连接到<code>/usr/local/bin</code>目录下，在终端输入<code>hexo clean</code>命令时，系统会去<code>/usr/local/bin</code>目录中查找对应的可执行文件，找到<code>hexo</code>后，会连接到<code>v8.11.1/bin/hexo</code>目录下调用hexo可执行文件，最终执行命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">poet@poetdeMacBook-Pro % ln -s /Users/poet/.nvm/versions/node/v8.11.1/bin/hexo /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure>

<p>执行完成之后，验证一下最终的命令是否有效果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">poet@poetdeMacBook-Pro ~ % hexo</span><br><span class="line">Usage: hexo &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  <span class="built_in">help</span>     Get <span class="built_in">help</span> on a <span class="built_in">command</span>.</span><br><span class="line">  init     Create a new Hexo folder.</span><br><span class="line">  version  Display version information.</span><br><span class="line"></span><br><span class="line">Global Options:</span><br><span class="line">  --config  Specify config file instead of using _config.yml</span><br><span class="line">  --cwd     Specify the CWD</span><br><span class="line">  --debug   Display all verbose messages <span class="keyword">in</span> the terminal</span><br><span class="line">  --draft   Display draft posts</span><br><span class="line">  --safe    Disable all plugins and scripts</span><br><span class="line">  --silent  Hide output on console</span><br><span class="line"></span><br><span class="line">For more <span class="built_in">help</span>, you can use <span class="string">&#x27;hexo help [command]&#x27;</span> <span class="keyword">for</span> the detailed information</span><br><span class="line">or you can check the docs: http://hexo.io/docs/</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>ln -s 源文件 目标文件</strong> 这个语法是给源文件建立一个软连接，软连接是一个特殊的文件，它包含源文件的具体位置。类似于Windows系统的快捷方式。</p>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://ziyubiti.github.io/2019/07/16/HexoCommandNotFound/">Hexo：command not found的问题解决</a><br><a href="https://www.cnblogs.com/kex1n/p/5193826.html">linux 创建连接命令 ln -s 软链接</a></p>
]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>通用</tag>
      </tags>
  </entry>
  <entry>
    <title>如何制作一个CocoaPods私有库</title>
    <url>/Blog/2020/08/30/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AACocoaPods%E7%A7%81%E6%9C%89%E5%BA%93/</url>
    <content><![CDATA[<h2 id="创建私有库模版"><a href="#创建私有库模版" class="headerlink" title="创建私有库模版"></a>创建私有库模版</h2><p>使用命令进入到要建立私有库工程的目录，执行以下命令，<code>CDUtils</code>是私有库项目名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod lib create CDUtils</span><br></pre></td></tr></table></figure>
<p>接下来终端会询问几个问题，请根据实际情况设置：</p>
<img src="/Blog/2020/08/30/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AACocoaPods%E7%A7%81%E6%9C%89%E5%BA%93/%E5%88%9B%E5%BB%BA%E6%A8%A1%E7%89%88%E9%97%AE%E9%A2%98%E6%88%AA%E5%9B%BE.png" class="" title="创建模版问题截图">
<p>根据提示最终就会创建一个私有工程。</p>
<h2 id="创建私有库Git地址，这里以Github为例"><a href="#创建私有库Git地址，这里以Github为例" class="headerlink" title="创建私有库Git地址，这里以Github为例"></a>创建私有库Git地址，这里以Github为例</h2><img src="/Blog/2020/08/30/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AACocoaPods%E7%A7%81%E6%9C%89%E5%BA%93/%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93Git%E6%88%AA%E5%9B%BE.png" class="" title="创建私有库Git截图">

<h2 id="修改配置文件CDUtils-podspec"><a href="#修改配置文件CDUtils-podspec" class="headerlink" title="修改配置文件CDUtils.podspec"></a>修改配置文件CDUtils.podspec</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to run `pod lib lint CDUtils.podspec&#x27; to ensure this is a</span></span><br><span class="line"><span class="comment"># valid spec before submitting.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Any lines starting with a # are optional, but their use is encouraged</span></span><br><span class="line"><span class="comment"># To learn more about a Podspec see https://guides.cocoapods.org/syntax/podspec.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">Pod::Spec.new <span class="keyword">do</span> |s|</span><br><span class="line">  s.name             = <span class="string">&#x27;CDUtils&#x27;</span></span><br><span class="line">  s.version          = <span class="string">&#x27;0.0.1&#x27;</span></span><br><span class="line">  s.summary          = <span class="string">&#x27;CDUtils 是一个公共方法库。&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This description is used to generate tags and improve search results.</span></span><br><span class="line"><span class="comment">#   * Think: What does it do? Why did you write it? What is the focus?</span></span><br><span class="line"><span class="comment">#   * Try to keep it short, snappy and to the point.</span></span><br><span class="line"><span class="comment">#   * Write the description between the DESC delimiters below.</span></span><br><span class="line"><span class="comment">#   * Finally, don&#x27;t worry about the indent, CocoaPods strips it!</span></span><br><span class="line"></span><br><span class="line">  s.description      = &lt;&lt;-<span class="string">DESC</span></span><br><span class="line"><span class="string">TODO: Add long description of the pod here.</span></span><br><span class="line"><span class="string">                       DESC</span></span><br><span class="line"></span><br><span class="line">  s.homepage         = <span class="string">&#x27;https://github.com/DavidWanderer/CDUtils.git&#x27;</span></span><br><span class="line">  <span class="comment"># s.screenshots     = &#x27;www.example.com/screenshots_1&#x27;, &#x27;www.example.com/screenshots_2&#x27;</span></span><br><span class="line">  s.license          = &#123; :<span class="built_in">type</span> =&gt; <span class="string">&#x27;MIT&#x27;</span>, :file =&gt; <span class="string">&#x27;LICENSE&#x27;</span> &#125;</span><br><span class="line">  s.author           = &#123; <span class="string">&#x27;1516715172@qq.com&#x27;</span> =&gt; <span class="string">&#x27;jsjhyp@gmail.com&#x27;</span> &#125;</span><br><span class="line">  s.source           = &#123; :git =&gt; <span class="string">&#x27;https://github.com/DavidWanderer/CDUtils.git&#x27;</span>, :tag =&gt; s.version.to_s &#125;</span><br><span class="line">  <span class="comment"># s.social_media_url = &#x27;https://twitter.com/&lt;TWITTER_USERNAME&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">  s.ios.deployment_target = <span class="string">&#x27;8.0&#x27;</span></span><br><span class="line"></span><br><span class="line">  s.source_files = <span class="string">&#x27;CDUtils/Classes/**/*&#x27;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># s.resource_bundles = &#123;</span></span><br><span class="line">  <span class="comment">#   &#x27;CDUtils&#x27; =&gt; [&#x27;CDUtils/Assets/*.png&#x27;]</span></span><br><span class="line">  <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.public_header_files = &#x27;Pod/Classes/**/*.h&#x27;</span></span><br><span class="line">  <span class="comment"># s.frameworks = &#x27;UIKit&#x27;, &#x27;MapKit&#x27;</span></span><br><span class="line">  <span class="comment"># s.dependency &#x27;AFNetworking&#x27;, &#x27;~&gt; 2.3&#x27;</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>命令行进入私有库工程所在目录下的Example文件夹，执行<code>pod install</code>，安装依赖项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PoetMacBook-Pro:Example kris$ pod install</span><br><span class="line">Analyzing dependencies</span><br><span class="line">Downloading dependencies</span><br><span class="line">Generating Pods project</span><br><span class="line">Integrating client project</span><br><span class="line">Pod installation complete! There is 1 dependency from the Podfile and 1 total pod installed.</span><br><span class="line">PoetMacBook-Pro:Example kris$ </span><br></pre></td></tr></table></figure>

<h2 id="添加库的源代码文件"><a href="#添加库的源代码文件" class="headerlink" title="添加库的源代码文件"></a>添加库的源代码文件</h2><p>将源码文件放入<code>CDUtils/Classes</code>目录下，与podspec文件保持一致。</p>
<img src="/Blog/2020/08/30/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AACocoaPods%E7%A7%81%E6%9C%89%E5%BA%93/%E6%B7%BB%E5%8A%A0%E5%BA%93%E7%9A%84%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6%E6%88%AA%E5%9B%BE.png" class="" title="添加库的源码文件截图">

<h2 id="验证私有库的正确性"><a href="#验证私有库的正确性" class="headerlink" title="验证私有库的正确性"></a>验证私有库的正确性</h2><p>使用命令验证私有库的正确性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod lib lint CDUtils.podspec</span><br></pre></td></tr></table></figure>

<h2 id="提交源码到github，并打Tag。"><a href="#提交源码到github，并打Tag。" class="headerlink" title="提交源码到github，并打Tag。"></a>提交源码到github，并打Tag。</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add origin https://github.com/DavidWanderer/CDUtils.git</span><br><span class="line"></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;0.0.1&quot;</span></span><br><span class="line"></span><br><span class="line">$ git pull origin master</span><br><span class="line"></span><br><span class="line">$ git push origin master</span><br><span class="line"></span><br><span class="line">$ git tag 0.0.1</span><br><span class="line"> </span><br><span class="line">$ git push origin 0.0.1</span><br></pre></td></tr></table></figure>

<h2 id="创建私有库的索引库"><a href="#创建私有库的索引库" class="headerlink" title="创建私有库的索引库"></a>创建私有库的索引库</h2><p>在Github上创建私有库的索引库，并进行初始化操作。</p>
<img src="/Blog/2020/08/30/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AACocoaPods%E7%A7%81%E6%9C%89%E5%BA%93/%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E7%B4%A2%E5%BC%95%E5%BA%93.png" class="" title="创建私有索引库截图">

<h2 id="将创建的索引库添加到本地cocoapods仓库"><a href="#将创建的索引库添加到本地cocoapods仓库" class="headerlink" title="将创建的索引库添加到本地cocoapods仓库"></a>将创建的索引库添加到本地cocoapods仓库</h2><ul>
<li>在自己的私有库目录下执行命令，将创建的索引库克隆到本地的cocoapods的仓库中。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod repo add CDSpecs https://github.com/DavidWanderer/CDSpecs.git</span><br></pre></td></tr></table></figure></li>
<li>cocoapods本地仓库路径为：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ~/.cocoapods/repos</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="发布私有库"><a href="#发布私有库" class="headerlink" title="发布私有库"></a>发布私有库</h2><p>在自己的私有库目录下执行命令，把当前私有库的索引同步到本地索引库，并同步给远程索引库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod repo push CDUtils CDUtils.podspec</span><br></pre></td></tr></table></figure>
<p>终端截图:</p>
<img src="/Blog/2020/08/30/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AACocoaPods%E7%A7%81%E6%9C%89%E5%BA%93/%E7%A7%81%E6%9C%89%E5%BA%93%E7%B4%A2%E5%BC%95%E5%90%8C%E6%AD%A5%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E7%B4%A2%E5%BC%95%E5%BA%93.png" class="" title="私有库索引同步到本地和远程索引库截图">

<h2 id="在自己的项目中引用私有库"><a href="#在自己的项目中引用私有库" class="headerlink" title="在自己的项目中引用私有库"></a>在自己的项目中引用私有库</h2><p>Podfile如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Uncomment the next line to define a global platform for your project</span></span><br><span class="line"><span class="built_in">source</span> <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br><span class="line"><span class="built_in">source</span> <span class="string">&#x27;https://github.com/DavidWanderer/CDSpecs.git&#x27;</span></span><br><span class="line">platform :ios, <span class="string">&#x27;8.0&#x27;</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;测试&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># Comment the next line if you don&#x27;t want to use dynamic frameworks</span></span><br><span class="line">  <span class="comment">#use_frameworks!</span></span><br><span class="line">  pod <span class="string">&#x27;CDUtils&#x27;</span>, <span class="string">&#x27;~&gt; 0.0.1&#x27;</span></span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在Github上搭建博客</title>
    <url>/Blog/2019/03/16/%E5%A6%82%E4%BD%95%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><ul>
<li>安装Hexo之前，电脑上需要安装Git和Node.js</li>
<li><ol>
<li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000">安装Git</a></li>
</ol>
</li>
<li><ol start="2">
<li><a href="https://nodejs.org/en/">安装Node.js</a></li>
</ol>
</li>
</ul>
<p>安装完Git和Node.js，开始安装Hexo，安装Hexo需要翻墙，打开终端，输入以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>新建目录存放博客的网站文件，例如新建一个空文件夹Blog，然后执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init Blog</span><br><span class="line">$ <span class="built_in">cd</span> Blog</span><br><span class="line">$ npm Blog </span><br></pre></td></tr></table></figure>

<h2 id="发布新的文章"><a href="#发布新的文章" class="headerlink" title="发布新的文章"></a>发布新的文章</h2><p>创建完网站目录后，开始写作，创建一篇新的文章，执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;HelloWord&quot;</span></span><br></pre></td></tr></table></figure>
<div style="width:400px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2019/03/16/%E5%A6%82%E4%BD%95%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/Snip20190316_1.png" class="" title="创建文章的截图"> </div>

<p>执行完上述命令，会在网站的～/Blog/source/_posts目录下出现HelloWord.md文件，这个文件就是我们新建的文章，使用Markdown语法编写我们的文章。</p>
<h2 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h2><p>文章写好之后，执行以下命令，开始生成静态文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<h2 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h2><p>静态文件生成之后，启动本地服务器，预览文章的总体页面，需要执行以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
<div style="width:400px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2019/03/16/%E5%A6%82%E4%BD%95%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/Snip20190316_2.png" class="" title="启动服务器的命令截图"> </div>

<p>本地浏览器预览效果：</p>
<img src="/Blog/2019/03/16/%E5%A6%82%E4%BD%95%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/Snip20190316_4.png" class="" title="本地浏览器预览文章的截图">


<h2 id="发布到Github"><a href="#发布到Github" class="headerlink" title="发布到Github"></a>发布到Github</h2><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>在配置文件中配置发布到git，然后填写具体的仓库地址:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/DavidWanderer/Blog.git</span><br></pre></td></tr></table></figure>

<h3 id="安装Hexo发布到git的插件"><a href="#安装Hexo发布到git的插件" class="headerlink" title="安装Hexo发布到git的插件:"></a>安装Hexo发布到git的插件:</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>检查插件是否安装完成:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm list hexo-deployer-git</span><br></pre></td></tr></table></figure>

<h3 id="将本地的静态文件部署到github的仓库"><a href="#将本地的静态文件部署到github的仓库" class="headerlink" title="将本地的静态文件部署到github的仓库"></a>将本地的静态文件部署到github的仓库</h3><p>执行命令，首次执行命令的时候会让你输入github的用户名和密码:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<div style="width:400px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2019/03/16/%E5%A6%82%E4%BD%95%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/Snip20190316_3.png" class="" title="将本地的静态文件部署到github"> </div>

<p>最后访问giuhub的地址效果：</p>
<img src="/Blog/2019/03/16/%E5%A6%82%E4%BD%95%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/Snip20190316_5.png" class="" title="Github效果预览图">


<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://hexo.io/zh-cn/docs/">Hexo官网</a><br><a href="https://juejin.im/post/5b8e43a951882542e821b5cc">Hexo + Github 搭建个人博客</a></p>
]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>通用</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度和空间复杂度</title>
    <url>/Blog/2020/09/05/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。</p>
<p>主要还是从算法所占用的「时间」和「空间」两个维度去考量。</p>
<ul>
<li>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。</li>
<li>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。</li>
</ul>
<h2 id="什么是时间复杂度，如何表示？"><a href="#什么是时间复杂度，如何表示？" class="headerlink" title="什么是时间复杂度，如何表示？"></a>什么是时间复杂度，如何表示？</h2><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。</p>
<p>常见时间复杂度：</p>
<table>
<thead>
<tr>
<th align="center">时间复杂度</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(1)</td>
<td align="center">常数复杂度</td>
</tr>
<tr>
<td align="center">O(logn)</td>
<td align="center">对数复杂度</td>
</tr>
<tr>
<td align="center">O(n)</td>
<td align="center">线性时间复杂度</td>
</tr>
<tr>
<td align="center">O(n^2)</td>
<td align="center">平方复杂度</td>
</tr>
<tr>
<td align="center">O(n^3)</td>
<td align="center">立方复杂度</td>
</tr>
<tr>
<td align="center">O(2^n)</td>
<td align="center">指数复杂度</td>
</tr>
<tr>
<td align="center">O(n!)</td>
<td align="center">阶乘复杂度</td>
</tr>
</tbody></table>
<h2 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h2><blockquote>
<p>在算法分析中，主定理（Master Theorem）提供了用渐近符号（大O符号）表示许多由分治法得到的递推关系式的方法。<br>——维基百科</p>
</blockquote>
<p>主定理可以用来分析递归算法的时间复杂度（也叫渐进复杂度）。</p>
<h2 id="常见时间复杂度问题分析"><a href="#常见时间复杂度问题分析" class="headerlink" title="常见时间复杂度问题分析"></a>常见时间复杂度问题分析</h2><ul>
<li>看一段代码根据n的不同情况，运行多少次。</li>
<li>画出递归状态树，第一层1个节点，第二层2个节点，第三层2^2个节点，第四层2^3个节点，最终根据等比数列求和公式计算所有的节点数，就是它的时间复杂度。</li>
</ul>
<h3 id="二叉树遍历，前序、中序、后序：时间复杂度是多少？"><a href="#二叉树遍历，前序、中序、后序：时间复杂度是多少？" class="headerlink" title="二叉树遍历，前序、中序、后序：时间复杂度是多少？"></a>二叉树遍历，前序、中序、后序：时间复杂度是多少？</h3><p>遍历二叉树，每个节点都会访问一次，所以最终时间复杂度都为O(n)，n代表节点总数。<br>也可以通过主定理推算出来。</p>
<h3 id="图的遍历，时间复杂度是多少？"><a href="#图的遍历，时间复杂度是多少？" class="headerlink" title="图的遍历，时间复杂度是多少？"></a>图的遍历，时间复杂度是多少？</h3><p>遍历图的时候，每个节点都会访问一次，所以时间复杂度都是O(n)，n代表节点总数。</p>
<h2 id="搜索算法，DFS、BFS时间复杂度是多少？"><a href="#搜索算法，DFS、BFS时间复杂度是多少？" class="headerlink" title="搜索算法，DFS、BFS时间复杂度是多少？"></a>搜索算法，DFS、BFS时间复杂度是多少？</h2><p>无论是深度优先搜索还是广度优先搜索，每个节点都会遍历一次，最终的时间复杂度是O(n)，n代表节点总数。</p>
<h2 id="二分查找，时间复杂度是多少？"><a href="#二分查找，时间复杂度是多少？" class="headerlink" title="二分查找，时间复杂度是多少？"></a>二分查找，时间复杂度是多少？</h2><p>二分查找，时间复杂度是O(logn)，n代表节点总数。</p>
<h2 id="数组的时间复杂度？"><a href="#数组的时间复杂度？" class="headerlink" title="数组的时间复杂度？"></a>数组的时间复杂度？</h2><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">头部追加</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">尾部追加</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">查找元素</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">插入元素</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">删除元素</td>
<td align="center">O(n)</td>
</tr>
</tbody></table>
<h2 id="链表的时间复杂度？"><a href="#链表的时间复杂度？" class="headerlink" title="链表的时间复杂度？"></a>链表的时间复杂度？</h2><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">头部追加</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">尾部追加</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">查找元素</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">插入元素</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">删除元素</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<h2 id="跳表的时间复杂度？"><a href="#跳表的时间复杂度？" class="headerlink" title="跳表的时间复杂度？"></a>跳表的时间复杂度？</h2><p>跳表处理的是有序链表，被称为“跳跃链表”。跳表的空间复杂度为O(n)。</p>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">头部追加</td>
<td align="center">O(logn)</td>
</tr>
<tr>
<td align="center">尾部追加</td>
<td align="center">O(logn)</td>
</tr>
<tr>
<td align="center">查找元素</td>
<td align="center">O(logn)</td>
</tr>
<tr>
<td align="center">插入元素</td>
<td align="center">O(logn)</td>
</tr>
<tr>
<td align="center">删除元素</td>
<td align="center">O(logn)</td>
</tr>
</tbody></table>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><ul>
<li>1.数组的长度</li>
<li>2.递归的深度</li>
</ul>
<p>如果程序里面开辟了数组，空间复杂度就是O(n)，如果开启的是二维数组，空间复杂度是O(n^2)。如果程序用到了递归，则递归的最大深度就是程序的空间复杂度。如果又开辟了数组又有递归，则空间复杂度为数组长度和递归最大深度之中的较大值。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://skywt.cn/posts/master-theorem">主定理与递归程序时间复杂度的计算</a><br><a href="https://blog.csdn.net/zolalad/article/details/11848739">算法的时间复杂度和空间复杂度-总结</a><br><a href="https://lotabout.me/2018/skip-list/">跳表──没听过但很犀利的数据结构</a><br><a href="https://zhuanlan.zhihu.com/p/50479555">算法的时间与空间复杂度（一看就懂）</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>有趣的网址</title>
    <url>/Blog/2019/06/15/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%BD%91%E5%9D%80/</url>
    <content><![CDATA[<h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><p><a href="http://gufenso.coderschool.cn/">http://gufenso.coderschool.cn/</a> (谷粉搜导航，可以临时用一下谷歌搜索)</p>
<p><a href="https://coderschool.cn/2366.html">https://coderschool.cn/2366.html</a>  （谷歌镜像网站链接收集，有广告）</p>
<p>链接: <a href="https://pan.baidu.com/s/1gePw35p">https://pan.baidu.com/s/1gePw35p</a> 密码: kw1k  （Chrom的饭前插件，注册一个账号，可以免费使用）</p>
<p><a href="https://github.com/XX-net/XX-Net">https://github.com/XX-net/XX-Net</a>   （这个配置有些麻烦，不过用起来还不错，免费）</p>
<p><a href="https://google.jiongjun.cc/user/miror.html">https://google.jiongjun.cc/user/miror.html</a>  （廉价VPS，还有搬瓦工优惠码）</p>
<p><a href="https://blog.kuoruan.com/48.html">https://blog.kuoruan.com/48.html</a>  （搬瓦工搭建Shadowsocks并优化速度）</p>
<p><a href="https://github.com/iMeiji/shadowsocks_install/blob/master/shadowsocksR-wiki/config.json.md">https://github.com/iMeiji/shadowsocks_install/blob/master/shadowsocksR-wiki/config.json.md</a>  (SSR配置文件更改)</p>
<p><a href="https://github.com/racaljk/hosts/blob/master/README.md">https://github.com/racaljk/hosts/blob/master/README.md</a>  （Hosts文件）</p>
<h2 id="谷歌镜像网站"><a href="#谷歌镜像网站" class="headerlink" title="谷歌镜像网站"></a>谷歌镜像网站</h2><p><a href="https://www.uedbox.com/post/54776/">https://www.uedbox.com/post/54776/</a> (体验盒子)<br><a href="http://gufenso.coderschool.cn/">http://gufenso.coderschool.cn/</a> (谷粉搜导航，可以临时用一下谷歌搜索)</p>
<h2 id="Vultr搭建VPS相关教程："><a href="#Vultr搭建VPS相关教程：" class="headerlink" title="Vultr搭建VPS相关教程："></a>Vultr搭建VPS相关教程：</h2><p><a href="https://www.jiongjun.cc/vultr/315.html">https://www.jiongjun.cc/vultr/315.html</a>  (购买和搭建VPS详细教程)</p>
<p><a href="http://yucc.me/p/b4d20b2d/">http://yucc.me/p/b4d20b2d/</a>  (简略版教程)</p>
<h2 id="Shadowsocks-客户端下载："><a href="#Shadowsocks-客户端下载：" class="headerlink" title="Shadowsocks 客户端下载："></a>Shadowsocks 客户端下载：</h2><p><a href="https://lvii.gitbooks.io/outman/content/ss.mac.html">https://lvii.gitbooks.io/outman/content/ss.mac.html</a></p>
<p><a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases/">https://github.com/shadowsocks/ShadowsocksX-NG/releases/</a>  （MAC版客户端下载地址）</p>
<h2 id="资源搜索："><a href="#资源搜索：" class="headerlink" title="资源搜索："></a>资源搜索：</h2><p><a href="https://www.panc.cc/">https://www.panc.cc/</a> 胖次（最新的电影资源，会抽风）</p>
<p><a href="https://www.quzhuanpan.com/">https://www.quzhuanpan.com/</a> 去转盘 （最新的电影，综艺）</p>
<p><a href="https://search.chongbuluo.com/">https://search.chongbuluo.com/</a> 虫部落  （整理非常好的搜索站）</p>
<p><a href="http://www.torrent.org.cn/">http://www.torrent.org.cn</a> (种子和磁链互相转换的网站)</p>
<p><a href="http://www.btbtt10.com/">BT之家</a></p>
<p><a href="http://www.btbtt20.com/">BT之家</a></p>
<p><a href="https://video.bqrdh.com/">不求人导航</a></p>
<h2 id="资源下载："><a href="#资源下载：" class="headerlink" title="资源下载："></a>资源下载：</h2><p>Aria2c </p>
<p>bt-tracker数据:<a href="https://github.com/ngosang/trackerslist/blob/master/trackers_all_udp.txt">https://github.com/ngosang/trackerslist/blob/master/trackers_all_udp.txt</a></p>
<p><a href="https://cowtransfer.com/">奶牛快传(分享临时文件)</a></p>
<h2 id="计算机免费书籍GitHub合集"><a href="#计算机免费书籍GitHub合集" class="headerlink" title="计算机免费书籍GitHub合集:"></a>计算机免费书籍GitHub合集:</h2><p><a href="https://github.com/justjavac/free-programming-books-zh_CN">justjavac/free-programming-books-zh_CN</a>(免费的编程中文书籍索引)</p>
<h2 id="iOS-开发："><a href="#iOS-开发：" class="headerlink" title="iOS 开发："></a>iOS 开发：</h2><p><a href="https://github.com/Tim9Liu9/TimLiu-iOS">https://github.com/Tim9Liu9/TimLiu-iOS</a> （iOS Demo，教程等等）</p>
<p><a href="https://github.com/Aufree/trip-to-iOS">https://github.com/Aufree/trip-to-iOS</a> （偏向于教程）</p>
<p><a href="https://github.com/jobbole/awesome-ios-cn">https://github.com/jobbole/awesome-ios-cn</a> （iOS 资源大全中文版，Demo比较全）</p>
<p><a href="https://github.com/Lax/iOS-Swift-Demos">https://github.com/Lax/iOS-Swift-Demos</a> （Swift 学习资源）</p>
<p><a href="https://github.com/leecade/ios-dev-flow">https://github.com/leecade/ios-dev-flow</a> （iOS 开发证书相关）</p>
<p><a href="https://github.com/Draveness/analyze">https://github.com/Draveness/analyze</a>  （iOS开源框架源代码解析）</p>
<p><a href="https://github.com/zhouhuanqiang/LearningIOS">https://github.com/zhouhuanqiang/LearningIOS</a>  （iOS视频教程）</p>
<p><a href="http://bbs.itheima.com/thread-338489-1-1.html">http://bbs.itheima.com/thread-338489-1-1.html</a></p>
<p><a href="https://zsisme.gitbooks.io/ios-/content/index.html">https://zsisme.gitbooks.io/ios-/content/index.html</a>  (iOS核心动画)</p>
<p><a href="https://nshipster.cn/">https://nshipster.cn/</a></p>
<p><a href="https://www.agoniblog.com/article/75">https://www.agoniblog.com/article/75</a> (有很多视频教程)</p>
<h2 id="Vue-开发："><a href="#Vue-开发：" class="headerlink" title="Vue 开发："></a>Vue 开发：</h2><p><a href="https://github.com/vuejs/awesome-vue">vuejs/awesome-vue</a>(vue 学习资料)</p>
<p><a href="https://ke.qq.com/course/402398?taid=3214894690608094">硅谷外卖视频课程以及很多免费课程</a></p>
<h2 id="iPhone机型介绍："><a href="#iPhone机型介绍：" class="headerlink" title="iPhone机型介绍："></a>iPhone机型介绍：</h2><p><a href="https://support.apple.com/zh-cn/HT201296">https://support.apple.com/zh-cn/HT201296</a>  （iPhone各种机型的详细介绍）</p>
<p><a href="https://www.theiphonewiki.com/wiki/Models">https://www.theiphonewiki.com/wiki/Models</a>  （iOS各种设备的Model的介绍）</p>
<h2 id="Android开发："><a href="#Android开发：" class="headerlink" title="Android开发："></a>Android开发：</h2><p><a href="http://bbs.itheima.com/thread-338469-1-1.html">http://bbs.itheima.com/thread-338469-1-1.html</a></p>
<h2 id="VR开发："><a href="#VR开发：" class="headerlink" title="VR开发："></a>VR开发：</h2><p><a href="https://github.com/GeekLiB/Lee-VR-Source">https://github.com/GeekLiB/Lee-VR-Source</a></p>
<h2 id="工具网站："><a href="#工具网站：" class="headerlink" title="工具网站："></a>工具网站：</h2><p><a href="http://www.iconfont.cn/">http://www.iconfont.cn/</a>   （阿里巴巴矢量图标库）</p>
<p><a href="https://github.com/shengxinjing/programmer-job-blacklist">https://github.com/shengxinjing/programmer-job-blacklist</a>  （程序员找工作黑名单）</p>
<h2 id="设计类网站"><a href="#设计类网站" class="headerlink" title="设计类网站:"></a>设计类网站:</h2><p><a href="http://www.xueui.cn/">http://www.xueui.cn</a></p>
<p><a href="https://magdeleine.co/">https://magdeleine.co</a>  (免费高清摄影图片下载)</p>
<p><a href="http://blog.cocoachina.com/article/73408">http://blog.cocoachina.com/article/73408</a> （8个免费UI图标网站）</p>
<h2 id="逆向工程与加密解密："><a href="#逆向工程与加密解密：" class="headerlink" title="逆向工程与加密解密："></a>逆向工程与加密解密：</h2><p><a href="https://pan.baidu.com/pcloud/album/info?uk=1745354485&amp;album_id=3855093648109743244">https://pan.baidu.com/pcloud/album/info?uk=1745354485&amp;album_id=3855093648109743244</a>  （百度网盘分享链接）</p>
<p><a href="https://www.hackfun.org/kali-tools/kali-tools-zh.html">https://www.hackfun.org/kali-tools/kali-tools-zh.html</a>  （Kali工具说明书）</p>
<p><a href="http://www.he11oworld.com/tag/shentoujiaocheng/page/2/">http://www.he11oworld.com/tag/shentoujiaocheng/page/2/</a> （渗透教程下载）</p>
<p><a href="http://daily.zhihu.com/story/3877456">http://daily.zhihu.com/story/3877456</a> （安全网站列表）</p>
<h2 id="社区："><a href="#社区：" class="headerlink" title="社区："></a>社区：</h2><p>伯乐在线 （<a href="https://github.com/jobbole%EF%BC%89">https://github.com/jobbole）</a></p>
<p><a href="https://www.v2ex.com/go/idev">https://www.v2ex.com/go/idev</a></p>
]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>通用</tag>
      </tags>
  </entry>
  <entry>
    <title>查看autoreleasepool的状态</title>
    <url>/Blog/2020/01/27/%E6%9F%A5%E7%9C%8Bautoreleasepool%E7%9A%84%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<p>查看NSAutoreleasePool 中 autorelease对象的状况，可以使用运行时系统中的函数<code>(lldb)po _objc_autoreleasePoolPrint();</code>。</p>
<p>测试的源代码如下:</p>
<img src="/Blog/2020/01/27/%E6%9F%A5%E7%9C%8Bautoreleasepool%E7%9A%84%E7%8A%B6%E6%80%81/snip1.png" class="" title="源代码截图">

<p>执行断点1处的代码，日志如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-01-27 19:22:37.241288+0800 NSAutoReleasePool测试[7028:191376] 执行断点1处的代码。</span><br><span class="line">(lldb) po _objc_autoreleasePoolPrint();</span><br><span class="line">objc[7028]: ##############</span><br><span class="line">objc[7028]: AUTORELEASE POOLS for thread 0x11a0615c0</span><br><span class="line">objc[7028]: 86 releases pending.</span><br><span class="line">objc[7028]: [0x7ff577009000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[7028]: [0x7ff577009038]  ################  POOL 0x7ff577009038</span><br><span class="line">objc[7028]: [0x7ff577009040]    0x60800002d3a0  __NSCFString</span><br><span class="line">objc[7028]: [0x7ff577009048]  ################  POOL 0x7ff577009048</span><br><span class="line">objc[7028]: [0x7ff577009050]  ################  POOL 0x7ff577009050</span><br><span class="line">objc[7028]: [0x7ff577009058]    0x60800023fca0  CAContextImpl</span><br><span class="line">objc[7028]: [0x7ff577009060]    0x60800023fca0  CAContextImpl</span><br><span class="line">objc[7028]: [0x7ff577009068]    0x604000027500  CAContextImpl</span><br><span class="line">objc[7028]: [0x7ff577009070]    0x604000027500  CAContextImpl</span><br><span class="line">objc[7028]: [0x7ff577009078]    0x604000028d20  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff577009080]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009088]    0x604000071c40  __NSCFDictionary</span><br><span class="line">objc[7028]: [0x7ff577009090]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009098]    0x604000049e40  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff5770090a0]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770090a8]    0x7ff576604080  UIStatusBarWindow</span><br><span class="line">objc[7028]: [0x7ff5770090b0]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770090b8]    0x604000046990  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff5770090c0]    0x7ff57880aeb0  UIView</span><br><span class="line">objc[7028]: [0x7ff5770090c8]    0x7ff57880aeb0  UIView</span><br><span class="line">objc[7028]: [0x7ff5770090d0]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770090d8]    0x604000048970  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff5770090e0]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770090e8]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770090f0]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770090f8]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009100]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff577009108]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009110]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009118]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009120]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff577009128]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009130]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009138]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009140]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009148]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009150]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009158]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff577009160]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009168]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009170]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009178]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff577009180]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009188]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009190]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009198]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770091a0]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091a8]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770091b0]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff5770091b8]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091c0]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091c8]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770091d0]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff5770091d8]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091e0]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091e8]    0x604000046990  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff5770091f0]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770091f8]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009200]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009208]    0x7ff578800540  UITouch</span><br><span class="line">objc[7028]: [0x7ff577009210]    0x604000049420  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff577009218]    0x604000013130  __NSSingleObjectSetI</span><br><span class="line">objc[7028]: [0x7ff577009220]    0x60400008de80  __NSMallocBlock__</span><br><span class="line">objc[7028]: [0x7ff577009228]    0x604000013130  __NSSingleObjectSetI</span><br><span class="line">objc[7028]: [0x7ff577009230]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff577009238]    0x60800010ee80  NSXPCConnection</span><br><span class="line">objc[7028]: [0x7ff577009240]    0x60400008de30  __NSXPCInterfaceProxy__UIKeyboardArbitration</span><br><span class="line">objc[7028]: [0x7ff577009248]    0x60800002ea80  NSXPCInterface</span><br><span class="line">objc[7028]: [0x7ff577009250]       0x10ecc4a58  __NSGlobalBlock__</span><br><span class="line">objc[7028]: [0x7ff577009258]    0x60800002ea80  NSXPCInterface</span><br><span class="line">objc[7028]: [0x7ff577009260]    0x60800002ef60  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff577009268]    0x7ff57880aeb0  UIView</span><br><span class="line">objc[7028]: [0x7ff577009270]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff577009278]    0x7ff57880aeb0  UIView</span><br><span class="line">objc[7028]: [0x7ff577009280]    0x6040000130f0  __NSDate</span><br><span class="line">objc[7028]: [0x7ff577009288]    0x604000360cc0  __NSCFTimer</span><br><span class="line">objc[7028]: [0x7ff577009290]    0x604000029440  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff577009298]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092a0]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092a8]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092b0]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092b8]    0x60400002abc0  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff5770092c0]    0x60400002aaa0  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff5770092c8]    0x6040000132d0  __NSSingleObjectArrayI</span><br><span class="line">objc[7028]: [0x7ff5770092d0]    0x60800010edf0  UITouchesEvent</span><br><span class="line">objc[7028]: [0x7ff5770092d8]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092e0]    0x604000026f00  AppDelegate</span><br><span class="line">objc[7028]: ##############</span><br><span class="line">0x75269231ba3900d2</span><br></pre></td></tr></table></figure>

<p>执行断点2处的代码，日志如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-01-27 19:24:29.654753+0800 NSAutoReleasePool测试[7028:191376] 执行断点2处的代码。</span><br><span class="line">2020-01-27 19:24:29.654806+0800 NSAutoReleasePool测试[7028:191487] XPC connection interrupted</span><br><span class="line">(lldb) po _objc_autoreleasePoolPrint();</span><br><span class="line">objc[7028]: ##############</span><br><span class="line">objc[7028]: AUTORELEASE POOLS for thread 0x11a0615c0</span><br><span class="line">objc[7028]: 87 releases pending.</span><br><span class="line">objc[7028]: [0x7ff577009000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[7028]: [0x7ff577009038]  ################  POOL 0x7ff577009038</span><br><span class="line">objc[7028]: [0x7ff577009040]    0x60800002d3a0  __NSCFString</span><br><span class="line">objc[7028]: [0x7ff577009048]  ################  POOL 0x7ff577009048</span><br><span class="line">objc[7028]: [0x7ff577009050]  ################  POOL 0x7ff577009050</span><br><span class="line">objc[7028]: [0x7ff577009058]    0x60800023fca0  CAContextImpl</span><br><span class="line">objc[7028]: [0x7ff577009060]    0x60800023fca0  CAContextImpl</span><br><span class="line">objc[7028]: [0x7ff577009068]    0x604000027500  CAContextImpl</span><br><span class="line">objc[7028]: [0x7ff577009070]    0x604000027500  CAContextImpl</span><br><span class="line">objc[7028]: [0x7ff577009078]    0x604000028d20  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff577009080]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009088]    0x604000071c40  __NSCFDictionary</span><br><span class="line">objc[7028]: [0x7ff577009090]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009098]    0x604000049e40  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff5770090a0]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770090a8]    0x7ff576604080  UIStatusBarWindow</span><br><span class="line">objc[7028]: [0x7ff5770090b0]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770090b8]    0x604000046990  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff5770090c0]    0x7ff57880aeb0  UIView</span><br><span class="line">objc[7028]: [0x7ff5770090c8]    0x7ff57880aeb0  UIView</span><br><span class="line">objc[7028]: [0x7ff5770090d0]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770090d8]    0x604000048970  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff5770090e0]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770090e8]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770090f0]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770090f8]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009100]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff577009108]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009110]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009118]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009120]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff577009128]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009130]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009138]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009140]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009148]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009150]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009158]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff577009160]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009168]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009170]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009178]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff577009180]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009188]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009190]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009198]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770091a0]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091a8]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770091b0]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff5770091b8]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091c0]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091c8]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770091d0]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff5770091d8]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091e0]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091e8]    0x604000046990  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff5770091f0]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770091f8]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009200]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009208]    0x7ff578800540  UITouch</span><br><span class="line">objc[7028]: [0x7ff577009210]    0x604000049420  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff577009218]    0x604000013130  __NSSingleObjectSetI</span><br><span class="line">objc[7028]: [0x7ff577009220]    0x60400008de80  __NSMallocBlock__</span><br><span class="line">objc[7028]: [0x7ff577009228]    0x604000013130  __NSSingleObjectSetI</span><br><span class="line">objc[7028]: [0x7ff577009230]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff577009238]    0x60800010ee80  NSXPCConnection</span><br><span class="line">objc[7028]: [0x7ff577009240]    0x60400008de30  __NSXPCInterfaceProxy__UIKeyboardArbitration</span><br><span class="line">objc[7028]: [0x7ff577009248]    0x60800002ea80  NSXPCInterface</span><br><span class="line">objc[7028]: [0x7ff577009250]       0x10ecc4a58  __NSGlobalBlock__</span><br><span class="line">objc[7028]: [0x7ff577009258]    0x60800002ea80  NSXPCInterface</span><br><span class="line">objc[7028]: [0x7ff577009260]    0x60800002ef60  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff577009268]    0x7ff57880aeb0  UIView</span><br><span class="line">objc[7028]: [0x7ff577009270]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff577009278]    0x7ff57880aeb0  UIView</span><br><span class="line">objc[7028]: [0x7ff577009280]    0x6040000130f0  __NSDate</span><br><span class="line">objc[7028]: [0x7ff577009288]    0x604000360cc0  __NSCFTimer</span><br><span class="line">objc[7028]: [0x7ff577009290]    0x604000029440  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff577009298]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092a0]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092a8]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092b0]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092b8]    0x60400002abc0  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff5770092c0]    0x60400002aaa0  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff5770092c8]    0x6040000132d0  __NSSingleObjectArrayI</span><br><span class="line">objc[7028]: [0x7ff5770092d0]    0x60800010edf0  UITouchesEvent</span><br><span class="line">objc[7028]: [0x7ff5770092d8]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092e0]    0x604000026f00  AppDelegate</span><br><span class="line">objc[7028]: [0x7ff5770092e8]  ################  POOL 0x7ff5770092e8</span><br><span class="line">objc[7028]: ##############</span><br><span class="line">0x75269231ba3900d2</span><br></pre></td></tr></table></figure>

<p>执行断点3处的代码，日志如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-01-27 19:27:07.529438+0800 NSAutoReleasePool测试[7028:191376] 执行断点3处的代码。</span><br><span class="line">(lldb) po _objc_autoreleasePoolPrint();</span><br><span class="line">objc[7028]: ##############</span><br><span class="line">objc[7028]: AUTORELEASE POOLS for thread 0x11a0615c0</span><br><span class="line">objc[7028]: 88 releases pending.</span><br><span class="line">objc[7028]: [0x7ff577009000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[7028]: [0x7ff577009038]  ################  POOL 0x7ff577009038</span><br><span class="line">objc[7028]: [0x7ff577009040]    0x60800002d3a0  __NSCFString</span><br><span class="line">objc[7028]: [0x7ff577009048]  ################  POOL 0x7ff577009048</span><br><span class="line">objc[7028]: [0x7ff577009050]  ################  POOL 0x7ff577009050</span><br><span class="line">objc[7028]: [0x7ff577009058]    0x60800023fca0  CAContextImpl</span><br><span class="line">objc[7028]: [0x7ff577009060]    0x60800023fca0  CAContextImpl</span><br><span class="line">objc[7028]: [0x7ff577009068]    0x604000027500  CAContextImpl</span><br><span class="line">objc[7028]: [0x7ff577009070]    0x604000027500  CAContextImpl</span><br><span class="line">objc[7028]: [0x7ff577009078]    0x604000028d20  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff577009080]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009088]    0x604000071c40  __NSCFDictionary</span><br><span class="line">objc[7028]: [0x7ff577009090]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009098]    0x604000049e40  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff5770090a0]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770090a8]    0x7ff576604080  UIStatusBarWindow</span><br><span class="line">objc[7028]: [0x7ff5770090b0]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770090b8]    0x604000046990  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff5770090c0]    0x7ff57880aeb0  UIView</span><br><span class="line">objc[7028]: [0x7ff5770090c8]    0x7ff57880aeb0  UIView</span><br><span class="line">objc[7028]: [0x7ff5770090d0]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770090d8]    0x604000048970  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff5770090e0]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770090e8]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770090f0]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770090f8]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009100]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff577009108]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009110]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009118]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009120]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff577009128]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009130]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009138]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009140]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009148]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009150]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009158]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff577009160]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009168]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009170]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009178]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff577009180]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009188]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009190]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009198]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770091a0]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091a8]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770091b0]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff5770091b8]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091c0]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091c8]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770091d0]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff5770091d8]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091e0]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091e8]    0x604000046990  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff5770091f0]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770091f8]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009200]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009208]    0x7ff578800540  UITouch</span><br><span class="line">objc[7028]: [0x7ff577009210]    0x604000049420  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff577009218]    0x604000013130  __NSSingleObjectSetI</span><br><span class="line">objc[7028]: [0x7ff577009220]    0x60400008de80  __NSMallocBlock__</span><br><span class="line">objc[7028]: [0x7ff577009228]    0x604000013130  __NSSingleObjectSetI</span><br><span class="line">objc[7028]: [0x7ff577009230]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff577009238]    0x60800010ee80  NSXPCConnection</span><br><span class="line">objc[7028]: [0x7ff577009240]    0x60400008de30  __NSXPCInterfaceProxy__UIKeyboardArbitration</span><br><span class="line">objc[7028]: [0x7ff577009248]    0x60800002ea80  NSXPCInterface</span><br><span class="line">objc[7028]: [0x7ff577009250]       0x10ecc4a58  __NSGlobalBlock__</span><br><span class="line">objc[7028]: [0x7ff577009258]    0x60800002ea80  NSXPCInterface</span><br><span class="line">objc[7028]: [0x7ff577009260]    0x60800002ef60  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff577009268]    0x7ff57880aeb0  UIView</span><br><span class="line">objc[7028]: [0x7ff577009270]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff577009278]    0x7ff57880aeb0  UIView</span><br><span class="line">objc[7028]: [0x7ff577009280]    0x6040000130f0  __NSDate</span><br><span class="line">objc[7028]: [0x7ff577009288]    0x604000360cc0  __NSCFTimer</span><br><span class="line">objc[7028]: [0x7ff577009290]    0x604000029440  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff577009298]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092a0]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092a8]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092b0]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092b8]    0x60400002abc0  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff5770092c0]    0x60400002aaa0  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff5770092c8]    0x6040000132d0  __NSSingleObjectArrayI</span><br><span class="line">objc[7028]: [0x7ff5770092d0]    0x60800010edf0  UITouchesEvent</span><br><span class="line">objc[7028]: [0x7ff5770092d8]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092e0]    0x604000026f00  AppDelegate</span><br><span class="line">objc[7028]: [0x7ff5770092e8]  ################  POOL 0x7ff5770092e8</span><br><span class="line">objc[7028]: [0x7ff5770092f0]    0x60400004a770  __NSArrayI</span><br><span class="line">objc[7028]: ##############</span><br><span class="line">0x75269231ba3900d2</span><br></pre></td></tr></table></figure>

<p>执行断点4处的代码，日志如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-01-27 19:28:45.777438+0800 NSAutoReleasePool测试[7028:191376] 执行断点4处的代码。</span><br><span class="line">(lldb) po _objc_autoreleasePoolPrint();</span><br><span class="line">objc[7028]: ##############</span><br><span class="line">objc[7028]: AUTORELEASE POOLS for thread 0x11a0615c0</span><br><span class="line">objc[7028]: 86 releases pending.</span><br><span class="line">objc[7028]: [0x7ff577009000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[7028]: [0x7ff577009038]  ################  POOL 0x7ff577009038</span><br><span class="line">objc[7028]: [0x7ff577009040]    0x60800002d3a0  __NSCFString</span><br><span class="line">objc[7028]: [0x7ff577009048]  ################  POOL 0x7ff577009048</span><br><span class="line">objc[7028]: [0x7ff577009050]  ################  POOL 0x7ff577009050</span><br><span class="line">objc[7028]: [0x7ff577009058]    0x60800023fca0  CAContextImpl</span><br><span class="line">objc[7028]: [0x7ff577009060]    0x60800023fca0  CAContextImpl</span><br><span class="line">objc[7028]: [0x7ff577009068]    0x604000027500  CAContextImpl</span><br><span class="line">objc[7028]: [0x7ff577009070]    0x604000027500  CAContextImpl</span><br><span class="line">objc[7028]: [0x7ff577009078]    0x604000028d20  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff577009080]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009088]    0x604000071c40  __NSCFDictionary</span><br><span class="line">objc[7028]: [0x7ff577009090]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009098]    0x604000049e40  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff5770090a0]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770090a8]    0x7ff576604080  UIStatusBarWindow</span><br><span class="line">objc[7028]: [0x7ff5770090b0]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770090b8]    0x604000046990  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff5770090c0]    0x7ff57880aeb0  UIView</span><br><span class="line">objc[7028]: [0x7ff5770090c8]    0x7ff57880aeb0  UIView</span><br><span class="line">objc[7028]: [0x7ff5770090d0]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770090d8]    0x604000048970  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff5770090e0]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770090e8]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770090f0]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770090f8]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009100]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff577009108]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009110]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009118]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009120]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff577009128]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009130]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009138]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009140]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009148]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009150]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009158]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff577009160]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009168]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009170]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009178]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff577009180]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009188]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009190]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009198]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770091a0]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091a8]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770091b0]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff5770091b8]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091c0]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091c8]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770091d0]    0x60c0000f7e00  _UIApplicationCanvas</span><br><span class="line">objc[7028]: [0x7ff5770091d8]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091e0]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff5770091e8]    0x604000046990  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff5770091f0]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff5770091f8]    0x60c0000cbb40  UIApplicationSceneSettings</span><br><span class="line">objc[7028]: [0x7ff577009200]    0x7ff578801260  UIScreen</span><br><span class="line">objc[7028]: [0x7ff577009208]    0x7ff578800540  UITouch</span><br><span class="line">objc[7028]: [0x7ff577009210]    0x604000049420  __NSArrayM</span><br><span class="line">objc[7028]: [0x7ff577009218]    0x604000013130  __NSSingleObjectSetI</span><br><span class="line">objc[7028]: [0x7ff577009220]    0x60400008de80  __NSMallocBlock__</span><br><span class="line">objc[7028]: [0x7ff577009228]    0x604000013130  __NSSingleObjectSetI</span><br><span class="line">objc[7028]: [0x7ff577009230]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff577009238]    0x60800010ee80  NSXPCConnection</span><br><span class="line">objc[7028]: [0x7ff577009240]    0x60400008de30  __NSXPCInterfaceProxy__UIKeyboardArbitration</span><br><span class="line">objc[7028]: [0x7ff577009248]    0x60800002ea80  NSXPCInterface</span><br><span class="line">objc[7028]: [0x7ff577009250]       0x10ecc4a58  __NSGlobalBlock__</span><br><span class="line">objc[7028]: [0x7ff577009258]    0x60800002ea80  NSXPCInterface</span><br><span class="line">objc[7028]: [0x7ff577009260]    0x60800002ef60  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff577009268]    0x7ff57880aeb0  UIView</span><br><span class="line">objc[7028]: [0x7ff577009270]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff577009278]    0x7ff57880aeb0  UIView</span><br><span class="line">objc[7028]: [0x7ff577009280]    0x6040000130f0  __NSDate</span><br><span class="line">objc[7028]: [0x7ff577009288]    0x604000360cc0  __NSCFTimer</span><br><span class="line">objc[7028]: [0x7ff577009290]    0x604000029440  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff577009298]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092a0]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092a8]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092b0]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092b8]    0x60400002abc0  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff5770092c0]    0x60400002aaa0  __NSArrayI</span><br><span class="line">objc[7028]: [0x7ff5770092c8]    0x6040000132d0  __NSSingleObjectArrayI</span><br><span class="line">objc[7028]: [0x7ff5770092d0]    0x60800010edf0  UITouchesEvent</span><br><span class="line">objc[7028]: [0x7ff5770092d8]    0x7ff578808a50  UIWindow</span><br><span class="line">objc[7028]: [0x7ff5770092e0]    0x604000026f00  AppDelegate</span><br><span class="line">objc[7028]: ##############</span><br><span class="line">0x75269231ba3900d2</span><br></pre></td></tr></table></figure>

<p>由以上日志可见，断点1处时<code>objc[7028]: 86 releases pending.</code>，有86个autorelease对象等待释放；然后新建一个autoreleasepool，到断点2处时<code>objc[7028]: 87 releases pending.</code>，有87个autorelease对象等待释放；然后创建一个NSArray对象并注册到autoreleasepool，到断点3处时<code>objc[7028]: 88 releases pending.</code>，有88个对象等待释放；最后出autoreleasepool的范围，新建的NSArray对象和autoreleasepool对象都被释放了，又恢复到最初时候<code>objc[7028]: 86 releases pending.</code>，仍然只有86个对象等待释放。整个的过程可以判断出autoreleasepool的内存管理方式。注意在autoreleasepool中包裹的部分，只有通过类方法，并且不是 alloc/init/copy/mutableCopy 获取到的对象才会注册到当前的autoreleasepool中，才可以使用以上方式查找内存的详细情况。</p>
<p>如果autorelease NSAutoreleasePool对象会如何?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSAutoreleasePool *pool &#x3D; [[NSAutoreleasePool alloc] init];</span><br><span class="line">[pool autorelease];</span><br></pre></td></tr></table></figure>

<p>回答：发生异常，通常在使用Objective-C，也就是Foundation框架时，无论调用哪一个对象的 autorelease 实例方法，实现上调用的都是 NSObject 类的 autorelease 实例方法。但是对于 NSAutoreleasePool类，autorelease 实例方法已被该类重载，因此运行时就会报错。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>《iOS与OS X多线程和内存管理》</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>自动引用计数</title>
    <url>/Blog/2019/12/30/%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="什么是自动引用计数？"><a href="#什么是自动引用计数？" class="headerlink" title="什么是自动引用计数？"></a>什么是自动引用计数？</h2><p>自动引用计数（ARC，Automatic Reference Counting）是指内存管理中对引用采取自动计数的技术。</p>
<h2 id="内存管理的思考方式"><a href="#内存管理的思考方式" class="headerlink" title="内存管理的思考方式"></a>内存管理的思考方式</h2><ul>
<li>自己生成的对象，自己持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>不再需要自己持有的对象时释放。</li>
<li>非自己持有的对象无法释放。</li>
</ul>
<h3 id="自己生成的对象，自己持有"><a href="#自己生成的对象，自己持有" class="headerlink" title="自己生成的对象，自己持有"></a>自己生成的对象，自己持有</h3><p>使用以下名称开头的方法名意味着自己生成的对象自己持有：</p>
<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
</ul>
<p>另外，下列名称也意味着自己生成并持有对象。</p>
<ul>
<li>allocMyObject</li>
<li>newThatObject</li>
<li>copyThis</li>
<li>mutableCopyYourObject</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** 自己生成并持有对象 *&#x2F;</span><br><span class="line">id obj &#x3D; [[NSObject alloc] init];</span><br><span class="line">&#x2F;** 自己持有对象 *&#x2F;</span><br></pre></td></tr></table></figure>

<p>使用<code>[NSObject new] </code>与<code>[[NSObject alloc] init]</code>是完全一致的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** 自己生成并持有对象 *&#x2F;</span><br><span class="line">id obj &#x3D; [NSObject new]</span><br><span class="line">&#x2F;** 自己持有对象 *&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="非自己生成的对象，自己也能持有"><a href="#非自己生成的对象，自己也能持有" class="headerlink" title="非自己生成的对象，自己也能持有"></a>非自己生成的对象，自己也能持有</h3><p>用alloc/new/copy/mutableCopy以外的方法取得的对象，因为非自己生成并持有，所以自己不是该对象的持有者。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** 取得非自己生成并持有的对象 *&#x2F;</span><br><span class="line">id obj &#x3D; [NSMutableArray array];</span><br><span class="line">&#x2F;** 取得的对象存在，但自己不持有对象 *&#x2F;</span><br></pre></td></tr></table></figure>

<p>源代码中，NSMutableArray类对象被赋值给变量obj，但变量obj自己并不持有该对象，使用retain方法可以持有对象。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 取得非自己生成并持有的对象 */</span></span><br><span class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="comment">/** 取得的对象存在，但自己不持有对象 */</span></span><br><span class="line">[obj <span class="keyword">retain</span>];</span><br><span class="line"><span class="comment">/** 自己持有对象 */</span></span><br></pre></td></tr></table></figure>

<p>通过retain方法，非自己生成的对象跟用 alloc/new/copy/mutableCopy 方法生成并持有的对象一样，成为了自己所持有的。</p>
<h3 id="不再需要自己持有的对象时释放"><a href="#不再需要自己持有的对象时释放" class="headerlink" title="不再需要自己持有的对象时释放"></a>不再需要自己持有的对象时释放</h3><p>自己持有的对象，一旦不再需要，持有者有义务释放该对象，释放使用release方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 自己生成并持有对象 */</span></span><br><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="comment">/** 自己持有对象 */</span></span><br><span class="line">[obj release];</span><br><span class="line"><span class="comment">/** 释放对象，指向对象的指针仍然被保留在变量obj中，貌似能够访问，但对象一经释放绝不可访问 */</span></span><br></pre></td></tr></table></figure>

<p>用alloc方法由自己生成并持有的对象就通过release方法释放了。自己生成而非自己所持有的对象，若用retain方法变为自己持有，也同样可以用release方法释放。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** 取得非自己生成并持有的对象 *&#x2F;</span><br><span class="line">id obj &#x3D; [NSMutableArray array];</span><br><span class="line">&#x2F;** 取得的对象存在，但自己不持有对象 *&#x2F;</span><br><span class="line">[obj retain];</span><br><span class="line">&#x2F;** 自己持有对象 *&#x2F;</span><br><span class="line">[obj release];</span><br><span class="line">&#x2F;** 释放对象，对象不可再被访问 *&#x2F;</span><br></pre></td></tr></table></figure>

<p>用 alloc/new/copy/mutableCopy 方法生成并持有的对象，或者用retain方法持有的对象，一旦不再需要，务必要用release方法进行释放。</p>
<p>如果要用某个方法生成对象，并将其返回给该方法的调用方，那么它的源代码又是如何呢？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">id</span>)allocObject &#123;</span><br><span class="line">  <span class="comment">/** 自己生成并持有对象 */</span></span><br><span class="line">  <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">  <span class="comment">/** 自己持有对象 */</span></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上例所示，原封不动的返回alloc方法生成并持有的对象，就能让调用方也持有该对象。请注意allocObject这个名称是符合前文命名规则的。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 取得非自己生成并持有的对象 */</span></span><br><span class="line"><span class="keyword">id</span> obj1 = [obj0 allocObject];</span><br><span class="line"><span class="comment">/** 自己持有对象 */</span></span><br></pre></td></tr></table></figure>

<p>allocObject名称符合前文的命名规则，因此它与用alloc方法生成并持有对象的情况完全相同，所以使用allocObject方法也意味着”自己生成并持有对象”。</p>
<p>那么，调用[NSMutable array]方法使取得的对象存在，但自己不持有对象，又是如何实现的呢？根据上下文命名规则，不能使用alloc/new/copy/mutableCopy 开头的方法名，因此要使用object这个方法名。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)object &#123;</span><br><span class="line">  <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">  <span class="comment">/** 自己持有对象 */</span></span><br><span class="line">  [obj autorelease];</span><br><span class="line">  <span class="comment">/** 取得的对象存在，但自己不持有对象 */</span></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中，我们使用了autorelease方法。用该方法可以使取得的对象存在，但自己不持有对象。autorelease 提供这样的功能，使对象在超出指定的生存范围时，能够自动并正确地释放(调用release 方法)。</p>
<p>使用NSMutableArray类的array类方法等可以取得谁都不持有的对象，这些方法都是通过 autorelease 而实现的。此外，根据上下文的命名规则，这些用来取得谁都不持有的对象的方法名不能以alloc/new/copy/mutableCopy 开头。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> obj1 = [obj0 object];</span><br><span class="line"><span class="comment">/** 取得的对象存在，但自己不持有对象 */</span></span><br></pre></td></tr></table></figure>

<p>当然也可以通过 retain 方法将调用 autorelease 方法取得的对象变为自己持有。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> obj1 = [obj0 object];</span><br><span class="line"><span class="comment">/** 取得的对象存在，但自己不持有对象 */</span></span><br><span class="line">[obj1 <span class="keyword">retain</span>];</span><br><span class="line"><span class="comment">/** 自己持有对象 */</span></span><br></pre></td></tr></table></figure>

<h3 id="非自己持有的对象无法释放"><a href="#非自己持有的对象无法释放" class="headerlink" title="非自己持有的对象无法释放"></a>非自己持有的对象无法释放</h3><p>对于用 alloc/new/copy/mutableCopy 方法生成并持有的对象，或是用 retain 方法持有的对象，由于持有者是自己，所以在不需要该对象时需要将其释放。<b><code>而由此外得到的对象绝对不能释放。倘若在应用程序中释放了非自己持有的对象就会造成崩溃。</code></b>例如自己生成并持有对象后，在释放完不再需要的对象之后再次释放。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 自己生成并持有对象 */</span></span><br><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="comment">/** 自己持有对象 */</span></span><br><span class="line">[obj release];</span><br><span class="line"><span class="comment">/** 对象已释放 */</span></span><br><span class="line">[obj release];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">释放之后再次释放非自己持有的对象</span></span><br><span class="line"><span class="comment">应用程序崩溃</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">崩溃情况：</span></span><br><span class="line"><span class="comment">再度废弃已经废弃了的对象时崩溃</span></span><br><span class="line"><span class="comment">访问已经废弃的对象时崩溃</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>或者在”取得的对象存在，但自己不持有对象”时释放。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> obj1 = [obj0 object];</span><br><span class="line"><span class="comment">/** 取得的对象存在，但自己不持有对象 */</span></span><br><span class="line">[obj1 release];</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">释放了非自己持有的对象</span></span><br><span class="line"><span class="comment">这肯定会导致应用程序崩溃</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p>《iOS与OS X多线程和内存管理》</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次重签名错误</title>
    <url>/Blog/2021/01/10/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E7%AD%BE%E5%90%8D%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h1 id="什么问题？"><a href="#什么问题？" class="headerlink" title="什么问题？"></a>什么问题？</h1><p>最近打开Cydia就闪退，我就重新去下载了uncOver，打算重新越狱一下，但是在重签名的时候一直失败，提示”No codesigning certificates found”的错误。</p>
<img src="/Blog/2021/01/10/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E7%AD%BE%E5%90%8D%E9%94%99%E8%AF%AF/1.png" class="" title="重签名失败的错误截图">

<h1 id="什么原因导致？"><a href="#什么原因导致？" class="headerlink" title="什么原因导致？"></a>什么原因导致？</h1><p>由于我之前使用<code>iOS App Signer</code>这个MAC软件一直没有问题，今天遇到这个问题，我就想去github把源码克隆到本地，然后调试一下，看看具体是什么原因导致。<br>打开源码直接搜索<code>No codesigning</code>发现，这个错误是一个Alert弹框，和我们遇到的弹框信息一致。</p>
<img src="/Blog/2021/01/10/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E7%AD%BE%E5%90%8D%E9%94%99%E8%AF%AF/2.png" class="" title="搜索错误提示的截图">

<p>最终调试发现，在程序调用<code>/usr/bin/security find-identity -v -p codesigning</code>命令时由于返回值为空，才触发错误弹框。</p>
<img src="/Blog/2021/01/10/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E7%AD%BE%E5%90%8D%E9%94%99%E8%AF%AF/3.png" class="" title="源码执行命令的截图">

<p>我把命令拷贝到终端执行，发现返回有效的identity的数量是0:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /usr/bin/security find-identity -v -p codesigning</span><br><span class="line">     0 valid identities found</span><br></pre></td></tr></table></figure>

<p>此处的命令的意思是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/security:</span><br><span class="line">A simple <span class="built_in">command</span> line interface <span class="built_in">which</span> lets you administer keychains, </span><br><span class="line">manipulate keys and certificates, and <span class="keyword">do</span> just about anything the </span><br><span class="line">Security framework is capable of from the <span class="built_in">command</span> line.</span><br><span class="line">(是一个管理钥匙串、keys和证书的命令行接口)</span><br><span class="line"></span><br><span class="line">find-identify:</span><br><span class="line">查找证书和私钥key的命令</span><br><span class="line"></span><br><span class="line">-v: 只显示有效的证书，默认显示所有的证书</span><br><span class="line"></span><br><span class="line">-p: 指定策略</span><br></pre></td></tr></table></figure>

<p>具体的命令行的文档查看一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /usr/bin/security find-identity --<span class="built_in">help</span></span><br><span class="line">find-identity: illegal option -- -</span><br><span class="line">Usage: find-identity [-p policy] [-s string] [-v] [keychain...]</span><br><span class="line">    -p  Specify policy to evaluate (multiple -p options are allowed)</span><br><span class="line">        Supported policies: basic, ssl-client, ssl-server, smime, eap,</span><br><span class="line">        ipsec, ichat, codesigning, sys-default, sys-kerberos-kdc, macappstore, appleID</span><br><span class="line">    -s  Specify optional policy-specific string (e.g. DNS hostname <span class="keyword">for</span> SSL,</span><br><span class="line">        or RFC822 email address <span class="keyword">for</span> S/MIME)</span><br><span class="line">    -v  Show valid identities only (default is to show all identities)</span><br><span class="line">If no keychains are specified to search, the default search list is used.</span><br><span class="line">        Find an identity (certificate + private key).</span><br></pre></td></tr></table></figure>

<h1 id="怎么解决？"><a href="#怎么解决？" class="headerlink" title="怎么解决？"></a>怎么解决？</h1><p>由于使用<code>/usr/bin/security find-identity -v -p codesigning</code>命令无法查询本地有效的重签名证书，我首先想到的就是更换查询策略，根据命令行文档可以看出，策略有很多种，包括<code>basic, ssl-client ssl-server, smime, eap,ipsec, ichat, codesigning, sys-default, sys-kerberos-kdc, macappstore, appleID</code>。经过尝试，发现策略改成<code>appleID</code>的时候是可以查询到有效证书的。但是这两个命令是有区别的。具体的区别如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">poet@poetdeMacBook-Pro ~ % /usr/bin/security find-identity -v -p codesigning</span><br><span class="line">  1) C766972EC48052D14E3A2D715F03960E10B4XXXX <span class="string">&quot;Apple Development: Zhang San (MGRQJNV411)&quot;</span></span><br><span class="line">  2) 8EA5E415105CEE96F75EAFA443B6AC992FC9CCCC <span class="string">&quot;Apple Development: Li Si (SB6BFS5U22)&quot;</span></span><br><span class="line">  3) AEF5450BA48F61EE1B5A718B7563D855E306DDDD <span class="string">&quot;iPhone Developer: Zhang San (MGRQJNV433)&quot;</span></span><br><span class="line">     3 valid identities found</span><br><span class="line">poet@poetdeMacBook-Pro ~ % /usr/bin/security find-identity -v -p appleID    </span><br><span class="line">1.2.840.113635.78.1.30</span><br><span class="line">  1) F87912EA9F939D6F044F1B86A165C5D8AC8CAAAA <span class="string">&quot;com.apple.idms.appleid.prd.5675685073322f516b6a565a55775471374c72424b671234&quot;</span> (CSSMERR_TP_CERT_EXPIRED)</span><br><span class="line">  2) 8751799A43C85FEF3914DE664E2A05251F40BBBB <span class="string">&quot;Mac Developer: Lao Wang (H2C8DTYK00)&quot;</span> (CSSMERR_TP_CERT_EXPIRED)</span><br><span class="line">  3) C766972EC48052D14E3A2D715F03960E10B4CCCC <span class="string">&quot;Apple Development: Zhang San (MGRQJNV411)&quot;</span> (Missing required extension)</span><br><span class="line">  4) 8EA5E415105CEE96F75EAFA443B6AC992FC9DDDD <span class="string">&quot;Apple Development: Li Si (SB6BFS5U22)&quot;</span> (Missing required extension)</span><br><span class="line">  5) AEF5450BA48F61EE1B5A718B7563D855E306EEEE <span class="string">&quot;iPhone Developer: Zhang San (MGRQJNV433)&quot;</span> (Missing required extension)</span><br><span class="line">     5 valid identities found</span><br></pre></td></tr></table></figure>
<p>经过上面的对比，发现策略是<code>codesigning</code>的时候查询出来的是所有有效的重签名的证书，不包含其他的证书（比如：苹果的idms官方证书、MAC电脑的证书等），但是策略是<code>appleID</code>的时候查询出来的证书一定包含策略<code>codesigning</code>查询出来的证书。所以，当使用策略<code>codesigning</code>无法查询出证书情况的时候，可以考虑把策略换成<code>appleID</code>来查询。所以解决办法就是将<code>codesigning</code>策略换成<code>appleID</code>的策略。</p>
<h1 id="提交Pull-Request"><a href="#提交Pull-Request" class="headerlink" title="提交Pull Request"></a>提交Pull Request</h1><p>解决这个问题之后，我去github仓库的issue里面看，发现很多人也有类似的问题，我就自己尝试提交了一个<code>Pull Request</code>到作者的仓库，虽然作者很久没有更新了，但是如果后续还有人碰到此问题可以通过类似的办法解决。如何提交<code>Pull Request</code>，我是参考github上的一个帖子，具体步骤如下：</p>
<h2 id="如何在别人的开源项目中提交自己的Pull-Request"><a href="#如何在别人的开源项目中提交自己的Pull-Request" class="headerlink" title="如何在别人的开源项目中提交自己的Pull Request ?"></a>如何在别人的开源项目中提交自己的Pull Request ?</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.先在本地创建一个空文件夹,里面准备放克隆过来的代码. --&gt; 我在本地Downloads文件夹下创建了一个名为 gitMessagekit 的文件夹.</span><br><span class="line">2.在<span class="string">&quot;终端&quot;</span>中通过<span class="built_in">cd</span>命令进入到gitMessagekit文件夹下(将<span class="string">&quot;自己电脑的用户名&quot;</span>换成你自己的电脑的用户名). --&gt; <span class="built_in">cd</span> /Users/自己电脑的用户名/3.Downloads/gitMessagekit</span><br><span class="line">3.在<span class="string">&quot;终端&quot;</span>输入克隆命令 git <span class="built_in">clone</span> 开源项目源代码的url. --&gt; git <span class="built_in">clone</span> https://github.com/MessageKit/MessageKit.git</span><br><span class="line">4.进入到克隆所在的文件夹. --&gt; <span class="built_in">cd</span> /Users/自己电脑的用户名/Downloads/gitMessagekit/MessageKit</span><br><span class="line">5.用查看命令查看一下开源项目都有多少个分支. --&gt; git branch -a</span><br><span class="line">6.找到自己要切换的分支,准备切换分支,在这里我要切换到3.0.0-beta分支. --&gt; git checkout remotes/origin/3.0.0-beta</span><br><span class="line">7.基于远程分支新建本地分支(3.0.0-beta),2条命令. --&gt; git branch 3.0.0-beta git checkout 3.0.0-beta</span><br><span class="line">8.打开/Users/自己电脑的用户名/Downloads/gitMessagekit/MessageKit该路径下的代码,对代码进行修改.</span><br><span class="line">9.添加修改. --&gt; git add 你修改的文件</span><br><span class="line">10.提交修改. --&gt; git commit -m <span class="string">&quot;fix 某某问题&quot;</span></span><br><span class="line">11.去自己的git仓库,准备fork一下开源项目MessageKit到自己的仓库(repository)中.</span><br><span class="line">12.即将关联自己fork过的项目. --&gt; git remote add upstream git@github.com:xxjldh/MessageKit.git</span><br><span class="line">13.推送本地的分支(3.0.0-beta)到自己fork过的仓库中,2条命令. --&gt; git fetch origin git merge origin/3.0.0-beta</span><br><span class="line">14.在即将提交时出现这样一个错误,git@github.com: Permission denied (publickey).解决办法(https://www.jianshu.com/p/f22d02c7d943)</span><br><span class="line">15.最后push自己的分支到自己fork过的仓库中. --&gt; git push upstream 3.0.0-beta</span><br><span class="line">16.在开源项目https://github.com/MessageKit/MessageKit.git的pull request中添加自己刚修改过的文件, 点<span class="string">&quot;comment pull request&quot;</span>即可.</span><br></pre></td></tr></table></figure>

<h2 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h2><p><a href="https://github.com/DavidWanderer/Blog/releases/tag/1.0.0">下载App重签名工具</a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/pixy/p/4817579.html">Mac Security工具使用总结</a><br><a href="http://blog.fpliu.com/it/os/macOS/software/security">security命令</a><br><a href="https://gist.github.com/zxhfighter/62847a087a2a8031fbdf">如何给开源项目贡献代码</a></p>
]]></content>
      <categories>
        <category>iOS越狱</category>
      </categories>
      <tags>
        <tag>iOS越狱</tag>
      </tags>
  </entry>
</search>
