<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/Blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/Blog/css/main.css">


<link rel="stylesheet" href="/Blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/Blog/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。">
<meta property="og:type" content="website">
<meta property="og:title" content="Stay hungry, Stay foolish.">
<meta property="og:url" content="https://github.com/DavidWanderer/Blog/page/3/index.html">
<meta property="og:site_name" content="Stay hungry, Stay foolish.">
<meta property="og:description" content="合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Stay hungry, Stay foolish.">
<meta name="twitter:description" content="合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。">

<link rel="canonical" href="https://github.com/DavidWanderer/Blog/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Stay hungry, Stay foolish.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/Blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Stay hungry, Stay foolish.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">向上吧，少年</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/Blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/Blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/Blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/Blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://github.com/DavidWanderer/Blog/2019/08/24/Git服务器搭建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Wanderer">
      <meta itemprop="description" content="合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stay hungry, Stay foolish.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2019/08/24/Git服务器搭建/" class="post-title-link" itemprop="url">Git服务器搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-24 09:07:48" itemprop="dateCreated datePublished" datetime="2019-08-24T09:07:48+08:00">2019-08-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-使用ssh命令登录Linux服务器"><a href="#1-使用ssh命令登录Linux服务器" class="headerlink" title="1.使用ssh命令登录Linux服务器"></a>1.使用ssh命令登录Linux服务器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@104.224.156.100 -p 2022</span><br></pre></td></tr></table></figure>
<h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel</span><br><span class="line">$ yum install git</span><br></pre></td></tr></table></figure>
<h2 id="3-接下来我们-创建一个git用户组和用户，用来运行git服务："><a href="#3-接下来我们-创建一个git用户组和用户，用来运行git服务：" class="headerlink" title="3.接下来我们 创建一个git用户组和用户，用来运行git服务："></a>3.接下来我们 创建一个git用户组和用户，用来运行git服务：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ groupadd git</span><br><span class="line">$ useradd git -g git</span><br></pre></td></tr></table></figure>
<h2 id="4-客户端生成ssh公钥"><a href="#4-客户端生成ssh公钥" class="headerlink" title="4.客户端生成ssh公钥"></a>4.客户端生成ssh公钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">192:git poet$ ssh-keygen -t rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/poet/.ssh/id_rsa): </span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /Users/poet/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /Users/poet/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:Rky+UE83syyOMjaKYHeoGduGBaPqnU+rtrcyl7TMdL8 poet@192.168.0.101</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 2048]----+</span></span><br><span class="line"><span class="string">|        o . +    |</span></span><br><span class="line"><span class="string">|       = o o +   |</span></span><br><span class="line"><span class="string">| o    . + o o    |</span></span><br><span class="line"><span class="string">|. o .  o + .     |</span></span><br><span class="line"><span class="string">|oo + .= S .      |</span></span><br><span class="line"><span class="string">|o.X..= *         |</span></span><br><span class="line"><span class="string">|.=.o*.+ .        |</span></span><br><span class="line"><span class="string">|. o+oB.  .       |</span></span><br><span class="line"><span class="string">| ..=O+.  E.      |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br><span class="line"><span class="string">192:git poet$ cat /Users/poet/.ssh/id_rsa.pub</span></span><br><span class="line"><span class="string">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDQVX+tOytAUJq3pKNvIFX2HETKvalq4rlqIFJ04KtKIDykzbct5FxK1jR92oIP+ylEsQGz6dJ3FqIsXSn200UIbGvdCvSX5uSFFu8psV4eX1J7DsA6gcLMXElTEHDr82U6MwFmOR6Vb8RkSwsNzRqv8uDdxrmayvbUnQL3VK+/VNcfTdPl2O4YyrYp/DBtFe8b61QvlmU6x4UaX40Sg/r9/JyFMSEDduse9bvVkqg3xkTpaZqwquY7384Ou2iIr4bzlb5mAjW222foM6YBuBhxlovu5kVhLx4GpPsCcxPBJe8lgiGyAGG4yvJ1CH7Rv658eIFqVUyVeOJGP871pLkR poet@192.168.0.101</span></span><br></pre></td></tr></table></figure>
<h2 id="5-创建证书登录，如果没有该文件就创建它："><a href="#5-创建证书登录，如果没有该文件就创建它：" class="headerlink" title="5.创建证书登录，如果没有该文件就创建它："></a>5.创建证书登录，如果没有该文件就创建它：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /home/git/</span><br><span class="line">$ mkdir .ssh</span><br><span class="line">$ chmod 755 .ssh</span><br><span class="line">$ touch .ssh/authorized_keys</span><br><span class="line">$ chmod 644 .ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<h2 id="6-将生成客户端公钥并复制到服务器上"><a href="#6-将生成客户端公钥并复制到服务器上" class="headerlink" title="6.将生成客户端公钥并复制到服务器上"></a>6.将生成客户端公钥并复制到服务器上</h2><p>收集所有需要登录的用户的公钥，公钥位于id_rsa.pub文件中，把我们的公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。<br>下面我们复制id_rsa.pub里的公钥到服务器的authorized_keys文件中。<br>首先使用ssh连接远程的服务器,然后进入目录/home/git，然后执行如下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost git]<span class="comment"># vim .ssh/authorized_keys</span></span><br></pre></td></tr></table></figure></p>
<p>然后将上面生成的公钥复制到服务器的公钥文件中。复制万保存，查看公钥文件中的内容:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost git]<span class="comment"># cat .ssh/authorized_keys</span></span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDQVX+tOytAUJq3pKNvIFX2HETKvalq4rlqIFJ04KtKIDykzbct5FxK1jR92oIP+ylEsQGz6dJ3FqIsXSn200UIbGvdCvSX5uSFFu8psV4eX1J7DsA6gcLMXElTEHDr82U6MwFmOR6Vb8RkSwsNzRqv8uDdxrmayvbUnQL3VK+/VNcfTdPl2O4YyrYp/DBtFe8b61QvlmU6x4UaX40Sg/r9/JyFMSEDduse9bvVkqg3xkTpaZqwquY7384Ou2iIr4bzlb5mAjW222foM6YBuBhxlovu5kVhLx4GpPsCcxPBJe8lgiGyAGG4yvJ1CH7Rv658eIFqVUyVeOJGP871pLkR poet@192.168.0.101</span><br></pre></td></tr></table></figure></p>
<h2 id="7-初始化Git仓库"><a href="#7-初始化Git仓库" class="headerlink" title="7.初始化Git仓库"></a>7.初始化Git仓库</h2><p>首先我们选定一个目录作为Git仓库，假定是/home/gitrepo/helloword.git，在/home/gitrepo目录下输入命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /home</span><br><span class="line">$ mkdir gitrepo</span><br><span class="line">$ chown git:git gitrepo/</span><br><span class="line">$ <span class="built_in">cd</span> gitrepo</span><br><span class="line"></span><br><span class="line">$ git init --bare helloword.git</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /home/gitrepo/helloword.git/</span><br></pre></td></tr></table></figure></p>
<h2 id="8-以上命令Git创建一个空仓库，服务器上的Git仓库通常都以-git结尾。然后，把仓库所属用户改为git："><a href="#8-以上命令Git创建一个空仓库，服务器上的Git仓库通常都以-git结尾。然后，把仓库所属用户改为git：" class="headerlink" title="8.以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git："></a>8.以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chown -R git:git helloword.git</span><br></pre></td></tr></table></figure>
<h2 id="9-克隆仓库"><a href="#9-克隆仓库" class="headerlink" title="9.克隆仓库"></a>9.克隆仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@104.224.156.100:/home/gitrepo/helloword.git</span><br><span class="line">Cloning into <span class="string">'helloword'</span>...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>
<p>104.224.156.100 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip。</p>
<p>但是我克隆的时候却报错了:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">192:git poet$ git <span class="built_in">clone</span> git@104.224.156.100:2022:/home/gitrepo/helloword.git</span><br><span class="line">Cloning into <span class="string">'helloword'</span>...</span><br><span class="line">ssh: connect to host 104.224.156.100 port 22: Connection refused</span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">192:git poet$</span><br></pre></td></tr></table></figure></p>
<h2 id="10-克隆仓库的时候出了点小差错，因为ssh的端口号被我改了，而Git是依赖于ssh，所以Git的连接请求也会失败。第9步的命令应该换一下"><a href="#10-克隆仓库的时候出了点小差错，因为ssh的端口号被我改了，而Git是依赖于ssh，所以Git的连接请求也会失败。第9步的命令应该换一下" class="headerlink" title="10.克隆仓库的时候出了点小差错，因为ssh的端口号被我改了，而Git是依赖于ssh，所以Git的连接请求也会失败。第9步的命令应该换一下:"></a>10.克隆仓库的时候出了点小差错，因为ssh的端口号被我改了，而Git是依赖于ssh，所以Git的连接请求也会失败。第9步的命令应该换一下:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> ssh://git@104.224.156.100:2022/home/gitrepo/helloword.git</span><br></pre></td></tr></table></figure>
<p>如果你添加到服务器的公钥有效果，则上述命令会自动把项目克隆下来，但是如果公钥无效或者生成公钥的时候设置了密码，则克隆的步骤中会提示输入密码。</p>
<p>这样我们的 Git 服务器安装就完成。</p>
<h2 id="11-如果需要继续添加新的仓库，请到服务器的-home-gitrepo目录下输入命令："><a href="#11-如果需要继续添加新的仓库，请到服务器的-home-gitrepo目录下输入命令：" class="headerlink" title="11.如果需要继续添加新的仓库，请到服务器的/home/gitrepo目录下输入命令："></a>11.如果需要继续添加新的仓库，请到服务器的/home/gitrepo目录下输入命令：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init --bare second.git</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /home/gitrepo/second.git/</span><br></pre></td></tr></table></figure>
<p>以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chown -R git:git second.git</span><br></pre></td></tr></table></figure></p>
<p>然后你就可以在客户端使用git clone正常的克隆项目了。具体操作命令如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> ssh://git@104.224.156.100:2022/home/gitrepo/second.git</span><br></pre></td></tr></table></figure></p>
<h2 id="12-克隆了空项目，想在本地试下git是否好用，可以试试下面的命令。"><a href="#12-克隆了空项目，想在本地试下git是否好用，可以试试下面的命令。" class="headerlink" title="12.克隆了空项目，想在本地试下git是否好用，可以试试下面的命令。"></a>12.克隆了空项目，想在本地试下git是否好用，可以试试下面的命令。</h2><p>创建Readme.txt文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch Readme.txt</span><br></pre></td></tr></table></figure></p>
<p>查看当前项目的Git仓库的状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br></pre></td></tr></table></figure></p>
<p>将Readme.txt文件添加到本地的Git仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add Readme.txt</span><br></pre></td></tr></table></figure></p>
<p>继续查看本地的Git仓库的状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br></pre></td></tr></table></figure></p>
<p>将操作提交到本地的Git仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"add Readme.txt file"</span></span><br></pre></td></tr></table></figure></p>
<p>如果你没有设置本地Git的全局用户名和邮箱，有时候会报错，设置方法如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config  --global user.name 你的目标用户名</span><br><span class="line">$ git config  --global user.email 你的目标邮箱名</span><br></pre></td></tr></table></figure></p>
<p>将操作推送到远程的Git仓库的master分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></p>
<p>在另外一个客户端拉取Git远程仓库master分支的内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure></p>
<p>在本地按时间倒序查看提交的log记录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></p>
<h2 id="13-禁用shell登录"><a href="#13-禁用shell登录" class="headerlink" title="13.禁用shell登录"></a>13.禁用shell登录</h2><p>网上流传在搭建服务器的过程中创建的git用户可以免密登录远程的ssh，试了一把，果不其然登录了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192:~ poet$ ssh git@104.224.156.100 -p 2022</span><br><span class="line">[git@localhost ~]$ ls</span><br><span class="line">[git@localhost ~]$ ls -a</span><br><span class="line">.  ..  .bash_logout  .bash_profile  .bashrc  .ssh</span><br><span class="line">[git@localhost ~]$</span><br></pre></td></tr></table></figure></p>
<p>出于安全考虑，第三步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@git ~]<span class="comment"># cat /etc/passwd | grep git</span></span><br><span class="line"></span><br><span class="line">git:x:1001:1001:git version control:/home/git:/bin/bash</span><br></pre></td></tr></table></figure></p>
<p>改为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@git ~]<span class="comment"># vim /etc/passwd</span></span><br><span class="line"></span><br><span class="line">git:x:1001:1001:git version control:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure></p>
<p>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p>
<p>修改完再试一把，发现已经连接不了远程ssh了:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">192:~ poet$ ssh git@104.224.156.100 -p 2022</span><br><span class="line">Last login: Fri Aug 23 07:56:10 2019 from 222.93.190.219</span><br><span class="line">fatal: What <span class="keyword">do</span> you think I am? A shell?</span><br><span class="line">Connection to 104.224.156.100 closed.</span><br><span class="line">192:~ poet$ ssh git@104.224.156.100 -p 2022</span><br><span class="line">Last login: Fri Aug 23 07:56:39 2019 from 222.93.190.219</span><br><span class="line">fatal: What <span class="keyword">do</span> you think I am? A shell?</span><br><span class="line">Connection to 104.224.156.100 closed.</span><br><span class="line">192:~ poet$</span><br></pre></td></tr></table></figure></p>
<h2 id="14-Git报错收集"><a href="#14-Git报错收集" class="headerlink" title="14.Git报错收集"></a>14.Git报错收集</h2><ul>
<li><p>git clone does not appear to be a git repository<br>错误示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">poetmacbook-pro:git kris$ git <span class="built_in">clone</span> ssh://git@10.211.55.4:/home/gitrepo/IMBasic.git</span><br><span class="line">正克隆到 <span class="string">'IMBasic'</span>...</span><br><span class="line">fatal: <span class="string">'/home/gitrepo/IMBasic.git'</span> does not appear to be a git repository</span><br><span class="line">fatal: 无法读取远程仓库。</span><br><span class="line"></span><br><span class="line">请确认您有正确的访问权限并且仓库存在。</span><br></pre></td></tr></table></figure>
<p>问题产生的原因：git仓库的路径不对，请确认<code>/home/gitrepo/IMBasic.git</code>是否确实存在，还要注意此处应该使用服务器上的绝对路径，不能使用相对路径。</p>
</li>
</ul>
<p>参考链接:<br><a href="https://www.runoob.com/git/git-server.html" target="_blank" rel="noopener">Git 服务器搭建</a><br><a href="https://www.linuxidc.com/Linux/2014-05/101830.htm" target="_blank" rel="noopener">Git 服务器搭建与客户端安装</a><br><a href="https://www.cnblogs.com/bass6/p/6382633.html" target="_blank" rel="noopener">git 从远程git服务上拉代码 git服务器非默认端口</a><br><a href="https://baijiahao.baidu.com/s?id=1621628813408131040&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">Git常用命令总结及其用法说明</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://github.com/DavidWanderer/Blog/2019/07/07/MySQL基本命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Wanderer">
      <meta itemprop="description" content="合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stay hungry, Stay foolish.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2019/07/07/MySQL基本命令/" class="post-title-link" itemprop="url">MySQL基本命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-07 11:33:14" itemprop="dateCreated datePublished" datetime="2019-07-07T11:33:14+08:00">2019-07-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>MAC OSX上安装MySQL有多种方法：</p>
<ul>
<li><ol>
<li>使用DMG文件安装，安装完在系统偏好设置中有相应的管理面板可以控制MySQL服务器开启和关闭，详情可访问<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">官网下载地址</a></li>
</ol>
</li>
<li><ol start="2">
<li>使用Homebrew安装，打开终端，输入命令<code>brew install mysql</code> ,这个安装过程中可能需要升级Homebrew，Homebrew的升级需要翻墙</li>
</ol>
</li>
</ul>
<h2 id="安装完测试MySQL需要使用的基本命令如下："><a href="#安装完测试MySQL需要使用的基本命令如下：" class="headerlink" title="安装完测试MySQL需要使用的基本命令如下："></a>安装完测试MySQL需要使用的基本命令如下：</h2><p>1.使用brew安装完MySQL时,root密码默认为空，如果要设置MySQL的相关安全策略，使用命令: <code>mysql_secure_installation</code></p>
<p>2.打开mysql,带后台线程（电脑重启后会自己开启）:<code>brew services start mysql</code></p>
<p>3.打开mysql，不带后台线程:<code>mysql.server start</code></p>
<p>4.退出mysql:<code>brew services stop mysql</code></p>
<p>5.登录MySQL:<code>mysql -u root -p</code></p>
<p>6.查看MySQL的版本号:mysql&gt; <code>select Version();</code></p>
<p>7.查看当前登录的MySQL运行的端口号:mysql&gt; <code>show global variables like &#39;port&#39;;</code></p>
<p>8.显示可用的数据库:<code>SHOW DATABASES;</code></p>
<p>9.选择数据库:mysql&gt; <code>USE crashcourse;</code></p>
<p>10.显示数据库中所有可用的表:mysql&gt; <code>SHOW TABLES;</code></p>
<p>11.显示表列: <code>SHOW COLUMNS FROM customers;</code> 或 <code>DESCRIBE customers;</code></p>
<p>12.显示服务器状态信息:<code>SHOW STATUS;</code></p>
<p>13.显示用户的安全权限:<code>SHOW GRANTS;</code></p>
<p>14.显示服务器错误信息:<code>SHOW ERRORS;</code></p>
<p>15.显示服务器警告信息:<code>SHOW WARNINGS;</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://github.com/DavidWanderer/Blog/2019/06/27/分类的原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Wanderer">
      <meta itemprop="description" content="合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stay hungry, Stay foolish.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2019/06/27/分类的原理/" class="post-title-link" itemprop="url">分类的原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-27 16:00:32" itemprop="dateCreated datePublished" datetime="2019-06-27T16:00:32+08:00">2019-06-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="分类的原理"><a href="#分类的原理" class="headerlink" title="分类的原理"></a>分类的原理</h2><p>对于分类的作用恐怕大家都是知道的吧，今天就让我们一起研究一下分类的实现原理。</p>
<p>首先创建一个<code>person</code>类，然后在创建<code>person</code>类的两个分类<code>Person+eat</code>&amp;<code>Person+Run</code>。<br>研究原理我们的思路就是:</p>
<ul>
<li>1、生成c++文件，查看c++文件中的实现</li>
<li>2、如果c++文件中实现介绍的不太具体就去查看<a href="https://opensource.apple.com/source/objc4/" target="_blank" rel="noopener">源码</a>实现</li>
</ul>
<p>我们使用<code>xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc Person+eat.m</code>来生成c++代码</p>
<p>我们可以找到分类都包含了哪些东西<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> *<span class="title">cls</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">instance_methods</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">class_methods</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">prop_list_t</span> *<span class="title">properties</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们发现里面并没有对方法属性协议等等的具体实现过程，那么我们在去<a href="https://opensource.apple.com/source/objc4/" target="_blank" rel="noopener">源码</a>中查看一下相关实现过程。</p>
<p>源码解读顺序</p>
<ul>
<li>1、objc-os.mm（runtime初始化的代码）<ul>
<li>_objc_init</li>
<li>map_images</li>
<li>map_images_nolock</li>
</ul>
</li>
<li>2、objc-runtime-new.mm<ul>
<li>_read_images</li>
<li>remethodizeClass</li>
<li>attachCategories</li>
<li>attachLists</li>
<li>realloc、memmove、 memcpy</li>
</ul>
</li>
</ul>
<p>我们按照源码查找一路找到<code>attachCategories</code>方法，我们发现这个方法就是对分类的实现。里面第一句解释<code>Attach method lists and properties and protocols from categories to a class.</code>将方法列表、属性和协议从类别附加到类中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">attachCategories(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方法数组，这是一个二维数组</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	[</span></span><br><span class="line"><span class="comment">	[method_t,method_t],</span></span><br><span class="line"><span class="comment">	[method_t,method_t]</span></span><br><span class="line"><span class="comment">	]</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">method_list_t</span> **mlists = (<span class="keyword">method_list_t</span> **)</span><br><span class="line">	<span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">	<span class="comment">//属性数组，这是一个二维数组</span></span><br><span class="line">	<span class="keyword">property_list_t</span> **proplists = (<span class="keyword">property_list_t</span> **)</span><br><span class="line">	<span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</span><br><span class="line">	<span class="comment">//协议数组，这是一个二维数组</span></span><br><span class="line">	<span class="keyword">protocol_list_t</span> **protolists = (<span class="keyword">protocol_list_t</span> **)</span><br><span class="line">	<span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> propcount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> protocount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = cats-&gt;count;</span><br><span class="line">	<span class="keyword">bool</span> fromBundle = NO;</span><br><span class="line">	<span class="keyword">while</span> (i--) &#123;</span><br><span class="line">	<span class="comment">//取出某个分类</span></span><br><span class="line">	<span class="keyword">auto</span>&amp; entry = cats-&gt;<span class="built_in">list</span>[i];</span><br><span class="line">	<span class="comment">//取出分类里面的方法列表</span></span><br><span class="line">	<span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">	<span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">		mlists[mcount++] = mlist;</span><br><span class="line">		fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">property_list_t</span> *proplist = </span><br><span class="line">	entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">	<span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">		proplists[propcount++] = proplist;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;protocols;</span><br><span class="line">	<span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">		protolists[protocount++] = protolist;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//得到对象里面的数据</span></span><br><span class="line">	<span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">	prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">	<span class="comment">//将所有分类的对象方法，附加到类对象的方法列表中</span></span><br><span class="line">	rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">	<span class="built_in">free</span>(mlists);</span><br><span class="line">	<span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) flushCaches(cls);</span><br><span class="line">	<span class="comment">//将所有分类的属性，附加到类对象的属性列表中</span></span><br><span class="line">	rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">	<span class="built_in">free</span>(proplists);</span><br><span class="line">	<span class="comment">//将所有分类的协议，附加到类对象的协议列表中</span></span><br><span class="line">	rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">	<span class="built_in">free</span>(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现<code>rw-&gt;methods.attachLists(mlists, mcount);</code>方法是实现将所有分类的对象方法，附加到类对象的方法列表中，其他两个属性和协议都是调用这个方法，我们分析一个就可以了。</p>
<p>点击进入<code>attachLists</code>方法，里面有一个段实现代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">	<span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">	<span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">	<span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">	setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">	<span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">	<span class="comment">//array()-&gt;list 原来的方法列表</span></span><br><span class="line">	memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">	<span class="comment">//addedList 所有分类的方法列表</span></span><br><span class="line">	<span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1、扩容，把类中的方法数组和分类中的方法数组计算出来</li>
<li>2、<code>memmove</code>把类中方法放到数组的最后一位</li>
<li>3、<code>memcpy</code>把分类中的方法放到数组的前面。</li>
</ul>
<img src="/Blog/2019/06/27/分类的原理/分类.png" title="分类">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://github.com/DavidWanderer/Blog/2019/06/27/KVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Wanderer">
      <meta itemprop="description" content="合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stay hungry, Stay foolish.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2019/06/27/KVC/" class="post-title-link" itemprop="url">KVC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-27 15:07:28" itemprop="dateCreated datePublished" datetime="2019-06-27T15:07:28+08:00">2019-06-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h2><p>KVC（Key-value coding）键值编码，指iOS的开发中，可以允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值而不需要调用明确的存取方法。</p>
<h3 id="1、KVC中常见方法"><a href="#1、KVC中常见方法" class="headerlink" title="1、KVC中常见方法"></a>1、KVC中常见方法</h3><p>我们随便点击进入<code>setValue:forKey</code>方法，我们可以发现里面的方法基本上都是基于<code>NSObject</code>的<code>NSKeyValueCoding</code>分类写的，所以对于所有继承了NSObject的类型，也就是几乎所有的Objective-C对象都能使用KVC(一些纯Swift类和结构体是不支持KVC的)，下面是KVC最为重要的四个方法：<br><img src="/Blog/2019/06/27/KVC/KVC1.png" title="KVC截图"></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;                          <span class="comment">//直接通过Key来取值</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;          <span class="comment">//通过Key来设值</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;                  <span class="comment">//通过KeyPath来取值</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;  <span class="comment">//通过KeyPath来设值</span></span><br></pre></td></tr></table></figure>
<p><code>NSKeyValueCoding</code>类别中还有其他的一些方法，这些方法在碰到特殊情况或者有特殊需求还是会用到的<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认返回YES，表示如果没有找到Set&lt;Key&gt;方法的话，会按照_key，_iskey，key，iskey的顺序搜索成员，设置成NO就不这样搜索</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)accessInstanceVariablesDirectly;</span><br><span class="line"></span><br><span class="line"><span class="comment">//KVC提供属性值正确性验证的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)validateValue:(<span class="keyword">inout</span> <span class="keyword">id</span> __<span class="keyword">nullable</span> * __<span class="keyword">nonnull</span>)ioValue forKey:(<span class="built_in">NSString</span> *)inKey error:(<span class="keyword">out</span> <span class="built_in">NSError</span> **)outError;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是集合操作的API，里面还有一系列这样的API，如果属性是一个NSMutableArray，那么可以用这个方法来返回。</span></span><br><span class="line">- (<span class="built_in">NSMutableArray</span> *)mutableArrayValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果Key不存在，且没有KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常。</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和上一个方法一样，但这个方法是设值。</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你在SetValue方法时面给Value传nil，则会调用这个方法</span></span><br><span class="line">- (<span class="keyword">void</span>)setNilValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入一组key,返回该组key对应的Value，再转成字典返回，用于将Model转到字典。</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br></pre></td></tr></table></figure></p>
<h3 id="2、KVC的内部实现机制"><a href="#2、KVC的内部实现机制" class="headerlink" title="2、KVC的内部实现机制"></a>2、KVC的内部实现机制</h3><h4 id="KVC的setValue-forKey原理"><a href="#KVC的setValue-forKey原理" class="headerlink" title="KVC的setValue:forKey原理"></a>KVC的<code>setValue:forKey</code>原理</h4><p>我们先来一张图片可以直接明了的看清楚实现原理<br><img src="/Blog/2019/06/27/KVC/KVC2.png" title="KVC截图"></p>
<ul>
<li>1、按照<code>setKey</code>，<code>_setKey</code>的顺序查找<code>成员方法</code>，如果找到方法，传递参数，调用方法</li>
<li>2、如果没有找到，查看<code>accessInstanceVariablesDirectly</code>的返回值（<code>accessInstanceVariablesDirectly</code>的返回值默认是<code>YES</code>），<ul>
<li>返回值为YES，按照<code>_Key,_isKey,Key,isKey</code>的顺序查找<code>成员变量</code>，如果找到，直接赋值，如果没有找到，调用<code>setValue:forUndefinedKey:</code>，抛出异常</li>
<li>返回NO，直接调用<code>setValue:forUndefinedKey:</code>，抛出异常</li>
</ul>
</li>
</ul>
<h4 id="KVC的ValueforKey原理"><a href="#KVC的ValueforKey原理" class="headerlink" title="KVC的ValueforKey原理"></a>KVC的<code>ValueforKey</code>原理</h4><img src="/Blog/2019/06/27/KVC/KVC3.png" title="KVC截图">
<ul>
<li>1、按照<code>getKey,key,isKey,_key</code>的顺序查找<code>成员方法</code>，如果找到直接调用<code>取值</code></li>
<li>2、如果没有找到，查看<code>accessInstanceVariablesDirectly</code>的返回值</li>
<li>返回值为YES，按照<code>_Key,_isKey,Key,isKey</code>的顺序查找<code>成员变量</code>，如果找到，直接<code>取值</code>，如果没有找到，调用<code>setValue:forUndefinedKey:</code>，抛出异常</li>
<li>返回NO，直接调用<code>setValue:forUndefinedKey:</code>，抛出异常</li>
</ul>
<h3 id="3、KVC的使用"><a href="#3、KVC的使用" class="headerlink" title="3、KVC的使用"></a>3、KVC的使用</h3><h4 id="KVC基础使用"><a href="#KVC基础使用" class="headerlink" title="KVC基础使用"></a>KVC基础使用</h4><p>假设我们有一个<code>Person</code>类，里面有一个<code>age</code>属性，我们给<code>age</code>赋值和取值</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">[p setValue:@<span class="number">10</span> forKey:<span class="string">@"age"</span>];</span><br><span class="line"><span class="comment">//取值</span></span><br><span class="line">[p valueForKey:<span class="string">@"age"</span>];</span><br></pre></td></tr></table></figure>
<p>这也是最简单的使用方法了，也是我们平时项目中最常使用的方法了。</p>
<h4 id="KVC中使用keyPath"><a href="#KVC中使用keyPath" class="headerlink" title="KVC中使用keyPath"></a>KVC中使用keyPath</h4><p>但是当<code>Person</code>类里面有一个<code>Student</code>类，里面有一个<code>height</code>属性，我们怎么赋值<code>height</code>属性呢，<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) Student *stu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>我们能否这样写呢<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc]init];</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">[p setValue:@<span class="number">10</span> forKey:<span class="string">@"stu.height"</span>];</span><br><span class="line"><span class="comment">//取值</span></span><br><span class="line">[p valueForKey:<span class="string">@"stu.height"</span>];</span><br></pre></td></tr></table></figure></p>
<p>我们运行程序打印结果:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2020-06-27 15:41:13.085990+0800 KVC[2974:107108] *** Terminating app due to uncaught exception 'NSUnknownKeyException', reason: '[&lt;Person 0x600000d90160&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key stu.height.'</span><br><span class="line">*** First throw call stack:</span><br><span class="line">(</span><br><span class="line">	<span class="number">0</span>   CoreFoundation                      <span class="number">0x00007fff23c7127e</span> __exceptionPreprocess + <span class="number">350</span></span><br><span class="line">	<span class="number">1</span>   libobjc.A.dylib                     <span class="number">0x00007fff513fbb20</span> objc_exception_throw + <span class="number">48</span></span><br><span class="line">	<span class="number">2</span>   CoreFoundation                      <span class="number">0x00007fff23c70e49</span> -[<span class="built_in">NSException</span> raise] + <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>打印结果是<code>this class is not key value coding-compliant for the key stu.height.</code>,所以这个方法是不可以的，但是iOS为我们提供了另一个方法<code>KeyPath</code>:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc]init];</span><br><span class="line">p.stu = [[Student alloc]init];</span><br><span class="line">[p setValue:@<span class="number">180</span> forKeyPath:<span class="string">@"stu.height"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"valueForKey:%@"</span>,[p valueForKeyPath:<span class="string">@"stu.height"</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"stu.height:%f"</span>,p.stu.height);</span><br></pre></td></tr></table></figure></p>
<p>打印结果:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">43</span>:<span class="number">31.258661</span>+<span class="number">0800</span> KVC[<span class="number">3012</span>:<span class="number">108720</span>] valueForKey:<span class="number">180</span></span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">43</span>:<span class="number">31.258805</span>+<span class="number">0800</span> KVC[<span class="number">3012</span>:<span class="number">108720</span>] stu.height:<span class="number">180.000000</span></span><br></pre></td></tr></table></figure>
<p><code>keyPath</code>除了对当前对象的属性进行赋值外，还可以对其更“深层”的对象进行赋值。KVC进行多级访问时，直接类似于属性调用一样用点语法进行访问即可。</p>
<h4 id="KVC之集合属性"><a href="#KVC之集合属性" class="headerlink" title="KVC之集合属性"></a>KVC之集合属性</h4><p>如果我们想要修改集合类型，我们该怎么办呢，不要着急，系统还是很友好的给我们提供了一些方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableArray</span> *)mutableArrayValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="built_in">NSMutableArray</span> *)mutableArrayValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMutableSet</span> *)mutableSetValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">- (<span class="built_in">NSMutableSet</span> *)mutableSetValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMutableOrderedSet</span> *)mutableOrderedSetValueForKey:(<span class="built_in">NSString</span> *)key </span><br><span class="line">- (<span class="built_in">NSMutableOrderedSet</span> *)mutableOrderedSetValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br></pre></td></tr></table></figure></p>
<p>简单使用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">[[p mutableArrayValueForKey:<span class="string">@"list"</span>] addObject:<span class="string">@"test"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"mutableArrayValueForKey:%@"</span>,[p valueForKeyPath:<span class="string">@"list"</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,p.list);</span><br></pre></td></tr></table></figure></p>
<p>关于<code>mutableArrayValueForKey:</code>的适用场景，网上一般说是在<code>KVO</code>中，因为<code>KVO的本质是系统监测到某个属性的内存地址或常量改变</code>时会添加上<code>- (void)willChangeValueForKey:(NSString *)key</code>和<code>- (void)didChangeValueForKey:(NSString *)key</code>方法来发送通知，但是如果直接改数组的话，内存地址并没有改变。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">	[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">	<span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span>|<span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">	_p = [[Person alloc]init];</span><br><span class="line">	[_p addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"list"</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line"><span class="comment">//    [_p.list addObject:@(arc4random()%255)];</span></span><br><span class="line"><span class="comment">//    NSLog(@"打印内存地址：%x",self.p.list);</span></span><br><span class="line"><span class="comment">//    NSLog(@"打印内容:%@",self.p.list);</span></span><br><span class="line"></span><br><span class="line">	[[<span class="keyword">self</span>.p mutableArrayValueForKey:<span class="string">@"list"</span>] addObject:@(arc4random()%<span class="number">255</span>)];</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"打印内存地址：%x"</span>,<span class="keyword">self</span>.p.list);</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"打印内容:%@"</span>,<span class="keyword">self</span>.p.list);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line">	[_p removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"list"</span>]; <span class="comment">//一定要在dealloc里面移除观察</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们分别用<code>[_p.list addObject:@(arc4random()%255)];</code>和<code>[[self.p mutableArrayValueForKey:@&quot;list&quot;] addObject:@(arc4random()%255)];</code>两个方法修改<code>list</code>内容，我们打印可知<code>[_p.list addObject:@(arc4random()%255)];</code>方法并没有改变<code>list</code>的内存地址，而使用<code>[[self.p mutableArrayValueForKey:@&quot;list&quot;] addObject:@(arc4random()%255)];</code>  ， <code>list</code>的内存地址改变了。</p>
<h4 id="KVC之字典属性"><a href="#KVC之字典属性" class="headerlink" title="KVC之字典属性"></a>KVC之字典属性</h4><p>KVC里面还有两个关于NSDictionary的方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br><span class="line">- (<span class="keyword">void</span>)setValuesForKeysWithDictionary:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)keyedValues;</span><br></pre></td></tr></table></figure></p>
<p><code>dictionaryWithValuesForKeys:</code>是指输入一组key，返回这组key对应的属性，再组成一个字典<br><code>setValuesForKeysWithDictionary</code>是用来修改dic中对应key的属性</p>
<p>这个属性最常用到的地方就是字典转模型<br>例如我们有一个<code>Student</code>类，<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">float</span> height;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>我们正常是怎么赋值呢<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student *stu = [[Student alloc]init];</span><br><span class="line">stu.age = <span class="number">10</span>;</span><br><span class="line">stu.name = <span class="string">@"jack"</span>;</span><br><span class="line">stu.height = <span class="number">180</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果里面有100个属性呢，我们就需要写100遍。如果使用<code>setValuesForKeysWithDictionary</code>方法呢<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student *stu = [[Student alloc]init];</span><br><span class="line"><span class="comment">//在进行网络请求的时候dic不需要我们手写，是后台返回的</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *dic = @&#123;<span class="string">@"name"</span>:<span class="string">@"jack"</span>,<span class="string">@"height"</span>:@<span class="number">180</span>,<span class="string">@"age"</span>:@<span class="number">10</span>&#125;;</span><br><span class="line">[stu setValuesForKeysWithDictionary:dic];</span><br></pre></td></tr></table></figure></p>
<p>这样是不是简单了好多。</p>
<h3 id="4、KVC异常处理"><a href="#4、KVC异常处理" class="headerlink" title="4、KVC异常处理"></a>4、KVC异常处理</h3><p>当根据KVC搜索规则，没有搜索到对应的key或者keyPath，则会调用对应的异常方法。异常方法的默认实现，在异常发生时会抛出一个<code>NSUndefinedKeyException</code>的异常，并且应用程序<code>Crash</code>。我们可以重写下面两个方法，根据业务需求合理的处理KVC导致的异常。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)setNilValueForKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure></p>
<p>其中重写这两个方法，在<code>key</code>值不存在的时候，会走下面方法，而不会异常抛出<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure></p>
<p>重写这个方法，当value值为nil的时候，会走下面方法，而不会异常抛出<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setNilValueForKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure></p>
<h3 id="5、KVC的正确性验证"><a href="#5、KVC的正确性验证" class="headerlink" title="5、KVC的正确性验证"></a>5、KVC的正确性验证</h3><p>在调用KVC时可以先进行验证，验证通过下面两个方法进行，支持key和keyPath两种方式。验证方法默认实现返回YES，可以通过重写对应的方法修改验证逻辑。</p>
<p>验证方法需要我们手动调用，并不会在进行KVC的过程中自动调用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)validateValue:(<span class="keyword">inout</span> <span class="keyword">id</span> _Nullable * _Nonnull)ioValue forKey:(<span class="built_in">NSString</span> *)inKey error:(<span class="keyword">out</span> <span class="built_in">NSError</span> **)outError;</span><br><span class="line">- (<span class="built_in">BOOL</span>)validateValue:(<span class="keyword">inout</span> <span class="keyword">id</span> _Nullable * _Nonnull)ioValue forKeyPath:(<span class="built_in">NSString</span> *)inKeyPath error:(<span class="keyword">out</span> <span class="built_in">NSError</span> **)outError;</span><br></pre></td></tr></table></figure></p>
<p> 在validateValue方法的内部实现中，如果传入的value或key有问题，可以通过返回NO来表示错误，并设置NSError对象。</p>
<p><a href="https://github.com/DavidWanderer/iOS_Examples">参考demo</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://github.com/DavidWanderer/Blog/2019/06/22/KVO实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Wanderer">
      <meta itemprop="description" content="合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stay hungry, Stay foolish.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2019/06/22/KVO实现原理/" class="post-title-link" itemprop="url">KVO实现原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-22 20:28:49" itemprop="dateCreated datePublished" datetime="2019-06-22T20:28:49+08:00">2019-06-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="KVO实现原理"><a href="#KVO实现原理" class="headerlink" title="KVO实现原理"></a>KVO实现原理</h2><p><code>KVO(key value observing)</code>键值监听是我们在开发中常使用的用于监听特定对象属性值变化的方法，常用于监听数据模型的变化 。<br>KVO是为了监听一个对象的某个属性值是否发生变化。在属性值发生变化的时候，肯定会调用其setter方法。所以<strong><code>KVO的本质就是监听对象有没有调用被监听属性对应的setter方法</code></strong>。<br>在学习实现原理之前我们首先先了解一下<code>KVO</code>常用的有哪些方法。</p>
<h3 id="KVO常用方法"><a href="#KVO常用方法" class="headerlink" title="KVO常用方法"></a>KVO常用方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注册监听器</span></span><br><span class="line"><span class="comment">监听器对象为observer，被监听对象为消息的发送者即方法的调用者在回调函数中会被回传</span></span><br><span class="line"><span class="comment">监听的属性路径为keyPath支持点语法的嵌套</span></span><br><span class="line"><span class="comment">监听类型为options支持按位或来监听多个事件类型</span></span><br><span class="line"><span class="comment">监听上下文context主要用于在多个监听器对象监听相同keyPath时进行区分</span></span><br><span class="line"><span class="comment">添加监听器只会保留监听器对象的地址，不会增加引用，也不会在对象释放后置空，因此需要自己持有监听对象的强引用，该参数也会在回调函数中回传</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">删除监听器</span></span><br><span class="line"><span class="comment">监听器对象为observer，被监听对象为消息的发送者即方法的调用者，应与addObserver方法匹配</span></span><br><span class="line"><span class="comment">监听的属性路径为keyPath，应与addObserver方法的keyPath匹配</span></span><br><span class="line"><span class="comment">监听上下文context，应与addObserver方法的context匹配</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">与上一个方法相同，只是少了context参数</span></span><br><span class="line"><span class="comment">推荐使用上一个方法，该方法由于没有传递context可能会产生异常结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">监听器对象的监听回调方法</span></span><br><span class="line"><span class="comment">keyPath即为监听的属性路径</span></span><br><span class="line"><span class="comment">object为被监听的对象</span></span><br><span class="line"><span class="comment">change保存被监听的值产生的变化</span></span><br><span class="line"><span class="comment">context为监听上下文，由add方法回传</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure>
<h3 id="KVO简单实现"><a href="#KVO简单实现" class="headerlink" title="KVO简单实现"></a>KVO简单实现</h3><p>我们创建一个<code>person</code>对象，然后在里面添加一个<code>age</code>属性，我们就来观察一下<code>age</code>属性。<br><strong>person对象</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong>简单实现</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) Person *p1;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) Person *p2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.p1 = [[Person alloc]init];</span><br><span class="line">    <span class="keyword">self</span>.p2 = [[Person alloc]init];</span><br><span class="line">    <span class="keyword">self</span>.p1.age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">self</span>.p2.age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给person1对象添加KVO监听</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [<span class="keyword">self</span>.p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="string">@"123"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="keyword">self</span>.p1.age = arc4random()%<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">self</span>.p2.age = arc4random()%<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.p1 removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当监听对象的属性值发生改变时，就会调用</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听到%@的%@属性值改变了 - %@ - %@"</span>, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码就是一个<code>KVO</code>的简单实现，但是我们有没有想过他的内部到底是怎样实现的呢，今天我们就来探究一下<code>KVO</code>的内部实现原理。</p>
<h3 id="KVO的内部实现"><a href="#KVO的内部实现" class="headerlink" title="KVO的内部实现"></a>KVO的内部实现</h3><p>探究一个对象底层实现最简单的办法就行打印一些对象信息，看看有什么改变，我们在给<code>person1</code>添加监听之前分别打印<code>p1,p2</code>的类信息。<br>代码实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"person1添加KVO监听之前 - %@ %@"</span>, object_getClass(<span class="keyword">self</span>.p1), object_getClass(<span class="keyword">self</span>.p2));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给person1对象添加KVO监听</span></span><br><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">[<span class="keyword">self</span>.p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="string">@"123"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"person1添加KVO监听之后 - %@ %@"</span>, object_getClass(<span class="keyword">self</span>.p1), object_getClass(<span class="keyword">self</span>.p2));</span><br></pre></td></tr></table></figure>
<p>打印结果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">17</span>:<span class="number">41.812979</span>+<span class="number">0800</span> KVO[<span class="number">28865</span>:<span class="number">5328765</span>] person1添加KVO监听之前 - Person Person</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">17</span>:<span class="number">41.814729</span>+<span class="number">0800</span> KVO[<span class="number">28865</span>:<span class="number">5328765</span>] person1添加KVO监听之后 - <span class="built_in">NSKVONotifying_Person</span> Person</span><br></pre></td></tr></table></figure></p>
<p>我们根据结果看到，在添加KVO观察者之后<code>p1</code>的类对象由<code>Person</code>变成了<code>NSKVONotifying_Person</code>，虽然<code>p1</code>的类对象变成了<code>NSKVONotifying_Person</code>，但是我们在调用的时候感觉我们的<code>p1</code>的类对象还是<code>Person</code>，所以，我们可以猜测<code>KVO</code>会在运行时动态创建一个新类，将对象的<code>isa</code>指向新创建的类，<code>新类是原类的子类</code>，命名规则是<code>NSKVONotifying_xxx</code>的格式。KVO为了使其更像之前的类，还会将对象的<code>class实例方法重写</code>，使其更像原类。</p>
<p> <strong>查看P1内部方法是否改变</strong></p>
<p>我们在发现<code>p1</code>的类对象由<code>Person</code>变成了<code>NSKVONotifying_Person</code>，那我们也随便打印一下<code>Person</code>和<code>NSKVONotifying_Person</code>内部方法都变成了什么。</p>
<p>打印一下方法名：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)printMethodNamesOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// 获得方法数组</span></span><br><span class="line">    Method *methodList = class_copyMethodList(cls, &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储方法名</span></span><br><span class="line">    <span class="built_in">NSMutableString</span> *methodNames = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 获得方法</span></span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        <span class="comment">// 获得方法名</span></span><br><span class="line">        <span class="built_in">NSString</span> *methodName = <span class="built_in">NSStringFromSelector</span>(method_getName(method));</span><br><span class="line">        <span class="comment">// 拼接方法名</span></span><br><span class="line">        [methodNames appendString:methodName];</span><br><span class="line">        [methodNames appendString:<span class="string">@", "</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放</span></span><br><span class="line">    free(methodList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印方法名</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, cls, methodNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们分别在KVO监听前后在分别打印一下<code>p1</code>的类对象：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"person1添加KVO监听之前的内部方法==="</span>);</span><br><span class="line">[<span class="keyword">self</span> printMethodNamesOfClass:object_getClass(<span class="keyword">self</span>.p1)];</span><br><span class="line"><span class="comment">// 给person1对象添加KVO监听</span></span><br><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">[<span class="keyword">self</span>.p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="string">@"123"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"person1添加KVO监听之后的内部方法==="</span>);</span><br><span class="line">[<span class="keyword">self</span> printMethodNamesOfClass:object_getClass(<span class="keyword">self</span>.p1)];</span><br></pre></td></tr></table></figure></p>
<p>打印结果:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">21</span>:<span class="number">35.457729</span>+<span class="number">0800</span> KVO[<span class="number">28868</span>:<span class="number">5329249</span>] person1添加KVO监听之前的内部方法===</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">21</span>:<span class="number">35.458094</span>+<span class="number">0800</span> KVO[<span class="number">28868</span>:<span class="number">5329249</span>] Person setAge:, age,</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">21</span>:<span class="number">35.459171</span>+<span class="number">0800</span> KVO[<span class="number">28868</span>:<span class="number">5329249</span>] person1添加KVO监听之后的内部方法===</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">21</span>:<span class="number">35.459334</span>+<span class="number">0800</span> KVO[<span class="number">28868</span>:<span class="number">5329249</span>] <span class="built_in">NSKVONotifying_Person</span> setAge:, <span class="keyword">class</span>, dealloc, _isKVOA,</span><br></pre></td></tr></table></figure></p>
<p>我们在来打印一些KVO监听前后<code>setAge</code>方法发生了什么改变，因为值得改变肯定是因为<code>set</code>方法导致的，所以我们打印一下<code>setAge</code>方法。<code>methodForSelector</code>可以打印方法地址，我们分别在KVO监听前后打印。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"person1添加KVO监听之前 - %p %p"</span>,</span><br><span class="line">[<span class="keyword">self</span>.p1 methodForSelector:<span class="keyword">@selector</span>(setAge:)],</span><br><span class="line">[<span class="keyword">self</span>.p2 methodForSelector:<span class="keyword">@selector</span>(setAge:)]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给person1对象添加KVO监听</span></span><br><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">[<span class="keyword">self</span>.p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="string">@"123"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"person1添加KVO监听之后 - %p %p"</span>,</span><br><span class="line">[<span class="keyword">self</span>.p1 methodForSelector:<span class="keyword">@selector</span>(setAge:)],</span><br><span class="line">[<span class="keyword">self</span>.p2 methodForSelector:<span class="keyword">@selector</span>(setAge:)]);</span><br></pre></td></tr></table></figure>
<p>打印结果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">25</span>:<span class="number">12.925158</span>+<span class="number">0800</span> KVO[<span class="number">28871</span>:<span class="number">5329672</span>] person1添加KVO监听之前 - <span class="number">0x100192338</span> <span class="number">0x100192338</span></span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">25</span>:<span class="number">12.925468</span>+<span class="number">0800</span> KVO[<span class="number">28871</span>:<span class="number">5329672</span>] person1添加KVO监听之后 - <span class="number">0x2269f0a38</span> <span class="number">0x100192338</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以利用lldb分别看一下具体的方法实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">25</span>:<span class="number">12.925158</span>+<span class="number">0800</span> KVO[<span class="number">28871</span>:<span class="number">5329672</span>] person1添加KVO监听之前 - <span class="number">0x100192338</span> <span class="number">0x100192338</span></span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">25</span>:<span class="number">12.925468</span>+<span class="number">0800</span> KVO[<span class="number">28871</span>:<span class="number">5329672</span>] person1添加KVO监听之后 - <span class="number">0x2269f0a38</span> <span class="number">0x100192338</span></span><br><span class="line">(lldb) p (IMP)<span class="number">0x100192338</span></span><br><span class="line">(IMP) $<span class="number">0</span> = <span class="number">0x0000000100192338</span> (KVO`-[Person setAge:] at Person.h:<span class="number">12</span>)</span><br><span class="line">(lldb) p (IMP)<span class="number">0x2269f0a38</span></span><br><span class="line">(IMP) $<span class="number">1</span> = <span class="number">0x00000002269f0a38</span> (Foundation`_NSSetLongLongValueAndNotify)</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>
<p>根据以上总结，我们大概猜到在使用KVO前后对象的改变了。<br><strong>未使用KVO监听的对象</strong><br><img src="/Blog/2019/06/22/KVO实现原理/KVO3.png" title="KVO截图"></p>
<p><strong>使用KVO监听的对象</strong><br><img src="/Blog/2019/06/22/KVO实现原理/KVO4.png" title="KVO截图"></p>
<ul>
<li>1、重写class方法是为了我们调用它的时候返回跟重写继承类之前同样的内容。KVO底层交换了 NSKVONotifying_Person 的 class 方法，让其返回 Person。</li>
<li>2、重写setter方法:在新的类中会重写对应的set方法，是为了在set方法中增加另外两个方法的调用。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在didChangeValueForKey:方法再调用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context</span><br></pre></td></tr></table></figure></p>
<ul>
<li>3、重写dealloc方法，销毁新生成的NSKVONotifying_类。</li>
<li>4、重写_isKVOA方法，这个私有方法估计可能是用来标示该类是一个 KVO 机制声称的类。</li>
</ul>
<h3 id="NSSetLongLongValueAndNotify"><a href="#NSSetLongLongValueAndNotify" class="headerlink" title="_NSSetLongLongValueAndNotify"></a>_NSSetLongLongValueAndNotify</h3><p>在添加KVO监听方法以后<code>setAge</code>方法变成了<code>_NSSetLongLongValueAndNotify</code>,所以我们可以大概猜测动态监听方法主要就是在这里面实现的。我们可以在终端使用命令来查看<code>NSSet * ValueAndNotify</code>的类型。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm -a /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation | grep ValueAndNotify</span><br></pre></td></tr></table></figure></p>
<img src="/Blog/2019/06/22/KVO实现原理/KVO6.png" title="KVO截图">
<p>我们可以在<code>Person</code>类中重写<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>,来猜测一下<code>_NSSetLongLongValueAndNotify</code>的内部实现。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="built_in">NSInteger</span>)age&#123;</span><br><span class="line">    _age = age;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"调用set方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key&#123;</span><br><span class="line">    [<span class="keyword">super</span> willChangeValueForKey:key];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"willChangeValueForKey"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didChangeValueForKey - begin"</span>);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">super</span> didChangeValueForKey:key];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didChangeValueForKey - end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台打印的截图:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-24</span> <span class="number">22</span>:<span class="number">48</span>:<span class="number">59.344573</span>+<span class="number">0800</span> KVO[<span class="number">1762</span>:<span class="number">38744</span>] willChangeValueForKey</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-24</span> <span class="number">22</span>:<span class="number">48</span>:<span class="number">59.344766</span>+<span class="number">0800</span> KVO[<span class="number">1762</span>:<span class="number">38744</span>] 调用set方法</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-24</span> <span class="number">22</span>:<span class="number">48</span>:<span class="number">59.344915</span>+<span class="number">0800</span> KVO[<span class="number">1762</span>:<span class="number">38744</span>] didChangeValueForKey - begin</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-24</span> <span class="number">22</span>:<span class="number">48</span>:<span class="number">59.345209</span>+<span class="number">0800</span> KVO[<span class="number">1762</span>:<span class="number">38744</span>] 监听到&lt;Person: <span class="number">0x6000018a4250</span>&gt;的age属性值改变了 - &#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = <span class="number">61</span>;</span><br><span class="line">    old = <span class="number">10</span>;</span><br><span class="line">&#125; - <span class="number">123</span></span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-24</span> <span class="number">22</span>:<span class="number">48</span>:<span class="number">59.345340</span>+<span class="number">0800</span> KVO[<span class="number">1762</span>:<span class="number">38744</span>] didChangeValueForKey - end</span><br></pre></td></tr></table></figure></p>
<p>根据打印结果我们可以推断<code>_NSSetLongLongValueAndNotify</code>内部实现为:<br>1.调用<code>willChangeValueForKey</code>方法。<br>2.调用<code>setAge</code>方法。<br>3.调用<code>didChangeValueForKey</code>方法。<br>4.在<code>didChangeValueForKey</code>方法内部调用<code>oberser</code>的<br><code>observeValueForKeyPath: ofObject: change: context:</code>方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">void</span> _NSSetIntValueAndNotify() &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"age"</span>];</span><br><span class="line">    [<span class="keyword">super</span> setAge:age];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"age"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">// 通知监听器，某某属性值发生了改变</span></span><br><span class="line">    [oberser observeValueForKeyPath:key ofObject:<span class="keyword">self</span> change:<span class="literal">nil</span> context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>讲了这些，我们来讨论面试题吧</p>
<p><strong>1、iOS用什么方式实现对一个对象的KVO？(KVO的本质是什么？)</strong></p>
<ul>
<li>1、利用RuntimeAPI动态生成一个子类<code>NSKVONotifying_XXX</code>，并且让instance对象的isa指向这个全新的子类<code>NSKVONotifying_XXX</code>。</li>
<li>2、当修改对象的属性时，会在子类<code>NSKVONotifying_XXX</code>调用Foundation的<code>_NSSetXXXValueAndNotify</code>函数。</li>
<li>3、在<code>_NSSetXXXValueAndNotify</code>函数中依次调用：<pre><code>- 1、willChangeValueForKey
- 2、父类原来的setter
- 3、didChangeValueForKey，didChangeValueForKey:内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）
</code></pre></li>
</ul>
<p><strong>2、如何手动触发KVO方法</strong><br>手动调用<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>方法。</p>
<p>键值观察通知依赖于 NSObject 的两个方法: <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey</code>。在一个被观察属性发生改变之前， <code>willChangeValueForKey:</code> 一定会被调用，这就会记录旧的值。而当改变发生后， <code>didChangeValueForKey</code> 会被调用，继而<code>observeValueForKey:ofObject:change:context:</code>也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了有人可能会问只调用<code>didChangeValueForKey</code>方法可以触发KVO方法，其实是不能的，因为<code>willChangeValueForKey:</code> 记录旧的值，如果不记录旧的值，那就没有改变一说了。</p>
<p><strong>3、直接修改成员变量会触发KVO吗</strong><br>不会触发KVO，因为<code>KVO的本质就是监听对象有没有调用被监听属性对应的setter方法</code>，直接修改成员变量，是在内存中修改的，不走<code>set</code>方法。</p>
<p><strong>4、不移除KVO监听，会发生什么</strong></p>
<ul>
<li>不移除会造成内存泄漏。</li>
<li>但是多次重复移除会崩溃。系统为了实现KVO，为NSObject添加了一个名为NSKeyValueObserverRegistration的Category，KVO的add和remove的实现都在里面。在移除的时候，系统会判断当前KVO的key是否已经被移除，如果已经被移除，则主动抛出一个NSException的异常。</li>
</ul>
<p><a href="https://github.com/DavidWanderer/iOS_Examples">参考demo</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://github.com/DavidWanderer/Blog/2019/06/22/OC对象的分类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Wanderer">
      <meta itemprop="description" content="合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stay hungry, Stay foolish.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2019/06/22/OC对象的分类/" class="post-title-link" itemprop="url">OC对象的分类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-22 19:27:03" itemprop="dateCreated datePublished" datetime="2019-06-22T19:27:03+08:00">2019-06-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="OC对象的分类"><a href="#OC对象的分类" class="headerlink" title="OC对象的分类"></a>OC对象的分类</h2><p> OC对象主要可以分为3种</p>
<ul>
<li>1、instance对象（实例对象）：instance实例对象就是通过alloc出来的对象，每次调用alloc都会产生新的instance对象</li>
<li>2、class对象（类对象）：每个类的内存中有且只有一个类对象</li>
<li>3、meta-class对象（元类对象）：每个类的内存中有且只有一个元类对象</li>
</ul>
<p>实例对象的存储信息</p>
<ul>
<li>isa指针</li>
<li>其他成员变量</li>
</ul>
<p>类对象的存储信息</p>
<ul>
<li>isa指针</li>
<li>superClass指针</li>
<li>类的属性信息（@property），类的对象方法信息（method），类的协议信息（protocol），类的成员变量信息（ivar）</li>
</ul>
<p>元类的存储信息</p>
<ul>
<li>isa指针</li>
<li>superClass指针</li>
<li>类的属性信息（@property），类的对象方法信息（method），类的协议信息（protocol），类的成员变量信息（ivar）</li>
</ul>
<p><code>元类和类的存储结构是一样的，但是用途不一样</code></p>
<img src="/Blog/2019/06/22/OC对象的分类/OC对象的分类1.png" title="OC对象的分类">
<ul>
<li>instance的isa指向class，当调用<code>对象方法</code>时，通过instance的isa找到class，最后找到对象方法的实现进行调用</li>
<li>class的isa指向meta-class，当调用<code>类方法</code>时，通过class的isa找到meta-class，最后找到<code>类方法</code></li>
</ul>
<h2 id="总览图"><a href="#总览图" class="headerlink" title="总览图"></a>总览图</h2> <img src="/Blog/2019/06/22/OC对象的分类/OC对象类的继承图谱.png" title="OC对象类的继承图谱">
<ul>
<li>1、instance的<code>isa</code>指向class</li>
<li>2、class的<code>isa</code>指向meta-class</li>
<li>3、meta-class的<code>isa</code>指向基类的meta-class</li>
<li>4、class的<code>superclass</code>指向<code>父类的class</code>，如果没有父类，superclass指向nil</li>
<li>5、meta-class的<code>superclass</code>指向父类的meta-class，基类的meta-class的superclass指向基类的class</li>
<li>6、instance的调用轨迹：isa找class，方法不存在，就通过superclass找父类</li>
<li>7、class调用类方法的轨迹：isa找到meta-class，方法不存在，就通过superclass找父类</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://github.com/DavidWanderer/Blog/2019/06/19/一个NSObject对象占用多少内存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Wanderer">
      <meta itemprop="description" content="合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stay hungry, Stay foolish.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2019/06/19/一个NSObject对象占用多少内存/" class="post-title-link" itemprop="url">一个NSObject对象占用多少内存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-19 12:12:17" itemprop="dateCreated datePublished" datetime="2019-06-19T12:12:17+08:00">2019-06-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一个NSObject对象占用多少内存"><a href="#一个NSObject对象占用多少内存" class="headerlink" title="一个NSObject对象占用多少内存"></a>一个NSObject对象占用多少内存</h2><p>我们平时所编写的Objective-C代码，底层实现都是C/C++代码，</p>
<img src="/Blog/2019/06/19/一个NSObject对象占用多少内存/Object-C代码底层实现.png" title="Objective-C代码底层实现">
<p>所以OC的面向对象都是基于C/C++的数据结构实现的</p>
<p><code>思考:OC对象主要是基于C/C++的什么数据结构实现的呢？？？</code></p>
<p>想要了解OC对象主要是基于C/C++的什么数据结构实现的，我们首先要做的就是将Objective-C代码转化为C/C++代码，这样我们才能清楚的看清是怎么实现的</p>
<p>然后我们打开终端，在命令行找到cd到文件目录，然后中输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br></pre></td></tr></table></figure></p>
<p>命令可以将main.m编译成C++的代码，改成不同的文件名，就会生成不同的c++代码<br>这是就生成了main.cpp这个c++文件，打开文件代码<br>查看该main.cpp最底下的main函数， </p>
<p>但是不同平台支持的代码肯定是不一样的，像平台有<code>Windows</code>、<code>mac</code>、<code>iOS</code>，架构有<code>模拟器(i386)、32bit(armv7)、64bit（arm64）</code>，我们使用<code>iOS</code>，他的架构现在基本上都是<code>64bit（arm64）</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc OC源文件  -o  输出的CPP文件</span><br><span class="line">如果需要链接其他框架，使用-framework参数。比如-framework UIKit</span><br></pre></td></tr></table></figure>
<p>在终端输入命令以后，我们会生成一个<code>main.cpp</code>文件，打开<code>main.cpp</code>文件文件，我们把<code>main.cpp</code>文件拉到最下面，我们会看到这样一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">/* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一段代码就是我们OC代码中的<code>main</code>函数的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">	@autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时我们在<code>main</code>函数写入这一段代码，然后我们点击进入，查看代码实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSObject *obj = [[NSObject alloc] init];</span><br></pre></td></tr></table></figure></p>
<p>点击<code>NSObject</code>进入内部，可以看到NSObject底层实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject &#123;</span><br><span class="line">	Class isa;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们用<code>NSObject_IMPL</code>查找在c++文件中具体的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们再一次执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc main.m</span><br></pre></td></tr></table></figure></p>
<p>生成的C++代码为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">	/* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">	NSObject *obj = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有两个方法可以打印内存大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 获得NSObject实例对象的成员变量所占用的大小  </span><br><span class="line">NSLog(@&quot;%zd&quot;, class_getInstanceSize([NSObject class]));</span><br><span class="line"></span><br><span class="line">// 获得obj指针所指向内存的大小  </span><br><span class="line">NSLog(@&quot;%zd&quot;, malloc_size((__bridge const void *)obj));</span><br></pre></td></tr></table></figure></p>
<p>打印结果</p>
<img src="/Blog/2019/06/19/一个NSObject对象占用多少内存/NSObject对象内存.png" title="NSObject对象内存">
<h2 id="一个OC对象在内存中是怎么样布局的呢"><a href="#一个OC对象在内存中是怎么样布局的呢" class="headerlink" title="一个OC对象在内存中是怎么样布局的呢"></a>一个OC对象在内存中是怎么样布局的呢</h2><p>我们在C++文件中找到NSObject的实现<br>OC代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject &#123;</span><br><span class="line">	Class isa;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>c++代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们知道一个指针是<code>8个字节</code>，但是NSObject对象打印<code>16个字节</code>,他们是怎么样布局的呢</p>
<img src="/Blog/2019/06/19/一个NSObject对象占用多少内存/NSObject对象内存地址.png" title="NSObject对象内存地址">
<p>我们可以根据内存地址实时查看内存分配情况<code>Debug -&gt; Debug Workfllow -&gt; View Memory （Shift + Command + M）</code></p>
<p>菜单选项如何查看内存：<br><img src="/Blog/2019/06/19/一个NSObject对象占用多少内存/查看内存数据.png" title="查看内存数据"></p>
<p>输入内存地址：<br><img src="/Blog/2019/06/19/一个NSObject对象占用多少内存/查看内存数据1.png" title="查看内存数据1"></p>
<p>通过Xcode查看内存数据:<br><img src="/Blog/2019/06/19/一个NSObject对象占用多少内存/查看内存数据2.png" title="查看内存数据2"></p>
<p>通过LLDB命令查看内存数据:<br><img src="/Blog/2019/06/19/一个NSObject对象占用多少内存/查看内存数据3.png" title="查看内存数据3"></p>
<p>我们也可以直接使用 <code>LLDB命令</code>来查看内存地址<br><strong>常用LLDB命令</strong></p>
<ul>
<li>print、p：打印</li>
<li>po：打印对象</li>
<li><p>读取内存</p>
<ul>
<li>memory read/数量格式字节数  内存地址</li>
<li>x/数量格式字节数  内存地址（格式：x是16进制，f是浮点，d是10进制；字节大小<br>：b：byte 1字节，h：half word 2字节，w：word 4字节，g：giant word 8字节）</li>
</ul>
</li>
<li><p>修改内存中的值（memory  write  内存地址  数值   memory  write  0x0000010  10）</p>
</li>
</ul>
<p><strong>问题1</strong>：假设我创建一个<code>Animal</code>类，里面有<code>age</code>,<code>weight</code>两个属性，那么他的内存是多大呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal *animal = [[Animal alloc] init];</span><br><span class="line">animal.age = 10;</span><br><span class="line">animal.weight = 20;</span><br></pre></td></tr></table></figure>
<p>我们先执行命令，查看一下c++源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Animal_IMPL &#123;</span><br><span class="line">	struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">	int _age;</span><br><span class="line">	int _weight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们在知道结果之前大概猜猜内存是多大呢？16，24，32…</p>
<p>猜16字节的猜对了，我们先看看结果</p>
<img src="/Blog/2019/06/19/一个NSObject对象占用多少内存/Animal内存打印.png" title="Animal内存打印">
<p>我们用<code>LLDB命令</code>打印一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po animal</span><br><span class="line">&lt;Animal: 0x1005c23c0&gt;</span><br><span class="line"></span><br><span class="line">(lldb) memory read 0x1005c23c0</span><br><span class="line">0x1005c23c0: 81 13 00 00 01 80 1d 00 0a 00 00 00 14 00 00 00  ................</span><br><span class="line">0x1005c23d0: a0 24 5c 00 01 00 00 00 e0 26 5c 00 01 00 00 00  .$\......&amp;\.....</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure></p>
<p> 为什么会是<code>0a 00 00 00</code>和<code>14 00 00 00</code>呢，而不是<code>00 00 00 0a</code>和<code>00 00 00 14</code>,这个就要考虑<a href="https://baike.baidu.com/item/大小端模式/6750542?fromtitle=大端小端&amp;fromid=15925891&amp;fr=aladdin" target="_blank" rel="noopener">大端小端</a>，具体概念自己可以去查。</p>
<p>但是为什么会是16个字节呢，因为int类型占用4个字节，两个int类型8个字节，一个<code>isa</code>8个字节，因为刚刚占满16个字节，对象就没有在开辟新的空间了</p>
<p>如果在多一个<code>feetCount</code>会占用几个字节呢</p>
<img src="/Blog/2019/06/19/一个NSObject对象占用多少内存/Cat内存打印.png" title="Cat内存打印">
<p><code>占用32个字节，大家是不是很惊讶，没有猜到</code></p>
<p>其实这又要提到一个新的知识点了<code>内存对齐</code>,我们知道OC对象就是C++结构体，<code>而结构体的大小必须是最大成员大小的倍数</code>，当在多了一个<code>feetCount</code>以后，内存不够用了，然后就需要扩展了。</p>
<p><strong>如果是这样呢，占用内存是多少</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) int age;</span><br><span class="line">@property (nonatomic, assign) int weight;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Cat : Animal</span><br><span class="line">@property (nonatomic, assign) int feetCount;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Cat</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p><code>Cat</code>继承自<code>Animal</code></p>
<img src="/Blog/2019/06/19/一个NSObject对象占用多少内存/Cat内存打印.png" title="Cat内存打印">
<p>我们生成C++代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Cat_IMPL &#123;</span><br><span class="line">	struct Animal_IMPL Animal_IVARS;</span><br><span class="line">	int _feetCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Animal_IMPL &#123;</span><br><span class="line">	struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">	int _weight;</span><br><span class="line">	int _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>整理一下就是这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Cat_IMPL &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">	int _weight;</span><br><span class="line">	int _age;</span><br><span class="line">	int _feetCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/DavidWanderer/iOS_Examples">参考demo</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://github.com/DavidWanderer/Blog/2019/06/15/有趣的网址/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Wanderer">
      <meta itemprop="description" content="合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stay hungry, Stay foolish.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2019/06/15/有趣的网址/" class="post-title-link" itemprop="url">有趣的网址</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-15 10:08:20" itemprop="dateCreated datePublished" datetime="2019-06-15T10:08:20+08:00">2019-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/通用/" itemprop="url" rel="index"><span itemprop="name">通用</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><p><a href="http://gufenso.coderschool.cn/" target="_blank" rel="noopener">http://gufenso.coderschool.cn/</a> (谷粉搜导航，可以临时用一下谷歌搜索)</p>
<p><a href="https://coderschool.cn/2366.html" target="_blank" rel="noopener">https://coderschool.cn/2366.html</a>  （谷歌镜像网站链接收集，有广告）</p>
<p>链接: <a href="https://pan.baidu.com/s/1gePw35p" target="_blank" rel="noopener">https://pan.baidu.com/s/1gePw35p</a> 密码: kw1k  （Chrom的饭前插件，注册一个账号，可以免费使用）</p>
<p><a href="https://github.com/XX-net/XX-Net">https://github.com/XX-net/XX-Net</a>   （这个配置有些麻烦，不过用起来还不错，免费）</p>
<p><a href="https://google.jiongjun.cc/user/miror.html" target="_blank" rel="noopener">https://google.jiongjun.cc/user/miror.html</a>  （廉价VPS，还有搬瓦工优惠码）</p>
<p><a href="https://blog.kuoruan.com/48.html" target="_blank" rel="noopener">https://blog.kuoruan.com/48.html</a>  （搬瓦工搭建Shadowsocks并优化速度）</p>
<p><a href="https://github.com/iMeiji/shadowsocks_install/blob/master/shadowsocksR-wiki/config.json.md">https://github.com/iMeiji/shadowsocks_install/blob/master/shadowsocksR-wiki/config.json.md</a>  (SSR配置文件更改)</p>
<p><a href="https://github.com/racaljk/hosts/blob/master/README.md">https://github.com/racaljk/hosts/blob/master/README.md</a>  （Hosts文件）</p>
<h2 id="谷歌镜像网站"><a href="#谷歌镜像网站" class="headerlink" title="谷歌镜像网站"></a>谷歌镜像网站</h2><p><a href="https://www.uedbox.com/post/54776/" target="_blank" rel="noopener">https://www.uedbox.com/post/54776/</a> (体验盒子)<br><a href="http://gufenso.coderschool.cn/" target="_blank" rel="noopener">http://gufenso.coderschool.cn/</a> (谷粉搜导航，可以临时用一下谷歌搜索)</p>
<h2 id="Vultr搭建VPS相关教程："><a href="#Vultr搭建VPS相关教程：" class="headerlink" title="Vultr搭建VPS相关教程："></a>Vultr搭建VPS相关教程：</h2><p><a href="https://www.jiongjun.cc/vultr/315.html" target="_blank" rel="noopener">https://www.jiongjun.cc/vultr/315.html</a>  (购买和搭建VPS详细教程)</p>
<p><a href="http://yucc.me/p/b4d20b2d/" target="_blank" rel="noopener">http://yucc.me/p/b4d20b2d/</a>  (简略版教程)</p>
<h2 id="Shadowsocks-客户端下载："><a href="#Shadowsocks-客户端下载：" class="headerlink" title="Shadowsocks 客户端下载："></a>Shadowsocks 客户端下载：</h2><p><a href="https://lvii.gitbooks.io/outman/content/ss.mac.html" target="_blank" rel="noopener">https://lvii.gitbooks.io/outman/content/ss.mac.html</a></p>
<p><a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases/">https://github.com/shadowsocks/ShadowsocksX-NG/releases/</a>  （MAC版客户端下载地址）</p>
<h2 id="资源搜索："><a href="#资源搜索：" class="headerlink" title="资源搜索："></a>资源搜索：</h2><p><a href="https://www.panc.cc/" target="_blank" rel="noopener">https://www.panc.cc/</a> 胖次（最新的电影资源，会抽风）</p>
<p><a href="https://www.quzhuanpan.com/" target="_blank" rel="noopener">https://www.quzhuanpan.com/</a> 去转盘 （最新的电影，综艺）</p>
<p><a href="https://search.chongbuluo.com/" target="_blank" rel="noopener">https://search.chongbuluo.com/</a> 虫部落  （整理非常好的搜索站）</p>
<p><a href="http://www.torrent.org.cn" target="_blank" rel="noopener">http://www.torrent.org.cn</a> (种子和磁链互相转换的网站)</p>
<p><a href="https://www.btbtt.us/" target="_blank" rel="noopener">BT之家</a></p>
<p><a href="https://www.88btbtt.com/" target="_blank" rel="noopener">BT之家</a></p>
<p><a href="https://www.51btbtt.com/" target="_blank" rel="noopener">BT之家</a></p>
<p><a href="https://www.52btbtt.com/" target="_blank" rel="noopener">BT之家</a></p>
<p><a href="https://www.91btbtt.com/" target="_blank" rel="noopener">BT之家</a></p>
<p><a href="https://www.mebtbtt.com/" target="_blank" rel="noopener">BT之家</a></p>
<p><a href="https://www.btbtt.life/" target="_blank" rel="noopener">BT之家</a></p>
<p><a href="https://www.btbtt.live/" target="_blank" rel="noopener">BT之家</a></p>
<h2 id="资源下载："><a href="#资源下载：" class="headerlink" title="资源下载："></a>资源下载：</h2><p>Aria2c </p>
<p><a href="https://cowtransfer.com/" target="_blank" rel="noopener">奶牛快传(分享临时文件)</a></p>
<h2 id="计算机免费书籍GitHub合集"><a href="#计算机免费书籍GitHub合集" class="headerlink" title="计算机免费书籍GitHub合集:"></a>计算机免费书籍GitHub合集:</h2><p><a href="https://github.com/justjavac/free-programming-books-zh_CN">justjavac/free-programming-books-zh_CN</a>(免费的编程中文书籍索引)</p>
<h2 id="iOS-开发："><a href="#iOS-开发：" class="headerlink" title="iOS 开发："></a>iOS 开发：</h2><p><a href="https://github.com/Tim9Liu9/TimLiu-iOS">https://github.com/Tim9Liu9/TimLiu-iOS</a> （iOS Demo，教程等等）</p>
<p><a href="https://github.com/Aufree/trip-to-iOS">https://github.com/Aufree/trip-to-iOS</a> （偏向于教程）</p>
<p><a href="https://github.com/jobbole/awesome-ios-cn">https://github.com/jobbole/awesome-ios-cn</a> （iOS 资源大全中文版，Demo比较全）</p>
<p><a href="https://github.com/Lax/iOS-Swift-Demos">https://github.com/Lax/iOS-Swift-Demos</a> （Swift 学习资源）</p>
<p><a href="https://github.com/leecade/ios-dev-flow">https://github.com/leecade/ios-dev-flow</a> （iOS 开发证书相关）</p>
<p><a href="https://github.com/Draveness/analyze">https://github.com/Draveness/analyze</a>  （iOS开源框架源代码解析）</p>
<p><a href="https://github.com/zhouhuanqiang/LearningIOS">https://github.com/zhouhuanqiang/LearningIOS</a>  （iOS视频教程）</p>
<p><a href="http://bbs.itheima.com/thread-338489-1-1.html" target="_blank" rel="noopener">http://bbs.itheima.com/thread-338489-1-1.html</a></p>
<p><a href="https://zsisme.gitbooks.io/ios-/content/index.html" target="_blank" rel="noopener">https://zsisme.gitbooks.io/ios-/content/index.html</a>  (iOS核心动画)</p>
<p><a href="https://nshipster.cn/" target="_blank" rel="noopener">https://nshipster.cn/</a></p>
<h2 id="Vue-开发："><a href="#Vue-开发：" class="headerlink" title="Vue 开发："></a>Vue 开发：</h2><p><a href="https://github.com/vuejs/awesome-vue">vuejs/awesome-vue</a>(vue 学习资料)</p>
<p><a href="https://ke.qq.com/course/402398?taid=3214894690608094" target="_blank" rel="noopener">硅谷外卖视频课程以及很多免费课程</a></p>
<h2 id="iPhone机型介绍："><a href="#iPhone机型介绍：" class="headerlink" title="iPhone机型介绍："></a>iPhone机型介绍：</h2><p><a href="https://support.apple.com/zh-cn/HT201296" target="_blank" rel="noopener">https://support.apple.com/zh-cn/HT201296</a>  （iPhone各种机型的详细介绍）</p>
<p><a href="https://www.theiphonewiki.com/wiki/Models" target="_blank" rel="noopener">https://www.theiphonewiki.com/wiki/Models</a>  （iOS各种设备的Model的介绍）</p>
<h2 id="Android开发："><a href="#Android开发：" class="headerlink" title="Android开发："></a>Android开发：</h2><p><a href="http://bbs.itheima.com/thread-338469-1-1.html" target="_blank" rel="noopener">http://bbs.itheima.com/thread-338469-1-1.html</a></p>
<h2 id="VR开发："><a href="#VR开发：" class="headerlink" title="VR开发："></a>VR开发：</h2><p><a href="https://github.com/GeekLiB/Lee-VR-Source">https://github.com/GeekLiB/Lee-VR-Source</a></p>
<h2 id="工具网站："><a href="#工具网站：" class="headerlink" title="工具网站："></a>工具网站：</h2><p><a href="http://www.iconfont.cn/" target="_blank" rel="noopener">http://www.iconfont.cn/</a>   （阿里巴巴矢量图标库）</p>
<p><a href="https://github.com/shengxinjing/programmer-job-blacklist">https://github.com/shengxinjing/programmer-job-blacklist</a>  （程序员找工作黑名单）</p>
<h2 id="设计类网站"><a href="#设计类网站" class="headerlink" title="设计类网站:"></a>设计类网站:</h2><p><a href="http://www.xueui.cn" target="_blank" rel="noopener">http://www.xueui.cn</a></p>
<p><a href="https://magdeleine.co" target="_blank" rel="noopener">https://magdeleine.co</a>  (免费高清摄影图片下载)</p>
<p><a href="http://blog.cocoachina.com/article/73408" target="_blank" rel="noopener">http://blog.cocoachina.com/article/73408</a> （8个免费UI图标网站）</p>
<h2 id="逆向工程与加密解密："><a href="#逆向工程与加密解密：" class="headerlink" title="逆向工程与加密解密："></a>逆向工程与加密解密：</h2><p><a href="https://pan.baidu.com/pcloud/album/info?uk=1745354485&amp;album_id=3855093648109743244" target="_blank" rel="noopener">https://pan.baidu.com/pcloud/album/info?uk=1745354485&amp;album_id=3855093648109743244</a>  （百度网盘分享链接）</p>
<p><a href="https://www.hackfun.org/kali-tools/kali-tools-zh.html" target="_blank" rel="noopener">https://www.hackfun.org/kali-tools/kali-tools-zh.html</a>  （Kali工具说明书）</p>
<p><a href="http://www.he11oworld.com/tag/shentoujiaocheng/page/2/" target="_blank" rel="noopener">http://www.he11oworld.com/tag/shentoujiaocheng/page/2/</a> （渗透教程下载）</p>
<p><a href="http://daily.zhihu.com/story/3877456" target="_blank" rel="noopener">http://daily.zhihu.com/story/3877456</a> （安全网站列表）</p>
<h2 id="社区："><a href="#社区：" class="headerlink" title="社区："></a>社区：</h2><p>伯乐在线 （<a href="https://github.com/jobbole）">https://github.com/jobbole）</a></p>
<p><a href="https://www.v2ex.com/go/idev" target="_blank" rel="noopener">https://www.v2ex.com/go/idev</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://github.com/DavidWanderer/Blog/2019/04/27/Python学习笔记-Python3编码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Wanderer">
      <meta itemprop="description" content="合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stay hungry, Stay foolish.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2019/04/27/Python学习笔记-Python3编码/" class="post-title-link" itemprop="url">Python学习笔记(Python3编码)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-27 10:14:35" itemprop="dateCreated datePublished" datetime="2019-04-27T10:14:35+08:00">2019-04-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Python3中的字符串是Unicode字符串而不是字节数组。这是与Python2相比最大的差别。在Python2中，我们需要区分普通的字节为单位的字符串以及Unicode字符串。</p>
<h2 id="使用UTF-8编码和解码"><a href="#使用UTF-8编码和解码" class="headerlink" title="使用UTF-8编码和解码"></a>使用UTF-8编码和解码</h2><p>对字符串进行处理时，并不需要在意Python中Unicode字符的存储细节。当需要与外界进行数据交互时则需要完成两件事情:</p>
<ul>
<li>将字符串<strong>编码</strong>为字节</li>
<li>将字节<strong>解码</strong>为字符串</li>
</ul>
<p>如果Unicode包含的字符种类不超过64000种，我们就可以将字符ID统一存储在2字节中。遗憾的是，Unicode所包含的字符种类远不只此。诚然，我们将字符ID统一编码在3或4字节中，但是这样会使空间开销(内存和硬盘)增加3到4倍。两位Unix开发大神设计出了UTF-8动态编码方案。这种方案会动态的为每个Unicode字符分配1到4字节不等:</p>
<ul>
<li>为ASCII字符分配1字节</li>
<li>为拉丁语系(除西里尔语)的语言分配2字节</li>
<li>为其他的位于基本多语言平面的字符分配3字节</li>
<li>为剩下的字符集分配4字节，这包括一些亚洲语言及符号</li>
</ul>
<p>UTF-8是Python、Linux以及HTML的标准文本编码格式。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p><strong>编码是将字符串转化为一系列字节的过程</strong>。字符串的<strong>encode()</strong>函数所接收的第一个参数是编码方式。可选的编码方式见下表。</p>
<div style="width:400px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2019/04/27/Python学习笔记-Python3编码/Snip20190427_1.png" title="编码方式的截图"> </div>

<p>下面使用代码进行说明:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个Unicode字符串，它含有一个中文字符</span></span><br><span class="line">name = <span class="string">"中"</span></span><br><span class="line"><span class="comment"># 打印字符串的类型</span></span><br><span class="line">print(type(name))</span><br><span class="line"><span class="comment"># 打印字符串</span></span><br><span class="line">print(name)</span><br><span class="line"><span class="comment"># 打印字符串的长度，最后结果为1，说明len()获取的是字符串中字符的个数，不是字节长度</span></span><br><span class="line">print(len(name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串编码为UTF-8的字节序列</span></span><br><span class="line">ds = name.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(<span class="string">"--------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印字节序列的类型</span></span><br><span class="line">print(type(ds))</span><br><span class="line"><span class="comment"># 打印字符串编码过后的字节序列</span></span><br><span class="line">print(ds)</span><br><span class="line"><span class="comment"># 打印字节序列的长度，发现一个中文字符在UTF-8编码中占3个字节</span></span><br><span class="line">print(len(ds))</span><br></pre></td></tr></table></figure>
<p>程序的运行结果如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">中</span></span><br><span class="line"><span class="class">1</span></span><br><span class="line"><span class="class">--------</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">bytes</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">b</span>'\<span class="title">xe4</span>\<span class="title">xb8</span>\<span class="title">xad</span>'</span></span><br><span class="line"><span class="class">3</span></span><br></pre></td></tr></table></figure></p>
<p>由上面的运行结果可以知道，单个的Unicode中文字符在UTF-8编码的格式下占用了3字节的空间。当然，你也可以使用UTF-8以外的编码方式，但该Unicode字符串可能无法被指定的编码方式处理，此时Python会抛出异常。例如将上面的Unicode中文字符编码为ascii字节，就会报错。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'中'</span></span><br><span class="line">ds = name.encode(<span class="string">'ascii'</span>)</span><br><span class="line">print(ds)</span><br></pre></td></tr></table></figure></p>
<p>运行结果:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/kris/PycharmProjects/pythons_demo/Python语言及其应用/第七章/test.py"</span>, line <span class="number">26</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    ds = name.encode(<span class="string">'ascii'</span>)</span><br><span class="line">UnicodeEncodeError: <span class="string">'ascii'</span> codec can<span class="string">'t encode character '</span>\u4e2d<span class="string">' in position 0: ordinal not in range(128)</span></span><br></pre></td></tr></table></figure></p>
<p><strong>encode()</strong>函数可以接受额外的第二个参数来帮助你避免编码异常。它的默认值是’strict’,如上例所示,当函数检测到需要处理的字符串包含非ASCII字符时,会抛出UnicodeEncodeError异常。当然还有别的可选值,使用’ignore’会抛弃任何无法进行编码的字符;使用’replace’会将所有无法进行编码的字符替换为?;’backslashreplace’则会创建一个和Unicode-escape类似的Unicode字符串。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'ab中cd'</span></span><br><span class="line">print(name)</span><br><span class="line">print(name.encode(<span class="string">'ascii'</span>, <span class="string">'ignore'</span>))</span><br><span class="line">print(name.encode(<span class="string">'ascii'</span>, <span class="string">'replace'</span>))</span><br><span class="line">print(name.encode(<span class="string">'ascii'</span>, <span class="string">'backslashreplace'</span>))</span><br></pre></td></tr></table></figure></p>
<p>程序的运行结果:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ab中cd</span><br><span class="line"><span class="string">b'abcd'</span></span><br><span class="line"><span class="string">b'ab?cd'</span></span><br><span class="line"><span class="string">b'ab\\u4e2dcd'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p><strong>解码</strong>是将字节序列转化为Unicode字符串的过程。我们从外界文本源(文件、数据库、网站、网络API等)获得的所有文本都是经过编码的字节序列。重要的是需要知道它是以何种方式编码的，这样才能逆转编码过程以获得Unicode字符串。</p>
<p>问题是字节序列本身不带有任何指明编码方式的信息。之前我也提到过网站随意复制粘贴文本的风险,你也可能遇到过网页乱码的情况,本应是ASCII字符的位置却被奇怪的字符占据了,这些都是编码和解码的方式不一致导致的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">place = <span class="string">'caf\u00e9'</span></span><br><span class="line">print(place)</span><br><span class="line">print(type(place))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编码</span></span><br><span class="line">place_tytes = place.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(place_tytes)</span><br><span class="line">print(type(place_tytes))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码</span></span><br><span class="line">place2 = place_tytes.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(place2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用ASCII解码,会报错</span></span><br><span class="line"><span class="comment"># place3 = place_tytes.decode('ascii')</span></span><br><span class="line"><span class="comment"># print(place3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用其他编码格式解码</span></span><br><span class="line">place4 = place_tytes.decode(<span class="string">'latin_1'</span>)</span><br><span class="line">print(place4)</span><br><span class="line"></span><br><span class="line">place5 = place_tytes.decode(<span class="string">'windows-1252'</span>)</span><br><span class="line">print(place5)</span><br></pre></td></tr></table></figure>
<p>程序的运行结果:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">café</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">b</span>'<span class="title">caf</span>\<span class="title">xc3</span>\<span class="title">xa9</span>'</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">bytes</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">caf</span>é</span></span><br><span class="line"><span class="class"><span class="title">caf</span>Ã©</span></span><br><span class="line"><span class="class"><span class="title">caf</span>Ã©</span></span><br></pre></td></tr></table></figure></p>
<p>上面的运行结果说明，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://github.com/DavidWanderer/Blog/2019/04/02/Python学习笔记-对象和类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Wanderer">
      <meta itemprop="description" content="合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stay hungry, Stay foolish.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2019/04/02/Python学习笔记-对象和类/" class="post-title-link" itemprop="url">Python学习笔记-对象和类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-02 19:51:02" itemprop="dateCreated datePublished" datetime="2019-04-02T19:51:02+08:00">2019-04-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="使用class定义类"><a href="#使用class定义类" class="headerlink" title="使用class定义类"></a>使用class定义类</h2><p>Python中使用class关键字来定义类，下面定义一个Person类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person():</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    hunter = Person(&apos;Elmer Fudd&apos;)</span><br><span class="line">    print(hunter.name)</span><br></pre></td></tr></table></figure></p>
<p>其中 hunter = Person(‘Elmer Fudd’) 这一行代码执行的操作有:</p>
<ul>
<li><ol>
<li>查看Person类的定义</li>
</ol>
</li>
<li><ol start="2">
<li>在内存中创建一个新的对象</li>
</ol>
</li>
<li><ol start="3">
<li>调用对象的<code>__init__</code>方法,将这个新创建的对象作为self传入，并将另一个参数(‘Elmer Fudd’)作为name传入</li>
</ol>
</li>
<li><ol start="4">
<li>将name的值存入对象</li>
</ol>
</li>
<li><ol start="5">
<li>返回这个新的对象</li>
</ol>
</li>
<li><ol start="6">
<li>将名字hunter与这个对象关联<br>在类的定义中，<code>__init__</code>方法并不是必须的。只有当需要区分该类创建的不同对象时，才需要指定<code>__init__</code>方法。</li>
</ol>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>创建两个类，Car类和Yugo类，Yugo类继承自Car类，同时，Yugo类覆盖了Car类的exclaim方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exclaim</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I'm a Car!"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Yugo</span><span class="params">(Car)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exclaim</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I'm a Yugo! Much like a Car, but more Yugo-ish."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    give_me_a_car = Car()</span><br><span class="line">    give_me_a_yugo = Yugo()</span><br><span class="line">    give_me_a_car.exclaim()</span><br><span class="line">    give_me_a_yugo.exclaim()</span><br></pre></td></tr></table></figure></p>
<p>程序运行结果:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I<span class="string">'m a Car!</span></span><br><span class="line"><span class="string">I'</span>m a Yugo! Much like a Car, but more Yugo-ish.</span><br></pre></td></tr></table></figure></p>
<p>在子类中，可以覆盖任何父类的方法，包括<code>__init__()</code>。下面使用代码来说明：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MDPerson</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = <span class="string">"Doctor "</span> + name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JDPerson</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name + <span class="string">", Esquire"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    person = Person(<span class="string">'Fudd'</span>)</span><br><span class="line">    doctor = MDPerson(<span class="string">'Fudd'</span>)</span><br><span class="line">    lawyer = JDPerson(<span class="string">'Fudd'</span>)</span><br><span class="line">    print(person.name)</span><br><span class="line">    print(doctor.name)</span><br><span class="line">    print(lawyer.name)</span><br></pre></td></tr></table></figure></p>
<p>程序的运行结果:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fudd</span><br><span class="line">Doctor Fudd</span><br><span class="line">Fudd, Esquire</span><br></pre></td></tr></table></figure></p>
<p>子类可以添加父类中没有的方法。新增的方法子类对象可以调用，父类对象无法调用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exclaim</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I'm a Car!"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Yugo</span><span class="params">(Car)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exclaim</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I'm a Yugo! Much like a Car, but more Yugo-ish."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">need_a_push</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"A little help here?"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    give_me_a_car = Car()</span><br><span class="line">    give_me_a_yugo = Yugo()</span><br><span class="line">    give_me_a_yugo.need_a_push()</span><br><span class="line">    give_me_a_car.need_a_push()</span><br></pre></td></tr></table></figure></p>
<p>程序的运行结果:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A little help here?</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/kris/PycharmProjects/pythons_demo/Python语言及其应用/对象和类/创建类.py"</span>, line <span class="number">41</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    give_me_a_car.need_a_push()</span><br><span class="line">AttributeError: <span class="string">'Car'</span> object has no attribute <span class="string">'need_a_push'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="使用super-从父类获得帮助。子类中想要调用父类的方法需要使用super"><a href="#使用super-从父类获得帮助。子类中想要调用父类的方法需要使用super" class="headerlink" title="使用super()从父类获得帮助。子类中想要调用父类的方法需要使用super()"></a>使用super()从父类获得帮助。子类中想要调用父类的方法需要使用super()</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailPerson</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, email)</span>:</span></span><br><span class="line">        super().__init__(name)</span><br><span class="line">        self.email = email</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bob = EmailPerson(<span class="string">'Bob Frapples'</span>, <span class="string">'bob@frapples.com'</span>)</span><br><span class="line">    print(bob.name)</span><br><span class="line">    print(bob.email)</span><br></pre></td></tr></table></figure>
<p>在子类中定义<code>__init__()</code>方法时，父类的<code>__init__()</code>方法会被覆盖。因此在子类中，父类的初始化方法并不会被自动调用，我们必须显式调用。这样有什么好处呢？这样处理的好处在于子类在实例化的时候会经过父类，如果父类中对name属性进行了业务处理，子类也会体现出来，否则父类的name将来需要修改还需要修改一遍子类的实现。<br>程序运行结果:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bob Frapples</span><br><span class="line">bob@frapples.com</span><br></pre></td></tr></table></figure></p>
<p>Python使用self参数来找到正确对象所包含的特性和方法。通过下面的例子，说明Python在调用对象方法背后实际做的工作。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exclaim</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I'm a Car!"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    car = Car()</span><br><span class="line">    car.exclaim()</span><br><span class="line">    Car.exclaim(car)</span><br></pre></td></tr></table></figure></p>
<p>Python在背后所做的事情：</p>
<ul>
<li><ol>
<li>查找car对象所属的类(Car)</li>
</ol>
</li>
<li><ol start="2">
<li>把car对象作为self参数传给Car类所包含的exclaim()方法<br>上面程序运行的结果：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I<span class="string">'m a Car!</span></span><br><span class="line"><span class="string">I'</span>m a Car!</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="使用属性对特性进行访问和设置"><a href="#使用属性对特性进行访问和设置" class="headerlink" title="使用属性对特性进行访问和设置"></a>使用属性对特性进行访问和设置</h2><p>有一些面向对象的语言支持私有特性。这些特性无法从对象外部直接访问，我们需要编写getter和setter方法对这些私有特性进行读写操作。Python不需要getter和setter方法，因为Python里所有特性都是公开的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_name)</span>:</span></span><br><span class="line">        self.hidden_name = input_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'inside the getter'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.hidden_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, input_name)</span>:</span></span><br><span class="line">        print(<span class="string">'inside the setter'</span>)</span><br><span class="line">        self.hidden_name = input_name</span><br><span class="line"></span><br><span class="line">    name = property(get_name, set_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    fowl = Duck(<span class="string">'Howard'</span>)</span><br><span class="line">    print(fowl.name)</span><br><span class="line">    fowl.get_name()</span><br><span class="line">    fowl.name = <span class="string">'Daffy'</span></span><br><span class="line">    print(fowl.name)</span><br><span class="line">    fowl.set_name(<span class="string">'ZhangSan'</span>)</span><br><span class="line">    print(fowl.name)</span><br></pre></td></tr></table></figure></p>
<p>这两个新方法在最后一行之前都与普通的getter和setter方法没有区别，而最后一行则把这两个方法定义为了name属性。property()的第一个参数是getter方法，第二个参数是setter方法。现在当你尝试访问Duck类对象的name属性时，get_name()会被自动调用，当然也可以显式调用get_name()方法，它就像普通的getter方法一样；当对name属性进行赋值的时候，set_name()方法会被调用，也可以显式调用set_name()方法。<br>运行的结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inside the getter</span><br><span class="line">Howard</span><br><span class="line">inside the getter</span><br><span class="line">inside the setter</span><br><span class="line">inside the getter</span><br><span class="line">Daffy</span><br><span class="line">inside the setter</span><br><span class="line">inside the getter</span><br><span class="line">ZhangSan</span><br></pre></td></tr></table></figure></p>
<p>使用属性修饰符定义属性，@property 修饰符用于指示getter方法，@name.setter 用于指示setter方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_name)</span>:</span></span><br><span class="line">        self.hidden_name = input_name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'inside the getter'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.hidden_name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, input_name)</span>:</span></span><br><span class="line">        print(<span class="string">'inside the setter'</span>)</span><br><span class="line">        self.hidden_name = input_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    fowl = Duck(<span class="string">'Howard'</span>)</span><br><span class="line">    print(fowl.name)</span><br><span class="line">    <span class="comment"># fowl.get_name()</span></span><br><span class="line">    fowl.name = <span class="string">'Daffy'</span></span><br><span class="line">    print(fowl.name)</span><br><span class="line">    <span class="comment"># fowl.set_name('ZhangSan')</span></span><br><span class="line">    print(fowl.name)</span><br><span class="line">    print(fowl.hidden_name)</span><br><span class="line">    fowl.hidden_name = <span class="string">"lisi"</span></span><br><span class="line">    print(fowl.hidden_name)</span><br></pre></td></tr></table></figure></p>
<p>仍然可以像之前一样访问属性一样访问name，但是这里没有了显式的get_name()和set_name()方法，所以我注掉了显式调用的代码，不然会报错。如果有人猜到在类的内部用的变量名是hidden_name,他仍然可以直接通过fowl.hidden_name进行读写操作。运行结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inside the getter</span><br><span class="line">Howard</span><br><span class="line">inside the setter</span><br><span class="line">inside the getter</span><br><span class="line">Daffy</span><br><span class="line">inside the getter</span><br><span class="line">Daffy</span><br><span class="line">Daffy</span><br><span class="line">lisi</span><br></pre></td></tr></table></figure></p>
<h2 id="使用名称重整保护私有变量"><a href="#使用名称重整保护私有变量" class="headerlink" title="使用名称重整保护私有变量"></a>使用名称重整保护私有变量</h2><p>前面的Duck例子中，为了隐藏内部的变量，我们曾将其命名为hidden_name。其实，Python对那些需要刻意隐藏在类内部的特性有自己的命名规范：由连续的两个下划线开头<code>(__)</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_name)</span>:</span></span><br><span class="line">        self.__name = input_name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'inside the getter'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, input_name)</span>:</span></span><br><span class="line">        print(<span class="string">'inside the setter'</span>)</span><br><span class="line">        self.__name = input_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    fowl = Duck(<span class="string">'Howard'</span>)</span><br><span class="line">    print(fowl.name)</span><br><span class="line">    fowl.name = <span class="string">'Donald'</span></span><br><span class="line">    print(fowl.name)</span><br><span class="line">    <span class="comment"># print(fowl.__name)</span></span><br><span class="line">    fowl.__name = <span class="string">"zhangsan"</span></span><br><span class="line">    print(fowl.name)</span><br><span class="line">    print(fowl._Duck__name)</span><br></pre></td></tr></table></figure></p>
<p>这种命名规范本质上并没有把变量变成私有，但是Python确实将它的名字重整了，让外部的代码无法使用。最后一行打印可以成功绕过getter方法，但是这种命名重整能在一定程度上避免我们无意或有意的对变量进行直接访问。<br>运行结果:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inside the getter</span><br><span class="line">Howard</span><br><span class="line">inside the setter</span><br><span class="line">inside the getter</span><br><span class="line">Donald</span><br><span class="line">inside the getter</span><br><span class="line">Donald</span><br><span class="line">Donald</span><br></pre></td></tr></table></figure></p>
<h2 id="方法的类型"><a href="#方法的类型" class="headerlink" title="方法的类型"></a>方法的类型</h2><ul>
<li>1.实例方法</li>
<li>2.类方法(@classmethod)</li>
<li>3.静态方法(@staticmethod)</li>
</ul>
<p>有些数据(变量) 和函数(方法)是类本身的一部分，还有一些是由类创建的实例的一部分。在类的定义中，以self作为第一个参数的方法都是实例方法。他们在创建自定义类时最常见。实例方法的首个参数是self，当它被调用时，Python会把调用该方法的对象作为self参数传入。与之相对，类方法会作用于整个类，对类作出的任何改变会对它的所有实例对象产生影响。在类定义内部，用前缀修饰符@classmethod指定的方法都是类方法。与实例方法类似，类方法的第一个参数是类本身。在Python中，这个参数常被写作cls,因为全程class是保留字，在这里我们无法使用。下面的例子中，我们为A定义一个类方法来记录一共多少个类A的对象被创建：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        A.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exclaim</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I'm an A!"</span>)</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kids</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">"A has"</span>, cls.count, <span class="string">"little objects."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    easy_a = A()</span><br><span class="line">    breezy_a = A()</span><br><span class="line">    wheezy_a = A()</span><br><span class="line">    A.kids()</span><br><span class="line">    print(A.count)</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，在kids()方法中，我们使用的是cls.count，它与A.count的作用一样。<br>运行结果:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A has <span class="number">3</span> little objects.</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>类定义中的方法还存在第三种类型，它既不会影响类，也不会影响对象。他们出现在类的定义中仅仅是为了方便，这种类型的方法被称为静态方法，使用@staticmethod修饰，它既不需要self参数也不需要class参数。下面的例子中的静态方法是一则CoyoteWeapon的广告:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoyoteWeapon</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">commercial</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'This CoyoteWeapon has been brought to you by Acme'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    CoyoteWeapon.commercial()</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，我们甚至都不用创建任何CoyoteWeapon类的对象就可以调用这个方法，句法优雅不失风格!</p>
<h2 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h2><p>Python中有些特殊的方法，这些特殊方法的名称以双下划线<code>(__)</code>开头和结束，有时也被称作<strong>魔术方法</strong>。<br>下面列出常见的魔术方法：</p>
<ul>
<li>1.和比较相关的魔术方法</li>
</ul>
<div style="width:400px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2019/04/02/Python学习笔记-对象和类/Snip20190418_1.png" title="和比较相关的魔术方法截图"> </div>


<ul>
<li>2.和数学相关的魔术方法</li>
</ul>
<div style="width:400px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2019/04/02/Python学习笔记-对象和类/Snip20190418_3.png" title="和数学相关的魔术方法截图"> </div>


<ul>
<li>3.其他种类的魔术方法</li>
</ul>
<div style="width:400px; margin:0px; padding:0px; align:left;"> <img src="/Blog/2019/04/02/Python学习笔记-对象和类/Snip20190418_2.png" title="其他种类的魔术方法截图"> </div>


<p>下面定义魔术方法<code>__eq__()</code>和<code>__str__()</code>、<code>__repr__()</code>,看看运行的结果如何。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.text.lower() == other.text.lower()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.text</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Word("'</span>+self.text+<span class="string">'")'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    first = Word(<span class="string">'ha'</span>)</span><br><span class="line">    print(first)</span><br><span class="line">    print(first == Word(<span class="string">'Ha'</span>))</span><br></pre></td></tr></table></figure></p>
<p>定义<code>__eq__()</code>魔术方法方便同一类型的对象进行比较。定义 <code>__str__()</code>魔术方法方便print方法打印对象的相关信息，定义 <code>__repr__()</code> 魔术方法方便控制台输出对象的相关信息。<br>程序的运行结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ha</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/Blog/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/Blog/">1</a><a class="page-number" href="/Blog/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/Blog/page/4/">4</a><a class="extend next" rel="next" href="/Blog/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wanderer</p>
  <div class="site-description" itemprop="description">合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/Blog/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/Blog/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/Blog/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wanderer</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/Blog/lib/anime.min.js"></script>
  <script src="/Blog/lib/velocity/velocity.min.js"></script>
  <script src="/Blog/lib/velocity/velocity.ui.min.js"></script>
<script src="/Blog/js/utils.js"></script><script src="/Blog/js/motion.js"></script>
<script src="/Blog/js/schemes/pisces.js"></script>
<script src="/Blog/js/next-boot.js"></script>



  















  

  

</body>
</html>
